<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>【Golang修养之路】Go垃圾回收：三色标记法、混合写屏障机制 | Miraclo</title><meta name="author" content="Miraclo"><meta name="copyright" content="Miraclo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="来自：刘丹冰 视频链接地址：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1wz4y1y7Kd 笔记地址：https:&#x2F;&#x2F;www.yuque.com&#x2F;aceld&#x2F;golang&#x2F;zhzanb#2a81bdfb  Golang中GC垃圾回收机制：三色标记法、混合写屏障机制  垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不"><meta property="og:type" content="article"><meta property="og:title" content="【Golang修养之路】Go垃圾回收：三色标记法、混合写屏障机制"><meta property="og:url" content="http://unicorn-acc.github.io/posts/25056.html"><meta property="og:site_name" content="Miraclo"><meta property="og:description" content="来自：刘丹冰 视频链接地址：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1wz4y1y7Kd 笔记地址：https:&#x2F;&#x2F;www.yuque.com&#x2F;aceld&#x2F;golang&#x2F;zhzanb#2a81bdfb  Golang中GC垃圾回收机制：三色标记法、混合写屏障机制  垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg"><meta property="article:published_time" content="2023-03-26T21:24:22.000Z"><meta property="article:modified_time" content="2023-07-27T14:53:07.776Z"><meta property="article:author" content="Miraclo"><meta property="article:tag" content="Golang"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://unicorn-acc.github.io/posts/25056"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:2e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:800,languages:{author:"作者: Miraclo",link:"链接: ",source:"来源: Miraclo",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Golang修养之路】Go垃圾回收：三色标记法、混合写屏障机制",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-07-27 14:53:07"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mouth.css"><link rel="stylesheet" href="/css/codecolor.css"><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Miraclo</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Golang修养之路】Go垃圾回收：三色标记法、混合写屏障机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-26T21:24:22.000Z" title="发表于 2023-03-26 21:24:22">2023-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/Golang%E5%9F%BA%E7%A1%80/">Golang基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="【Golang修养之路】Go垃圾回收：三色标记法、混合写屏障机制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><p>来自：刘丹冰</p><p>视频链接地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wz4y1y7Kd">https://www.bilibili.com/video/BV1wz4y1y7Kd</a></p><p>笔记地址：https://www.yuque.com/aceld/golang/zhzanb#2a81bdfb</p></blockquote><h1 id="golang中gc垃圾回收机制三色标记法混合写屏障机制">Golang中GC垃圾回收机制：三色标记法、混合写屏障机制</h1><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1650786480776-52768cf0-0457-4875-a390-543ed516861f.jpeg"></p><p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。</p><p>Golang在GC的演进过程中也经历了很多次变革，Go V1.3之前的标记-清除(mark and sweep)算法，Go V1.3之前的标记-清扫(mark and sweep)的缺点</p><ul><li>Go V1.5的三色并发标记法</li><li>Go V1.5的三色标记为什么需要STW</li><li>Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )</li><li>Go V1.8混合写屏障机制</li><li>Go V1.8混合写屏障机制的全场景分析</li></ul><h2 id="一go-v1.3之前的标记-清除mark-and-sweep算法">一、Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>接下来我们来看一下在Golang1.3之前的时候主要用的普通的标记-清除算法，此算法主要有两个主要的步骤：</p><ul><li>标记(Mark phase)</li><li>清除(Sweep phase)</li></ul><h3 id="标记清除算法的具体步骤">1 标记清除算法的具体步骤</h3><p><strong>第一步</strong>，暂停程序业务逻辑, 分类出可达和不可达的对象，然后做上标记。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1650787873045-d038fe47-4898-4b07-9e16-007bebb6fb9c.png"></p><p>图中表示是程序与对象的可达关系，目前程序的可达对象有对象1-2-3，对象4-7等五个对象。</p><p><strong>第二步</strong>, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示： <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1650787891194-883ec541-5f13-4934-9274-080e5f44cf5e.png"></p><p>所以对象1-2-3、对象4-7等五个对象被做上标记。</p><p><strong>第三步</strong>, 标记完了之后，然后开始清除未标记的对象. 结果如下。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1650787913616-ecf21ee2-c247-4401-9d3e-5e2fa278726f.png"></p><p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 <code>STW(stop the world)</code>，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以STW也是一些回收机制最大的难题和希望优化的点。所以在执行到第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕。</p><p><strong>第四步</strong>, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p><p>以上便是标记-清除（mark and sweep）回收的算法。</p><h3 id="标记-清除mark-and-sweep的缺点">2 标记-清除(mark and sweep)的缺点</h3><p>标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题。</p><ul><li>STW，stop the world；让程序暂停，程序出现卡顿 <strong>(重要问题)</strong>；</li><li>标记需要扫描整个heap；</li><li>清除数据会产生heap碎片。</li></ul><p>Go V1.3版本之前就是以上来实施的, 在执行GC的基本流程就是首先启动STW暂停，然后执行标记，再执行数据回收，最后停止STW，如图所示。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1650787936233-9002040d-220b-4af6-8e51-75d7887569b4.png"></p><p>从上图来看，全部的GC时间都是包裹在STW范围之内的，这样貌似程序暂停的时间过长，影响程序的运行性能。所以Go V1.3 做了简单的优化,将STW的步骤提前, 减少STW暂停的时间范围.如下所示</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1650788071197-26a29703-0fb5-43f4-afc5-87a35fc78a4b.png"> 上图主要是将STW的步骤提前了一步，因为在Sweep清除的时候，可以不需要STW停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题。</p><p>但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是<strong>mark-and-sweep 算法会暂停整个程序</strong> 。</p><p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用<strong>三色并发标记法</strong>来优化这个问题.</p><h2 id="二go-v1.5的三色并发标记法">二、Go V1.5的三色并发标记法</h2><p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的<strong>STW(stop the world)</strong>，所谓<strong>三色标记法</strong>实际上就是通过三个阶段的标记来确定清楚的对象都有哪些？我们来看一下具体的过程。</p><p><strong>第一步</strong> , 每次新创建的对象，默认的颜色都是标记为“白色”，如图所示。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651035738281-051f7a89-e07f-418c-ad0e-7cb94ef1a3b8.png"></p><p>上图所示，我们的程序可抵达的内存对象关系如左图所示，右边的标记表，是用来记录目前每个对象的标记颜色分类。这里面需要注意的是，所谓“程序”，则是一些对象的根节点集合。所以我们如果将“程序”展开，会得到类似如下的表现形式，如图所示。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651035821416-b0ad644e-ef8e-440a-bbf4-b9e24a7e0257.jpeg"></p><p><strong>第二步</strong>, 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合如图所示。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651035842467-7341846f-6dee-4f8b-ad37-dc9723aa6407.jpeg"> 这里 要注意的是，本次遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。</p><p><strong>第三步</strong>, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，如图所示。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651035859950-96053775-24f7-4bdc-a1fb-295747055b3e.jpeg"> 这一次遍历是只扫描灰色对象，将灰色对象的第一层遍历可抵达的对象由白色变为灰色，如：对象2、对象7. 而之前的灰色对象1和对象4则会被标记为黑色，同时由灰色标记表移动到黑色标记表中。</p><p><strong>第四步</strong>, 重复<strong>第三步</strong>, 直到灰色中无任何对象，如图所示。 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651035907012-927d6cbc-686b-4f81-a1de-097ac7598a8e.jpeg"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651035916208-9c293dc0-8988-4180-a9b7-412e2599af0e.jpeg"></p><p>当我们全部的可达对象都遍历完后，灰色标记表将不再存在灰色对象，目前全部内存的数据只有两种颜色，黑色和白色。那么黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除，白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。</p><p><strong>第五步</strong>: 回收所有的白色标记表的对象. 也就是回收垃圾，如图所示。</p><p>以上我们将全部的白色对象进行删除回收，<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651035960263-e50436a6-4a3c-48f9-82cb-bb5729d71116.jpeg">剩下的就是全部依赖的黑色对象。</p><p>以上便是<code>三色并发标记法</code>，不难看出，我们上面已经清楚的体现<code>三色</code>的特性。但是这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，<strong>为了在GC过程中保证数据的安全，我们在开始三色标记之前就会加上STW，在扫描确定黑白对象之后再放开STW。但是很明显这样的GC扫描的性能实在是太低了。</strong></p><p>那么<strong>Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</strong></p><h2 id="三没有stw的三色标记法存在什么问题">三、没有STW的三色标记法存在什么问题</h2><p>先抛砖引玉，我们加入如果没有STW，那么也就不会再存在性能上的问题，那么接下来我们假设如果三色标记法不加入STW会发生什么事情？</p><p>我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性，<strong>我们来看看一个场景，如果三色标记法, 标记过程不使用STW将会发生什么事情?</strong></p><p>我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651035994109-83972e84-be65-4950-b9bf-a48b676856a5.jpeg"></p><p>现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，<font color="red">如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。</font></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036029588-29e317e6-8f92-41ca-a28e-65153913d227.jpeg"></p><p>与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036292354-f70d8185-66a2-4478-9036-b4de940285c5.jpeg"> 然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036347628-d63c17c4-7cee-4149-8ce9-13cc11bbd343.jpeg"></p><p>那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036362636-5a98e196-e1cd-49fc-9542-1cb0772a41c4.jpeg"> 但是最后我们才发现，本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。</p><p>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</p><ul><li>条件1: 一个白色对象被黑色对象引用<strong>(白色被挂在黑色下)</strong></li><li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏<strong>(灰色同时丢了该白色)</strong> 如果当以上两个条件同时满足时，就会出现对象丢失现象!</li></ul><p>并且，如图所示的场景中，如果示例中的白色对象3还有很多下游对象的话, 也会一并都清理掉。</p><p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是<strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p><h3 id="屏障机制">1 屏障机制</h3><p>我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。 这两种方式就是“强三色不变式”和“弱三色不变式”。</p><h4 id="强-弱-三色不变式">(1) “强-弱” 三色不变式</h4><ul><li><strong>强三色不变式</strong></li></ul><p>不存在黑色对象引用到白色对象的指针。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036383192-cb6b9fe9-4946-47da-bb9a-643f0c38a654.jpeg"></p><p>强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p><ul><li><strong>弱三色不变式</strong></li></ul><p>所有被黑色对象引用的白色对象都处于灰色保护状态。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036404003-e0ea569e-7a8a-4d9f-a08f-4bb9ed5c64ed.jpeg"></p><p>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p><p><strong>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。</strong></p><h4 id="插入屏障">(2) 插入屏障</h4><p><code>具体操作</code>: <strong>在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</strong></p><p><code>满足</code>: <strong>强三色不变式</strong>. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p><p>伪码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;   <br>  <span class="hljs-comment">//1</span><br>  标记灰色(新下游对象ptr)   <br>  <br>  <span class="hljs-comment">//2</span><br>  当前下游对象slot = 新下游对象ptr  				  <br>&#125;<br></code></pre></td></tr></table></figure><p>场景：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">A.添加下游对象(<span class="hljs-literal">nil</span>, B)   <span class="hljs-comment">//A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span><br>A.添加下游对象(C, B)     <span class="hljs-comment">//A 将下游对象C 更换为B，  B被标记为灰色</span><br></code></pre></td></tr></table></figure><p>这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在<strong>栈空间的对象操作中不使用</strong>. 而仅仅使用在堆空间对象的操作中.</p><p>​ 接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036442131-91f36e55-5c94-4931-a140-58ff5627c681.jpeg"></p><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036449149-2fb53d7c-d351-4305-84a8-7a1b51806ce4.jpeg"></p><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036456806-6b1aeb27-831d-43d9-a79e-4dad49fea07d.jpeg"></p><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036465710-e260440e-b53d-4f76-a826-842e28666efe.jpeg"></p><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036474130-755abe1f-d070-47e6-93cf-7aa129489206.jpeg"></p><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036481384-c4e44929-09e4-4a05-81bb-b5e9ed195982.jpeg"></p><p>​ <font color="red">但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9). 所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</font></p><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036522462-5e0c1ea9-e136-45c8-9648-bf691b270431.jpeg"></p><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036531031-d37d4239-9b13-4d0e-a9cc-d7bc230d56a8.jpeg"></p><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036538543-d84895c0-451d-4c49-9c67-f77dcf5a3ae9.jpeg"></p><hr><p>​ 最后将栈和堆空间 扫描剩余的全部 白色节点清除. 这次STW大约的时间在10~100ms间.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036559017-4564c417-9059-415c-aa81-d9504ac4e00b.jpeg"></p><h4 id="删除屏障">(3) 删除屏障</h4><p><code>具体操作</code>: <strong>被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</strong></p><p><code>满足</code>: <strong>弱三色不变式</strong>. (保护灰色对象到白色对象的路径不会断)</p><p>伪代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;<br>  <span class="hljs-comment">//1</span><br>  <span class="hljs-keyword">if</span> (当前下游对象slot是灰色 || 当前下游对象slot是白色) &#123;<br>  		标记灰色(当前下游对象slot)     <span class="hljs-comment">//slot为被删除对象， 标记为灰色</span><br>  &#125;<br>  <br>  <span class="hljs-comment">//2</span><br>  当前下游对象slot = 新下游对象ptr<br>&#125;<br></code></pre></td></tr></table></figure><p>场景：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">A.添加下游对象(B, <span class="hljs-literal">nil</span>)   <span class="hljs-comment">//A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)</span><br>A.添加下游对象(B, C)		 <span class="hljs-comment">//A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)</span><br></code></pre></td></tr></table></figure><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036621717-80ea507c-99a9-4e61-9bde-b4cd33f478f4-167975786274215.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036629775-bc69d08e-c270-46ad-b82b-5ad0d0bdcb64-167975786274217.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036637089-52a0fc99-7805-40d0-aee7-4124017e90c8-167975786274219.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036644794-05a69ec6-70c9-44c7-9493-44028ba4df7f-167975786274221.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036653171-57e34942-2091-4d76-83f3-0b084ebd577d-167975786274223.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036660503-4f49f494-8ede-45dd-8a4c-bfa5499b307a-167975786274225.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036668136-8592bd0f-2210-48d9-b43d-7c4a2e16a287-167975786274227.jpeg"></p><p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p><h2 id="四go-v1.8的混合写屏障hybrid-write-barrier机制">四、Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p><ul><li>插入写屏障：<strong>结束时需要STW来重新扫描栈</strong>，标记栈上引用的白色对象的存活；</li><li>删除写屏障：<strong>回收精度低</strong>，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</li></ul><p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p><h3 id="混合写屏障规则">1 混合写屏障规则</h3><p>具体操作:</p><p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p><p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p><p>3、被删除的对象标记为灰色。</p><p>4、被添加的对象标记为灰色。</p><p>满足: 变形的<strong>弱三色不变式.</strong></p><blockquote><p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p><p>总结：</p><p>​ Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p></blockquote><p>伪代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;<br>  	<span class="hljs-comment">//1 </span><br>	标记灰色(当前下游对象slot)    <span class="hljs-comment">//只要当前下游对象被移走，就标记灰色</span><br>  	<br>  	<span class="hljs-comment">//2 </span><br>  	标记灰色(新下游对象ptr)<br>  		<br>  	<span class="hljs-comment">//3</span><br>  	当前下游对象slot = 新下游对象ptr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="混合写屏障的具体场景分析">2 混合写屏障的具体场景分析</h3><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><blockquote><p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p></blockquote><h4 id="gc开始扫描栈区将可达对象全部标记为黑">GC开始：扫描栈区，将可达对象全部标记为黑</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036708530-f7c50de5-6a63-45dc-baef-f53b1b42eb62.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036716310-65729a9c-d8df-40ce-9c2b-d35228278791.jpeg"></p><h4 id="场景一-对象被一个堆对象删除引用成为栈对象的下游">场景一： 对象被一个堆对象删除引用，成为栈对象的下游</h4><p>伪代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用</span><br>栈对象<span class="hljs-number">1</span>-&gt;对象<span class="hljs-number">7</span> = 堆对象<span class="hljs-number">7</span>；  <span class="hljs-comment">//将堆对象7 挂在 栈对象1 下游</span><br>堆对象<span class="hljs-number">4</span>-&gt;对象<span class="hljs-number">7</span> = null；    <span class="hljs-comment">//对象4 删除引用 对象7</span><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036737874-a2f71441-c4f9-4f74-8c8a-c5a53bd35d4c.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036745104-24b7bf17-27b9-4531-97b7-48c5b7e64fac.jpeg"></p><h4 id="场景二-对象被一个栈对象删除引用成为另一个栈对象的下游">场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</h4><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">new</span> 栈对象<span class="hljs-number">9</span>；<br>对象<span class="hljs-number">8</span>-&gt;对象<span class="hljs-number">3</span> = 对象<span class="hljs-number">3</span>；      <span class="hljs-comment">//将栈对象3 挂在 栈对象9 下游</span><br>对象<span class="hljs-number">2</span>-&gt;对象<span class="hljs-number">3</span> = null；      <span class="hljs-comment">//对象2 删除引用 对象3</span><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036778055-bda31c21-45dc-4602-9241-11a33b6393a6.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036791814-78eed337-a9ac-42d9-bcd8-99a21c01111c.jpeg"></p><h4 id="场景三对象被一个堆对象删除引用成为另一个堆对象的下游">场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</h4><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">堆对象<span class="hljs-number">10</span>-&gt;对象<span class="hljs-number">7</span> = 堆对象<span class="hljs-number">7</span>；       <span class="hljs-comment">//将堆对象7 挂在 堆对象10 下游</span><br>堆对象<span class="hljs-number">4</span>-&gt;对象<span class="hljs-number">7</span> = null；         <span class="hljs-comment">//对象4 删除引用 对象7</span><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036826144-893174fb-0111-4838-9f7d-38fe2f89648a.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036833484-a18064d9-1329-42d7-8687-8a029542e85e.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036840569-f50df9db-5219-48fe-83ff-c3545ed4dec4.jpeg"></p><h4 id="场景四对象从一个栈对象删除引用成为另一个堆对象的下游">场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</h4><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">堆对象<span class="hljs-number">10</span>-&gt;对象<span class="hljs-number">7</span> = 堆对象<span class="hljs-number">7</span>；       <span class="hljs-comment">//将堆对象7 挂在 堆对象10 下游</span><br>堆对象<span class="hljs-number">4</span>-&gt;对象<span class="hljs-number">7</span> = null；         <span class="hljs-comment">//对象4 删除引用 对象7</span><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036859560-21a75ea4-ee66-46ae-81bc-ce4e697c3814.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036864959-929ec428-e8d8-48a9-aaeb-e2589723ec62.jpeg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs04/1651036876957-976a0ac6-6c82-4eca-88f3-10180782281c.jpeg"></p><p>​ Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p><h2 id="五总结">五、总结</h2><p>以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p><p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p><p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p><blockquote><p>视频总结：https://www.bilibili.com/video/BV1wz4y1y7Kd?p=14</p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Unicorn-acc.github.io">Miraclo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://unicorn-acc.github.io/posts/25056.html">http://unicorn-acc.github.io/posts/25056.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Unicorn-acc.github.io" target="_blank">Miraclo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/23688.html"><img class="prev-cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p9273e.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【GoWeb框架-Gin框架】路由、请求参数、响应、模板渲染、会话、中间件</div></div></a></div><div class="next-post pull-right"><a href="/posts/35945.html"><img class="next-cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p9273e.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Go爬虫】Go爬取静态数据、动态数据、并发爬取</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/16244.html" title="【Golang 快速入门3】Go Modules + 生态拓展"><img class="cover" src="https://w.wallhaven.cc/full/1p/wallhaven-1pjml1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="title">【Golang 快速入门3】Go Modules + 生态拓展</div></div></a></div><div><a href="/posts/23688.html" title="【GoWeb框架-Gin框架】路由、请求参数、响应、模板渲染、会话、中间件"><img class="cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p9273e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-28</div><div class="title">【GoWeb框架-Gin框架】路由、请求参数、响应、模板渲染、会话、中间件</div></div></a></div><div><a href="/posts/16215.html" title="【Golang修养之路】GMP协程调度器原理及GMP设计思想"><img class="cover" src="https://w.wallhaven.cc/full/x6/wallhaven-x619o3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">【Golang修养之路】GMP协程调度器原理及GMP设计思想</div></div></a></div><div><a href="/posts/53840.html" title="【Golang 快速入门2】高级语法：反射 + 并发"><img class="cover" src="https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="title">【Golang 快速入门2】高级语法：反射 + 并发</div></div></a></div><div><a href="/posts/35945.html" title="【Go爬虫】Go爬取静态数据、动态数据、并发爬取"><img class="cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p9273e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">【Go爬虫】Go爬取静态数据、动态数据、并发爬取</div></div></a></div><div><a href="/posts/43853.html" title="【Go项目】Gin+Gorm实现简单备忘录"><img class="cover" src="https://w.wallhaven.cc/full/1p/wallhaven-1p1qjg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">【Go项目】Gin+Gorm实现简单备忘录</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#golang%E4%B8%ADgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C%E6%9C%BA%E5%88%B6"><span class="toc-text">Golang中GC垃圾回收机制：三色标记法、混合写屏障机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80go-v1.3%E4%B9%8B%E5%89%8D%E7%9A%84%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4mark-and-sweep%E7%AE%97%E6%B3%95"><span class="toc-text">一、Go V1.3之前的标记-清除(mark and sweep)算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-text">1 标记清除算法的具体步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4mark-and-sweep%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">2 标记-清除(mark and sweep)的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8Cgo-v1.5%E7%9A%84%E4%B8%89%E8%89%B2%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="toc-text">二、Go V1.5的三色并发标记法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%B2%A1%E6%9C%89stw%E7%9A%84%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">三、没有STW的三色标记法存在什么问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C%E6%9C%BA%E5%88%B6"><span class="toc-text">1 屏障机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA-%E5%BC%B1-%E4%B8%89%E8%89%B2%E4%B8%8D%E5%8F%98%E5%BC%8F"><span class="toc-text">(1) “强-弱” 三色不变式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%B1%8F%E9%9A%9C"><span class="toc-text">(2) 插入屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B1%8F%E9%9A%9C"><span class="toc-text">(3) 删除屏障</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9Bgo-v1.8%E7%9A%84%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9Chybrid-write-barrier%E6%9C%BA%E5%88%B6"><span class="toc-text">四、Go V1.8的混合写屏障(hybrid write barrier)机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C%E8%A7%84%E5%88%99"><span class="toc-text">1 混合写屏障规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-text">2 混合写屏障的具体场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gc%E5%BC%80%E5%A7%8B%E6%89%AB%E6%8F%8F%E6%A0%88%E5%8C%BA%E5%B0%86%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1%E5%85%A8%E9%83%A8%E6%A0%87%E8%AE%B0%E4%B8%BA%E9%BB%91"><span class="toc-text">GC开始：扫描栈区，将可达对象全部标记为黑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80-%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%B8%80%E4%B8%AA%E5%A0%86%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4%E5%BC%95%E7%94%A8%E6%88%90%E4%B8%BA%E6%A0%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8B%E6%B8%B8"><span class="toc-text">场景一： 对象被一个堆对象删除引用，成为栈对象的下游</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C-%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4%E5%BC%95%E7%94%A8%E6%88%90%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8B%E6%B8%B8"><span class="toc-text">场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%B8%80%E4%B8%AA%E5%A0%86%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4%E5%BC%95%E7%94%A8%E6%88%90%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%A0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8B%E6%B8%B8"><span class="toc-text">场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%9B%9B%E5%AF%B9%E8%B1%A1%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4%E5%BC%95%E7%94%A8%E6%88%90%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%A0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8B%E6%B8%B8"><span class="toc-text">场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Miraclo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人只有在走上坡路的时候才会累和迷茫。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.1},options:{renderActions:{findScript:[10,t=>{for(const n of document.querySelectorAll('script[type^="math/tex"]')){var e=!!n.type.match(/; *mode=display/),e=new t.options.MathItem(n.textContent,t.inputJax[0],e),a=document.createTextNode("");n.parentNode.replaceChild(a,n),e.start={node:a,delim:"",n:0},e.end={node:a,delim:"",n:0},t.math.push(e)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t.hasAttribute("display")?btf.wrap(t,"div",{class:"mathjax-overflow"}):btf.wrap(t,"span",{class:"mathjax-overflow"})})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script></div><link rel="stylesheet" href="/css/Lete.css"><script src="/js/custom.js"></script><script src="/js/mouth.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1s"),arr[i].setAttribute("data-wow-delay","1ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>