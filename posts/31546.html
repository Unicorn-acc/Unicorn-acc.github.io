<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>JUC-05--共享模型之工具【线程池、JUC并发编程、读写锁、Semaphore信号量、CountdownLatch倒计时锁、CyclicBarrier循环栅栏、CurrentHashMap】 | Miraclo</title><meta name="author" content="Miraclo"><meta name="copyright" content="Miraclo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="8.共享模型之工具 8.1 线程池 8.1.1 自定义线程池  步骤1：自定义拒绝策略接口 1234@FunctionalInterface &#x2F;&#x2F;拒绝策略interface RejectPolicy&lt;T&gt;&amp;#123;    void reject(BlockingQueue&lt;T&gt; queue,T task);&amp;#125; 步骤2：自定义任务队列 12345678910111"><meta property="og:type" content="article"><meta property="og:title" content="JUC-05--共享模型之工具【线程池、JUC并发编程、读写锁、Semaphore信号量、CountdownLatch倒计时锁、CyclicBarrier循环栅栏、CurrentHashMap】"><meta property="og:url" content="http://unicorn-acc.github.io/posts/31546.html"><meta property="og:site_name" content="Miraclo"><meta property="og:description" content="8.共享模型之工具 8.1 线程池 8.1.1 自定义线程池  步骤1：自定义拒绝策略接口 1234@FunctionalInterface &#x2F;&#x2F;拒绝策略interface RejectPolicy&lt;T&gt;&amp;#123;    void reject(BlockingQueue&lt;T&gt; queue,T task);&amp;#125; 步骤2：自定义任务队列 12345678910111"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w.wallhaven.cc/full/1p/wallhaven-1pjml1.jpg"><meta property="article:published_time" content="2022-12-20T14:36:02.000Z"><meta property="article:modified_time" content="2022-12-20T07:49:18.955Z"><meta property="article:author" content="Miraclo"><meta property="article:tag" content="JUC"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/1p/wallhaven-1pjml1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://unicorn-acc.github.io/posts/31546"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:2e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:800,languages:{author:"作者: Miraclo",link:"链接: ",source:"来源: Miraclo",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JUC-05--共享模型之工具【线程池、JUC并发编程、读写锁、Semaphore信号量、CountdownLatch倒计时锁、CyclicBarrier循环栅栏、CurrentHashMap】",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-12-20 07:49:18"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mouth.css"><link rel="stylesheet" href="/css/codecolor.css"><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">129</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://w.wallhaven.cc/full/1p/wallhaven-1pjml1.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Miraclo</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC-05--共享模型之工具【线程池、JUC并发编程、读写锁、Semaphore信号量、CountdownLatch倒计时锁、CyclicBarrier循环栅栏、CurrentHashMap】</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-12-20T14:36:02.000Z" title="发表于 2022-12-20 14:36:02">2022-12-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/">Java技术栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">JUC并发编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>140分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="JUC-05--共享模型之工具【线程池、JUC并发编程、读写锁、Semaphore信号量、CountdownLatch倒计时锁、CyclicBarrier循环栅栏、CurrentHashMap】"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="共享模型之工具">8.共享模型之工具</h1><h2 id="线程池">8.1 线程池</h2><h3 id="自定义线程池">8.1.1 自定义线程池</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212170927167.png"></p><p>步骤1：自定义拒绝策略接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">//拒绝策略</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RejectPolicy</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue,T task)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤2：自定义任务队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt;&#123;<br>    <span class="hljs-comment">//阻塞队列，存放任务</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-comment">//队列的最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-comment">//锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">//生产者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">fullWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">//消费者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">emptyWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br>    <span class="hljs-comment">//超时阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-comment">//将时间转换为纳秒</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">nanoTime</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(queue.size() == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//等待超时依旧没有获取，返回null</span><br>                    <span class="hljs-keyword">if</span>(nanoTime &lt;= <span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//该方法返回的是剩余时间</span><br>                    nanoTime = emptyWaitSet.awaitNanos(nanoTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(queue.size() == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T t)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().toString() + <span class="hljs-string">&quot;等待加入任务队列:&quot;</span> + t.toString());<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            System.out.println(Thread.currentThread().toString() + <span class="hljs-string">&quot;加入任务队列:&quot;</span> + t.toString());<br>            queue.addLast(t);<br>            emptyWaitSet.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//超时阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T t,<span class="hljs-type">long</span> timeout,TimeUnit timeUnit)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanoTime</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanoTime &lt;= <span class="hljs-number">0</span>)&#123;<br>                        System.out.println(<span class="hljs-string">&quot;等待超时，加入失败：&quot;</span> + t);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    System.out.println(Thread.currentThread().toString() + <span class="hljs-string">&quot;等待加入任务队列:&quot;</span> + t.toString());<br>                    nanoTime = fullWaitSet.awaitNanos(nanoTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            System.out.println(Thread.currentThread().toString() + <span class="hljs-string">&quot;加入任务队列:&quot;</span> + t.toString());<br>            queue.addLast(t);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//从形参接收拒绝策略的put方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy,T task)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(queue.size() == capacity)&#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>,task);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;加入任务队列：&quot;</span> + task);<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤3：自定义线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span>&#123;<br>    <span class="hljs-comment">//阻塞队列</span><br>    BlockingQueue&lt;Runnable&gt; taskQue;<br>    <span class="hljs-comment">//线程集合</span><br>    HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-comment">//拒绝策略</span><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize,<span class="hljs-type">long</span> timeout,TimeUnit timeUnit,<span class="hljs-type">int</span> queueCapacity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span>&#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>        taskQue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;Runnable&gt;(queueCapacity);<br>    &#125;<br>    <span class="hljs-comment">//线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br>    <span class="hljs-comment">//任务超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>    <span class="hljs-comment">//时间单元</span><br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br>    <span class="hljs-comment">//线程池的执行方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span>&#123;<br>        <span class="hljs-comment">//当线程数大于等于coreSize的时候，将任务放入阻塞队列</span><br>        <span class="hljs-comment">//当线程数小于coreSize的时候，新建一个Worker放入workers</span><br>        <span class="hljs-comment">//注意workers类不是线程安全的， 需要加锁</span><br>        <span class="hljs-keyword">synchronized</span> (workers)&#123;<br>            <span class="hljs-keyword">if</span>(workers.size() &gt;= coreSize)&#123;<br><span class="hljs-comment">//                taskQue.put(task);</span><br>                <span class="hljs-comment">//死等</span><br>                <span class="hljs-comment">//带超时等待</span><br>                <span class="hljs-comment">//让调用者放弃执行任务</span><br>                <span class="hljs-comment">//让调用者抛出异常</span><br>                <span class="hljs-comment">//让调用者自己执行任务</span><br>                taskQue.tryPut(rejectPolicy,task);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                System.out.println(Thread.currentThread().toString() + <span class="hljs-string">&quot;新增worker:&quot;</span> + worker + <span class="hljs-string">&quot;,task:&quot;</span> + task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//工作类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span>&#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//巧妙的判断</span><br>            <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = taskQue.poll(timeout,timeUnit)) != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    System.out.println(Thread.currentThread().toString() + <span class="hljs-string">&quot;正在执行:&quot;</span> + task);<br>                    task.run();<br>                &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (workers)&#123;<br>                System.out.println(Thread.currentThread().toString() + <span class="hljs-string">&quot;worker被移除:&quot;</span> + <span class="hljs-built_in">this</span>.toString());<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤4：编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPool</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPool</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-number">1</span>, (queue,task)-&gt;&#123;<br>                    <span class="hljs-comment">//死等</span><br><span class="hljs-comment">//                    queue.put(task);</span><br>            <span class="hljs-comment">//带超时等待</span><br><span class="hljs-comment">//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span><br>            <span class="hljs-comment">//让调用者放弃任务执行</span><br><span class="hljs-comment">//            System.out.println(&quot;放弃：&quot; + task);</span><br>            <span class="hljs-comment">//让调用者抛出异常</span><br><span class="hljs-comment">//            throw new RuntimeException(&quot;任务执行失败&quot; + task);</span><br>            <span class="hljs-comment">//让调用者自己执行任务</span><br>            task.run();<br>                &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            threadPool.execute(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().toString() + <span class="hljs-string">&quot;执行任务：&quot;</span> + j);<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="threadpoolexecutor">8.1.2 ThreadPoolExecutor</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212171920168.png"></p><p>说明：</p><ul><li>ScheduledThreadPoolExecutor是带调度的线程池</li><li>ThreadPoolExecutor是不带调度的线程池</li></ul><h4 id="线程池状态">1）线程池状态</h4><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p><table><thead><tr class="header"><th style="text-align:center">状态名</th><th style="text-align:center">高3位</th><th style="text-align:center">接收新任务</th><th style="text-align:center">处理阻塞队列任务</th><th style="text-align:center">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">RUNNING</td><td style="text-align:center">111</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td></tr><tr class="even"><td style="text-align:center">SHUTDOWN</td><td style="text-align:center">000</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">不会接收新任务，但会处理阻塞队列剩余 任务</td></tr><tr class="odd"><td style="text-align:center">STOP</td><td style="text-align:center">001</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">会中断正在执行的任务，并抛弃阻塞队列 任务</td></tr><tr class="even"><td style="text-align:center">TIDYING</td><td style="text-align:center">010</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">任务全执行完毕，活动线程为 0 即将进入 终结</td></tr><tr class="odd"><td style="text-align:center">TERMINATED</td><td style="text-align:center">011</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">终结状态</td></tr></tbody></table><p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</p><p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用 <strong>一次 cas 原子操作</strong> 进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// c 为旧值， ctlOf 返回结果为新值</span><br>ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));<br><span class="hljs-comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><h4 id="构造方法">2）构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><ul><li>corePoolSize 核心线程数目 (最多保留的线程数)</li><li>maximumPoolSize 最大线程数目</li><li>keepAliveTime 生存时间 - 针对救急线程</li><li>unit 时间单位 - 针对救急线程</li><li>workQueue 阻塞队列</li><li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li><li>handler 拒绝策略</li></ul><p><strong>工作方式</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212171949263.png"></p><ul><li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</p></li><li><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排 队，直到有空闲的线程。</p></li><li><p>如果队列选择了<font color="red">有界队列</font>，<strong>那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</strong></p></li><li><p><strong>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现，其它 著名框架也提供了实现</p><ul><li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li>CallerRunsPolicy 让调用者运行任务</li><li>DiscardPolicy 放弃本次任务</li><li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li><li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul></li><li><p>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212171949740.png"></p></li></ul><p>根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池。</p><h4 id="newfixedthreadpool固定大小线程池">3）newFixedThreadPool固定大小线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>特点</p><ul><li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li></ul><blockquote><p><strong>评价</strong> 适用于任务量已知，相对耗时的任务</p></blockquote><p>内部调用了：ThreadPoolExecutor的一个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>    <span class="hljs-built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure><p>默认工厂以及默认构造线程的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultThreadFactory() &#123;<br>    <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>    group = (s != <span class="hljs-literal">null</span>) ? s.getThreadGroup() :<br>    Thread.currentThread().getThreadGroup();<br>    namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>        poolNumber.getAndIncrement() +<br>        <span class="hljs-string">&quot;-thread-&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, r,<br>                          namePrefix + threadNumber.getAndIncrement(),<br>                          <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (t.isDaemon())<br>        t.setDaemon(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>        t.setPriority(Thread.NORM_PRIORITY);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认拒绝策略：抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">defaultHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortPolicy</span>();<br></code></pre></td></tr></table></figure><h4 id="newcachedthreadpool带缓冲线程池">4）newCachedThreadPool带缓冲线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>特点</p><ul><li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，<ul><li>意味着全部都是救急线程（60s 后可以回收）</li><li>救急线程可以无限创建</li></ul></li><li>队列采用了 <code>SynchronousQueue</code> 实现特点是，<strong>它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</strong></li></ul><blockquote><p><strong>评价</strong> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。</p><p>适合任务数比较密集，但每个任务执行时间较短的情况</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">SynchronousQueue&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;putting &#123;&#125; &quot;</span>, <span class="hljs-number">1</span>);<br>        integers.put(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125; putted...&quot;</span>, <span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;putting...&#123;&#125; &quot;</span>, <span class="hljs-number">2</span>);<br>        integers.put(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125; putted...&quot;</span>, <span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;taking &#123;&#125;&quot;</span>, <span class="hljs-number">1</span>);<br>        integers.take();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;taking &#123;&#125;&quot;</span>, <span class="hljs-number">2</span>);<br>        integers.take();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">11:48:15.500 c.TestSynchronousQueue [t1] - putting 1 <br>11:48:16.500 c.TestSynchronousQueue [t2] - taking 1 <br>11:48:16.500 c.TestSynchronousQueue [t1] - 1 putted... <br>11:48:16.500 c.TestSynchronousQueue [t1] - putting...2 <br>11:48:17.502 c.TestSynchronousQueue [t3] - taking 2 <br>11:48:17.503 c.TestSynchronousQueue [t1] - 2 putted... <br></code></pre></td></tr></table></figure><h4 id="newsinglethreadexecutor单线程线程池">5）newSingleThreadExecutor单线程线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：</p><p>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p><p>区别：</p><ul><li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一 个线程，保证池的正常工作</li><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ul><li>FinalizableDelegatedExecutorService 应用的是装饰器模式，在调用构造方法时将ThreadPoolExecutor对象传给了内部的ExecutorService接口。只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法，也不能重新设置线程池的大小。</li></ul></li><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul><li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ul></li></ul><h4 id="提交任务">6）提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br><span class="hljs-comment">// 提交 tasks 中所有任务</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间，时间超时后，会放弃执行后面的任务</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br></code></pre></td></tr></table></figure><p><strong>测试submit</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    Future&lt;String&gt; future = pool.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>    &#125;);<br><br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, future.get());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>    method1(pool);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">18:36:58.033 c.TestSubmit [pool-1-thread-1] - running<br>18:36:59.034 c.TestSubmit [main] - ok<br></code></pre></td></tr></table></figure><p><strong>测试invokeAll</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(<br>        () -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        &#125;,<br>        () -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>        &#125;,<br>        () -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;3&quot;</span>;<br>        &#125;<br>    ));<br><br>    futures.forEach( f -&gt;  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, f.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>    method2(pool);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">19</span>:<span class="hljs-number">33</span>:<span class="hljs-number">16.530</span> c.TestSubmit [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - begin<br><span class="hljs-number">19</span>:<span class="hljs-number">33</span>:<span class="hljs-number">17.530</span> c.TestSubmit [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - begin<br><span class="hljs-number">19</span>:<span class="hljs-number">33</span>:<span class="hljs-number">18.040</span> c.TestSubmit [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - begin<br><span class="hljs-number">19</span>:<span class="hljs-number">33</span>:<span class="hljs-number">20.051</span> c.TestSubmit [main] - <span class="hljs-number">1</span><br><span class="hljs-number">19</span>:<span class="hljs-number">33</span>:<span class="hljs-number">20.051</span> c.TestSubmit [main] - <span class="hljs-number">2</span><br><span class="hljs-number">19</span>:<span class="hljs-number">33</span>:<span class="hljs-number">20.051</span> c.TestSubmit [main] - <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>测试invokeAny</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ExecutorService pool)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pool.invokeAny(Arrays.asList(<br>        () -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin 1&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;end 1&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        &#125;,<br>        () -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin 2&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>            log.debug(<span class="hljs-string">&quot;end 2&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>        &#125;,<br>        () -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin 3&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            log.debug(<span class="hljs-string">&quot;end 3&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;3&quot;</span>;<br>        &#125;<br>    ));<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">//ExecutorService pool = Executors.newFixedThreadPool(1);</span><br>    method3(pool);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">19:44:46.314 c.TestSubmit [pool-1-thread-1] - begin 1<br>19:44:46.314 c.TestSubmit [pool-1-thread-3] - begin 3<br>19:44:46.314 c.TestSubmit [pool-1-thread-2] - begin 2<br>19:44:46.817 c.TestSubmit [pool-1-thread-2] - end 2<br>19:44:46.817 c.TestSubmit [main] - 2<br><br>19:47:16.063 c.TestSubmit [pool-1-thread-1] - begin 1<br>19:47:17.063 c.TestSubmit [pool-1-thread-1] - end 1<br>19:47:17.063 c.TestSubmit [pool-1-thread-1] - begin 2<br>19:47:17.063 c.TestSubmit [main] - 1<br></code></pre></td></tr></table></figure><h4 id="关闭线程池">7）关闭线程池</h4><p><strong>shutdown</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 SHUTDOWN</span><br><span class="hljs-comment">- 不会接收新任务</span><br><span class="hljs-comment">- 但已提交任务会执行完</span><br><span class="hljs-comment">- 此方法不会阻塞调用线程的执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        <span class="hljs-comment">// 修改线程池状态</span><br>        advanceRunState(SHUTDOWN);<br>        <span class="hljs-comment">// 仅会打断空闲线程</span><br>        interruptIdleWorkers();<br>        onShutdown(); <span class="hljs-comment">// 扩展点 ScheduledThreadPoolExecutor</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span><br>    tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>shutdownNow</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 STOP</span><br><span class="hljs-comment">- 不会接收新任务</span><br><span class="hljs-comment">- 会将队列中的任务返回</span><br><span class="hljs-comment">- 并用 interrupt 的方式中断正在执行的任务</span><br><span class="hljs-comment">*/</span><br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Runnable&gt; tasks;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        <span class="hljs-comment">// 修改线程池状态</span><br>        advanceRunState(STOP);<br>        <span class="hljs-comment">// 打断所有线程</span><br>        interruptWorkers();<br>        <span class="hljs-comment">// 获取队列中剩余任务</span><br>        tasks = drainQueue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结</span><br>    tryTerminate();<br>    <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其他方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span><br><span class="hljs-comment">// 一般task是Callable类型的时候不用此方法，因为futureTask.get方法自带等待功能。</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p><strong>测试shutdown、shutdownNow、awaitTermination</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestShutDown&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestShutDown</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        Future&lt;Integer&gt; result1 = pool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task 1 running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;task 1 finish...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;);<br><br>        Future&lt;Integer&gt; result2 = pool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task 2 running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;task 2 finish...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;);<br><br>        Future&lt;Integer&gt; result3 = pool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task 3 running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;task 3 finish...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;);<br><br>        log.debug(<span class="hljs-string">&quot;shutdown&quot;</span>);<br>        pool.shutdown();<br>        <span class="hljs-comment">//        pool.awaitTermination(3, TimeUnit.SECONDS);</span><br>        <span class="hljs-comment">//        List&lt;Runnable&gt; runnables = pool.shutdownNow();</span><br>        <span class="hljs-comment">//        log.debug(&quot;other.... &#123;&#125;&quot; , runnables);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#shutdown依旧会执行剩下的任务</span><br>20:09:13.285 c.TestShutDown [main] - shutdown<br>20:09:13.285 c.TestShutDown [pool-1-thread-1] - task 1 running...<br>20:09:13.285 c.TestShutDown [pool-1-thread-2] - task 2 running...<br>20:09:14.293 c.TestShutDown [pool-1-thread-2] - task 2 finish...<br>20:09:14.293 c.TestShutDown [pool-1-thread-1] - task 1 finish...<br>20:09:14.293 c.TestShutDown [pool-1-thread-2] - task 3 running...<br>20:09:15.303 c.TestShutDown [pool-1-thread-2] - task 3 finish...<br><span class="hljs-comment">#shutdownNow立刻停止所有任务</span><br>20:11:11.750 c.TestShutDown [main] - shutdown<br>20:11:11.750 c.TestShutDown [pool-1-thread-1] - task 1 running...<br>20:11:11.750 c.TestShutDown [pool-1-thread-2] - task 2 running...<br>20:11:11.750 c.TestShutDown [main] - other.... [java.util.concurrent.FutureTask@66d33a]<br></code></pre></td></tr></table></figure><h4 id="模式之工作模式worker-thread">8）<font color="orange">*模式之工作模式Worker Thread</font></h4><p><strong>定义</strong></p><p><strong>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。</strong>也可以将其归类为分工模式，它的典型实现 就是线程池，也体现了经典设计模式中的享元模式。</p><p>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那 么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）</p><p>注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</p><p>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成 服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</p><p><strong>饥饿现象</strong></p><p><font color="red"><strong>固定大小线程池会有饥饿现象</strong></font></p><ul><li><p>两个工人是同一个线程池中的两个线程</p></li><li><p>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作</p><ul><li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li><li>后厨做菜：没啥说的，做就是了</li></ul></li><li><p>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好</p></li><li><p>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDeadLock</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="hljs-string">&quot;地三鲜&quot;</span>, <span class="hljs-string">&quot;宫保鸡丁&quot;</span>, <span class="hljs-string">&quot;辣子鸡丁&quot;</span>, <span class="hljs-string">&quot;烤鸡翅&quot;</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">RANDOM</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">cooking</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>        executorService.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>            Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>                <span class="hljs-keyword">return</span> cooking();<br>            &#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        executorService.execute(() -&gt; &#123;</span><br><span class="hljs-comment">            log.debug(&quot;处理点餐...&quot;);</span><br><span class="hljs-comment">            Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;</span><br><span class="hljs-comment">                log.debug(&quot;做菜&quot;);</span><br><span class="hljs-comment">                return cooking();</span><br><span class="hljs-comment">            &#125;);</span><br><span class="hljs-comment">            try &#123;</span><br><span class="hljs-comment">                log.debug(&quot;上菜: &#123;&#125;&quot;, f.get());</span><br><span class="hljs-comment">            &#125; catch (InterruptedException | ExecutionException e) &#123;</span><br><span class="hljs-comment">                e.printStackTrace();</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;);</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">17:21:27.883 c.TestDeadLock [pool-1-thread-1] - 处理点餐...<br>17:21:27.891 c.TestDeadLock [pool-1-thread-2] - 做菜<br>17:21:27.891 c.TestDeadLock [pool-1-thread-1] - 上菜: 烤鸡翅<br></code></pre></td></tr></table></figure><p>当注释取消后，可能的输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">17:08:41.339 c.TestDeadLock [pool-1-thread-2] - 处理点餐...  <br>17:08:41.339 c.TestDeadLock [pool-1-thread-1] - 处理点餐... <br></code></pre></td></tr></table></figure><p><strong>解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程 池</strong>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDeadLock</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="hljs-string">&quot;地三鲜&quot;</span>, <span class="hljs-string">&quot;宫保鸡丁&quot;</span>, <span class="hljs-string">&quot;辣子鸡丁&quot;</span>, <span class="hljs-string">&quot;烤鸡翅&quot;</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">RANDOM</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">cooking</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">waiterPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cookPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>        waiterPool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>                <span class="hljs-keyword">return</span> cooking();<br>            &#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        waiterPool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>                <span class="hljs-keyword">return</span> cooking();<br>            &#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">17:25:14.626 c.TestDeadLock [pool-1-thread-1] - 处理点餐... <br>17:25:14.630 c.TestDeadLock [pool-2-thread-1] - 做菜<br>17:25:14.631 c.TestDeadLock [pool-1-thread-1] - 上菜: 地三鲜<br>17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 处理点餐... <br>17:25:14.632 c.TestDeadLock [pool-2-thread-1] - 做菜<br>17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 上菜: 辣子鸡丁<br></code></pre></td></tr></table></figure><p><strong>创建多少线程池合适</strong></p><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><p><strong>CPU 密集型运算</strong></p><p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p><p><strong>I/O 密集型运算</strong></p><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p><p>经验公式如下</p><p><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code></p><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p><p><code>4 * 100% * 100% / 50% = 8</code></p><p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p><p><code>4 * 100% * 100% / 10% = 40</code></p><h4 id="任务调度线程池">9）任务调度线程池</h4><p>在『任务调度线程池』功能加入之前(JDK1.3)，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但 由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;task 1&quot;</span>);<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;task 2&quot;</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span><br>    <span class="hljs-comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span><br>    timer.schedule(task1, <span class="hljs-number">1000</span>);<br>    timer.schedule(task2, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">20:46:09.444 c.TestTimer [main] - start... <br>20:46:10.447 c.TestTimer [Timer-0] - task 1 <br>20:46:12.448 c.TestTimer [Timer-0] - task 2 <br></code></pre></td></tr></table></figure><p>使用 ScheduledExecutorService 改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 添加两个任务，希望它们都在 1s 后执行</span><br>executor.schedule(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务1，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">2000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>&#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>executor.schedule(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务2，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>&#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">任务1，执行时间：Thu Jan 03 12:45:17 CST 2019 <br>任务2，执行时间：Thu Jan 03 12:45:17 CST 2019 <br></code></pre></td></tr></table></figure><p>scheduleAtFixedRate 例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>pool.scheduleAtFixedRate(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">21:45:43.167 c.TestTimer [main] - start... <br>21:45:44.215 c.TestTimer [pool-1-thread-1] - running... <br>21:45:45.215 c.TestTimer [pool-1-thread-1] - running... <br>21:45:46.215 c.TestTimer [pool-1-thread-1] - running... <br>21:45:47.215 c.TestTimer [pool-1-thread-1] - running... <br></code></pre></td></tr></table></figure><p>scheduleAtFixedRate 例子（任务执行时间超过了间隔时间）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>pool.scheduleAtFixedRate(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    sleep(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">21:44:30.311 c.TestTimer [main] - start... <br>21:44:31.360 c.TestTimer [pool-1-thread-1] - running... <br>21:44:33.361 c.TestTimer [pool-1-thread-1] - running... <br>21:44:35.362 c.TestTimer [pool-1-thread-1] - running... <br>21:44:37.362 c.TestTimer [pool-1-thread-1] - running...<br></code></pre></td></tr></table></figure><p>scheduleWithFixedDelay 例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>pool.scheduleWithFixedDelay(()-&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    sleep(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所 以间隔都是 3s</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">21:40:55.078 c.TestTimer [main] - start... <br>21:40:56.140 c.TestTimer [pool-1-thread-1] - running... <br>21:40:59.143 c.TestTimer [pool-1-thread-1] - running... <br>21:41:02.145 c.TestTimer [pool-1-thread-1] - running... <br>21:41:05.147 c.TestTimer [pool-1-thread-1] - running... <br></code></pre></td></tr></table></figure><blockquote><p><strong>评价</strong> 整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线 程也不会被释放。用来执行延迟或反复执行的任务</p></blockquote><h4 id="正确处理执行任务异常">10）正确处理执行任务异常</h4><p>不论是哪个线程池，在线程执行的任务发生异常后既不会抛出，也不会捕获，这时就需要我们做一定的处理。</p><p><strong>方法1：主动捉异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>pool.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;error:&quot;</span>, e);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">21:59:04.558 c.TestTimer [pool-1-thread-1] - task1 <br>21:59:04.562 c.TestTimer [pool-1-thread-1] - error: <br>java.lang.ArithmeticException: / by zero <br> at cn.itcast.n8.TestTimer.lambda$main<span class="hljs-variable">$0</span>(TestTimer.java:28) <br> at java.util.concurrent.Executors<span class="hljs-variable">$RunnableAdapter</span>.call(Executors.java:511) <br> at java.util.concurrent.FutureTask.run(FutureTask.java:266) <br> at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) <br> at java.util.concurrent.ThreadPoolExecutor<span class="hljs-variable">$Worker</span>.run(ThreadPoolExecutor.java:624) <br> at java.lang.Thread.run(Thread.java:748) <br></code></pre></td></tr></table></figure><p><strong>方法2：使用 Future</strong></p><p>说明：</p><ul><li>lambda表达式内要有返回值，编译器才能将其识别为Callable，否则将识别为Runnable，也就不能用FutureTask</li><li>方法中如果出异常，<code>futuretask.get</code>会返回这个异常，否者正常返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;);<br>log.debug(<span class="hljs-string">&quot;result:&#123;&#125;&quot;</span>, f.get());<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">21:54:58.208 c.TestTimer [pool-1-thread-1] - task1 <br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.util.concurrent.ExecutionException: <br>java.lang.ArithmeticException: / by zero <br> at java.util.concurrent.FutureTask.report(FutureTask.java:122) <br> at java.util.concurrent.FutureTask.get(FutureTask.java:192) <br> at cn.itcast.n8.TestTimer.main(TestTimer.java:31) <br>Caused by: java.lang.ArithmeticException: / by zero <br> at cn.itcast.n8.TestTimer.lambda$main<span class="hljs-variable">$0</span>(TestTimer.java:28) <br> at java.util.concurrent.FutureTask.run(FutureTask.java:266) <br> at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) <br> at java.util.concurrent.ThreadPoolExecutor<span class="hljs-variable">$Worker</span>.run(ThreadPoolExecutor.java:624) <br> at java.lang.Thread.run(Thread.java:748) <br></code></pre></td></tr></table></figure><h4 id="应用之定时任务">11）<font color="green">* 应用之定时任务</font></h4><p>如何让每周四 18:00:00 定时执行任务？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得当前时间</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><span class="hljs-comment">// 获取本周四 18:00:00.000</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">thursday</span> <span class="hljs-operator">=</span> <br>    now.with(DayOfWeek.THURSDAY).withHour(<span class="hljs-number">18</span>).withMinute(<span class="hljs-number">0</span>).withSecond(<span class="hljs-number">0</span>).withNano(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000</span><br><span class="hljs-keyword">if</span>(now.compareTo(thursday) &gt;= <span class="hljs-number">0</span>) &#123;<br>    thursday = thursday.plusWeeks(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 计算时间差，即延时执行时间</span><br><span class="hljs-type">long</span> <span class="hljs-variable">initialDelay</span> <span class="hljs-operator">=</span> Duration.between(now, thursday).toMillis();<br><span class="hljs-comment">// 计算间隔时间，即 1 周的毫秒值</span><br><span class="hljs-type">long</span> <span class="hljs-variable">oneWeek</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span> * <span class="hljs-number">24</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>;<br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br>System.out.println(<span class="hljs-string">&quot;开始时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>executor.scheduleAtFixedRate(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>&#125;, initialDelay, oneWeek, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure><h4 id="tomcat-线程池">12）Tomcat 线程池</h4><p>Tomcat 在哪里用到了线程池呢</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191050688.png"></p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ul><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p><ul><li>如果总线程数达到 maximumPoolSize<ul><li>这时不会立刻抛 RejectedExecutionException 异常</li><li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li></ul></li></ul><p>源码 tomcat-7.0.42</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>    submittedCount.incrementAndGet();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">super</span>.getQueue() <span class="hljs-keyword">instanceof</span> TaskQueue) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">TaskQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> (TaskQueue)<span class="hljs-built_in">super</span>.getQueue();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!queue.force(command, timeout, unit)) &#123;<br>                    submittedCount.decrementAndGet();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Queue capacity is full.&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;<br>                submittedCount.decrementAndGet();<br>                Thread.interrupted();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(x);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            submittedCount.decrementAndGet();<br>            <span class="hljs-keyword">throw</span> rx;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TaskQueue.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">force</span><span class="hljs-params">(Runnable o, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> ( parent.isShutdown() ) <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<br>        <span class="hljs-string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span><br>    );<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.offer(o,timeout,unit); <span class="hljs-comment">//forces the item onto the queue, to be used if the task </span><br>    is rejected<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>Connector 配置</p><table><thead><tr class="header"><th style="text-align:center">配置项</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><code>acceptorThreadCount</code></td><td style="text-align:center">1</td><td style="text-align:center">acceptor 线程数量</td></tr><tr class="even"><td style="text-align:center"><code>pollerThreadCount</code></td><td style="text-align:center">1</td><td style="text-align:center">poller 线程数量</td></tr><tr class="odd"><td style="text-align:center"><code>minSpareThreads</code></td><td style="text-align:center">10</td><td style="text-align:center">核心线程数，即 corePoolSize</td></tr><tr class="even"><td style="text-align:center"><code>maxThreads</code></td><td style="text-align:center">200</td><td style="text-align:center">最大线程数，即 maximumPoolSize</td></tr><tr class="odd"><td style="text-align:center"><code>executor</code></td><td style="text-align:center">-</td><td style="text-align:center">Executor 名称，用来引用下面的 Executor</td></tr></tbody></table><p>Executor 线程配置</p><table><thead><tr class="header"><th style="text-align:center">配置项</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><code>threadPriority</code></td><td style="text-align:center">5</td><td style="text-align:center">线程优先级</td></tr><tr class="even"><td style="text-align:center"><code>deamon</code></td><td style="text-align:center">true</td><td style="text-align:center">是否守护线程</td></tr><tr class="odd"><td style="text-align:center"><code>minSpareThreads</code></td><td style="text-align:center">25</td><td style="text-align:center">核心线程数，即corePoolSize</td></tr><tr class="even"><td style="text-align:center"><code>maxThreads</code></td><td style="text-align:center">200</td><td style="text-align:center">最大线程数，即 maximumPoolSize</td></tr><tr class="odd"><td style="text-align:center"><code>maxIdleTime</code></td><td style="text-align:center">60000</td><td style="text-align:center">线程生存时间，单位是毫秒，默认值即 1 分钟</td></tr><tr class="even"><td style="text-align:center"><code>maxQueueSize</code></td><td style="text-align:center">Integer.MAX_VALUE</td><td style="text-align:center">队列长度</td></tr><tr class="odd"><td style="text-align:center"><code>prestartminSpareThreads</code></td><td style="text-align:center">false</td><td style="text-align:center">核心线程是否在服务器启动时启动</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191114946.png"></p><h3 id="forkjoin-线程池">8.1.3 Fork/Join 线程池</h3><p><strong>概念</strong></p><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，<strong>适用于能够进行任务拆分的 cpu 密集型 运算</strong></p><p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p><p>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率</p><p>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p><h4 id="应用之求和"><font color="green">应用之求和</font></h4><p><strong>提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值）</strong></p><p>例如下面定义了一个<strong>对 1~n 之间的整数求和的任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTask1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br><br>        <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>        <span class="hljs-type">AddTask1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask1</span>(n - <span class="hljs-number">1</span>);<br>        t1.fork();<span class="hljs-comment">//让一个线程去执行此任务</span><br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br><br>        <span class="hljs-comment">// 合并(join)结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n + t1.join();<span class="hljs-comment">//join 获取任务结果</span><br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后提交给 ForkJoinPool 来执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br>    System.out.println(pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask1</span>(<span class="hljs-number">5</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">[ForkJoinPool-1-worker-0] - fork() 2 + &#123;1&#125; <br>[ForkJoinPool-1-worker-1] - fork() 5 + &#123;4&#125; <br>[ForkJoinPool-1-worker-0] - <span class="hljs-built_in">join</span>() 1 <br>[ForkJoinPool-1-worker-0] - <span class="hljs-built_in">join</span>() 2 + &#123;1&#125; = 3 <br>[ForkJoinPool-1-worker-2] - fork() 4 + &#123;3&#125; <br>[ForkJoinPool-1-worker-3] - fork() 3 + &#123;2&#125; <br>[ForkJoinPool-1-worker-3] - <span class="hljs-built_in">join</span>() 3 + &#123;2&#125; = 6 <br>[ForkJoinPool-1-worker-2] - <span class="hljs-built_in">join</span>() 4 + &#123;3&#125; = 10 <br>[ForkJoinPool-1-worker-1] - <span class="hljs-built_in">join</span>() 5 + &#123;4&#125; = 15 <br>15 <br></code></pre></td></tr></table></figure><p>用图来表示</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191130968.png"></p><p>改进（5要等待其他任务执行完才能继续执行，<strong>能不能让任务间的依赖减少，使他们并行执行</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTask3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-type">int</span> begin;<br>    <span class="hljs-type">int</span> end;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask3</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-built_in">this</span>.begin = begin;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + begin + <span class="hljs-string">&quot;,&quot;</span> + end + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 5, 5</span><br>        <span class="hljs-keyword">if</span> (begin == end) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, begin);<br>            <span class="hljs-keyword">return</span> begin;<br>        &#125;<br>        <span class="hljs-comment">// 4, 5</span><br>        <span class="hljs-keyword">if</span> (end - begin == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);<br>            <span class="hljs-keyword">return</span> end + begin;<br>        &#125;<br><br>        <span class="hljs-comment">// 1 5</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end + begin) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 3</span><br>        <span class="hljs-type">AddTask3</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask3</span>(begin, mid); <span class="hljs-comment">// 1,3</span><br>        t1.fork();<br>        <span class="hljs-type">AddTask3</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask3</span>(mid + <span class="hljs-number">1</span>, end); <span class="hljs-comment">// 4,5</span><br>        t2.fork();<br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> t1.join() + t2.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后提交给 ForkJoinPool 来执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br>    System.out.println(pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">[ForkJoinPool-1-worker-0] - <span class="hljs-built_in">join</span>() 1 + 2 = 3 <br>[ForkJoinPool-1-worker-3] - <span class="hljs-built_in">join</span>() 4 + 5 = 9 <br>[ForkJoinPool-1-worker-0] - <span class="hljs-built_in">join</span>() 3 <br>[ForkJoinPool-1-worker-1] - <span class="hljs-function"><span class="hljs-title">fork</span></span>() &#123;1,3&#125; + &#123;4,5&#125; = ? <br>[ForkJoinPool-1-worker-2] - <span class="hljs-function"><span class="hljs-title">fork</span></span>() &#123;1,2&#125; + &#123;3,3&#125; = ? <br>[ForkJoinPool-1-worker-2] - <span class="hljs-function"><span class="hljs-title">join</span></span>() &#123;1,2&#125; + &#123;3,3&#125; = 6 <br>[ForkJoinPool-1-worker-1] - <span class="hljs-function"><span class="hljs-title">join</span></span>() &#123;1,3&#125; + &#123;4,5&#125; = 15 <br>15 <br></code></pre></td></tr></table></figure><p>用图来表示</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191229984.png"></p><h2 id="j.u.c并发编程">8.2 J.U.C并发编程</h2><h3 id="aqs-阻塞式锁原理">8.2.1 <font color="blue">*AQS 阻塞式锁原理</font></h3><p>概述</p><p>全称是 <strong>AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</strong></p><p>特点：</p><ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><p>获取锁的姿势</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果获取锁失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123;<br>    <span class="hljs-comment">// 入队, 可以选择阻塞当前线程 park unpark</span><br>&#125;<br></code></pre></td></tr></table></figure><p>释放锁的姿势</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果释放锁成功</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>    <span class="hljs-comment">// 让阻塞线程恢复运行</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现不可重入锁">1）实现不可重入锁</h4><p><strong>自定义同步器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-comment">//独占锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">if</span> (acquires == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                 <span class="hljs-comment">//加上了锁 ，并设置owner为当前线程</span><br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//获取锁失败</span><br>    &#125;<br>    <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">if</span>(acquires == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(getState() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            &#125;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>    &#125;<br>    <span class="hljs-comment">//是否占有独占锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义锁</strong></p><p>有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">MySync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试加锁，不成功，进入等待队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试加锁，不成功，进入等待队列，可打断</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试加锁一次，不成功返回，不进入队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试加锁，不成功，进入等待队列，有时限</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 生成条件变量</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLock</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);<br>        lock.unlock();<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);<br>        lock.unlock();<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">22:29:28.727 c.TestAqs [t1] - locking... <br>22:29:29.732 c.TestAqs [t1] - unlocking... <br>22:29:29.732 c.TestAqs [t2] - locking... <br>22:29:29.732 c.TestAqs [t2] - unlocking... <br></code></pre></td></tr></table></figure><p>不可重入测试</p><p>如果改为下面代码，会发现自己也会被挡住（只会打印一次 locking）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">lock.lock();<br>log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="心得">2）心得</h4><p><strong>起源</strong></p><p>早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不 够优雅，于是在 JSR166（java 规范提案）中创建了 AQS，提供了这种通用的同步器机制。</p><p><strong>目标</strong></p><p>AQS 要实现的功能目标</p><ul><li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire</li><li>获取锁超时机制</li><li>通过打断取消机制</li><li>独占机制及共享机制</li><li>条件不满足时的等待机制</li></ul><p>要实现的性能目标</p><blockquote><p>Instead, the primary performance goal here is scalability: to predictably maintain efficiency even, or especially, when synchronizers are contended.</p></blockquote><p><strong>设计</strong></p><p>AQS 的基本思想其实很简单</p><p>获取锁的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(state 状态不允许获取) &#123;<br>    <span class="hljs-keyword">if</span>(队列中还没有此线程) &#123;<br>        入队并阻塞<br>    &#125;<br>&#125;<br>当前线程出队<br></code></pre></td></tr></table></figure><p>释放锁的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(state 状态允许了) &#123;<br>    恢复阻塞的线程(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>要点</p><ul><li>原子维护 state 状态</li><li>阻塞及恢复线程</li><li>维护队列</li></ul><ol type="1"><li>state 设计<ul><li>state 使用 volatile 配合 cas 保证其修改时的原子性</li><li>state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想</li></ul></li></ol><ol start="2" type="1"><li>阻塞恢复设计<ul><li>早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume 那么 suspend 将感知不到</li><li>解决方法是使用 park &amp; unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark 再 park 也没 问题</li><li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</li><li>park 线程还可以通过 interrupt 打断</li></ul></li><li>队列设计<ul><li>使用了 FIFO 先入先出队列，并不支持优先级队列</li><li>设计时借鉴了 CLH 队列，它是一种单向无锁队列</li></ul></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191322017.png"></p><p>队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态 入队伪代码，只需要考虑 tail 赋值的原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// 原来的 tail</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 用 cas 在原来 tail 的基础上改为 node</span><br>&#125; <span class="hljs-keyword">while</span>(tail.compareAndSet(prev, node))<br></code></pre></td></tr></table></figure><p>出队伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// prev 是上一个节点</span><br><span class="hljs-keyword">while</span>((Node prev=node.prev).state != 唤醒状态) &#123;<br>&#125;<br><span class="hljs-comment">// 设置头节点</span><br>head = node;<br></code></pre></td></tr></table></figure><p>CLH 好处：</p><ul><li>无锁，使用自旋</li><li>快速，无阻塞</li></ul><p>AQS 在一些方面改进了 CLH</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">// 队列中还没有元素 tail 为 null</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 将 head 从 null -&gt; dummy</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 将 node 的 prev 设置为原来的 tail</span><br>            node.prev = t;<br>            <span class="hljs-comment">// 将 tail 从原来的 tail 设置为 node</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                <span class="hljs-comment">// 原来 tail 的 next 设置为 node</span><br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要用到 AQS 的并发工具类</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191322335.png"></p><h3 id="reentrantlock-原理">8.2.2 ReentrantLock 原理</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191322419.png"></p><h4 id="非公平锁实现原理">1）非公平锁实现原理</h4><p><strong>加锁解锁流程</strong></p><p>先从构造器开始看，默认为非公平锁实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>NonfairSync 继承自 AQS 没有竞争时</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191323610.png"></p><p>第一个竞争出现时</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191323456.png"></p><p>Thread-1 执行了</p><ol type="1"><li>CAS 尝试将 state 由 0 改为 1，结果失败</li><li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li><li>接下来进入 addWaiter 逻辑，构造 Node 队列<ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ul></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191353615.png"></p><p>当前线程进入 acquireQueued 逻辑</p><ol type="1"><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191353139.png"></li><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191353097.png"></p><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191353728.png"></p><p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p><ul><li>设置 exclusiveOwnerThread 为 null</li><li>state = 0</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191354841.png"></p><p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程</p><p>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1</p><p>回到 Thread-1 的 acquireQueued 流程</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191354773.png"></p><p>如果加锁成功（没有竞争），会设置</p><ul><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ul><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191354494.png"></p><p>如果不巧又被 Thread-4 占了先</p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ul><h5 id="加锁与解锁源码">加锁与解锁源码</h5><p><strong>加锁源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7316153563782823691L</span>;<br><br>    <span class="hljs-comment">// 加锁实现</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 如果尝试失败，进入 ㈠</span><br>            acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-comment">// ㈡ tryAcquire </span><br>        <span class="hljs-keyword">if</span> (<br>            !tryAcquire(arg) &amp;&amp;<br>            <span class="hljs-comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span><br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>        ) &#123;<br>            selfInterrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈡ 进入 ㈢</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br><br>    <span class="hljs-comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-comment">// 如果还没有获得锁</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-comment">// state++</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获取失败, 回到调用处</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">//将当前node加入等待队列末尾等待，并返回当前node</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>        <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>        <span class="hljs-comment">//非公平同步器中有head和tail两个引用分别指向了等待队列的第一个和最后一个节点</span><br>        <span class="hljs-comment">//pred指的是node的前驱，从队尾插入，所以pred为tail</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">// 如果 tail 不为 null, 说明已经有了等待队列了，cas 尝试将 Node 对象加入 AQS 队列尾部</span><br>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//将node的前驱节点设置为pred</span><br>            node.prev = pred;<br>            <span class="hljs-comment">//尝试将队列的tial从当前的pred修改为node</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>                <span class="hljs-comment">// 双向链表</span><br>                pred.next = node;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果pred为null，说明等待队列还未创建，调用enq方法创建队列</span><br>        <span class="hljs-comment">// 尝试将 Node 加入 AQS, 进入 ㈥</span><br>        enq(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">//该方法就是创建等待队列，并将node插入队列的尾部。</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span><br>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>())) &#123;<br>                    <span class="hljs-comment">//将head赋值给tail，head和tail同时指向哨兵节点</span><br>                    tail = head;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span><br>                <span class="hljs-comment">//设置node的前驱节点为队列的最后一个节点</span><br>                node.prev = t;<br>                <span class="hljs-comment">//尝试将队列的尾部从当前的tail设置为node</span><br>                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                    <span class="hljs-comment">//将node设为上一个tail的后继节点</span><br>                    t.next = node;<br>                    <span class="hljs-keyword">return</span> t;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">//在队列中循环等待，只有当排队排到第一名并且获得了锁才能出队并从方法中退出。</span><br>    <span class="hljs-comment">//返回打断状态</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-comment">//找到当前node的前驱节点</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    <span class="hljs-comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span><br>                    setHead(node);<br>                    <span class="hljs-comment">// 上一个节点 help GC</span><br>                    p.next = <span class="hljs-literal">null</span>;<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// 返回中断标记 false</span><br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<br>                    <span class="hljs-comment">// 判断是否应当 park, 进入 ㈦</span><br>                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    <span class="hljs-comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span><br>                    parkAndCheckInterrupt()<br>                ) &#123;<br>                    interrupted = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">//判断acquire失败以后是否应该阻塞等待。从规则上来讲：</span><br>    <span class="hljs-comment">//1.如果前驱节点都阻塞了，那么当前节点也应该阻塞</span><br>    <span class="hljs-comment">//2.如果前驱节点取消，那么应该将前驱节点前移，直到其状态不为取消为止。</span><br>    <span class="hljs-comment">//3.如果前两种情况都不是，尝试将前驱节点状态设为SIGNAL，返回false（不用阻塞，等到下次在阻塞）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>        <span class="hljs-comment">// 获取上一个节点的状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>            <span class="hljs-comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// &gt; 0 表示取消状态</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                node.prev = pred = pred.prev;<br>            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>            pred.next = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这次还没有阻塞</span><br>            <span class="hljs-comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span><br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈧ 阻塞当前线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>是否需要 unpark 是由当前节点的前驱节点的 waitStatus == Node.SIGNAL 来决定，而不是本节点的 waitStatus 决定</p></blockquote><p>总结：</p><ul><li>调用<code>lock</code>，尝试将state从0修改为1<ul><li>成功：将owner设为当前线程</li><li>失败：调用<code>acquire</code>-&gt;<code>tryAcquire</code>-&gt;<code>nonfairTryAcquire</code>，判断state=0则获得锁，或者state不为0但当前线程持有锁则重入锁，以上两种情况<code>tryAcquire</code>返回true，剩余情况返回false。<ul><li>true：获得锁</li><li>false：调用<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>,其中<code>addwiter</code>将关联线程的节点插入AQS队列尾部，进入<code>acquireQueued</code>中的for循环:<ul><li>如果当前节点是头节点，并尝试获得锁成功，将当前节点设为头节点，清除此节点信息，返回打断标记。</li><li>调用<code>shoudParkAfterFailure</code>,第一次调用返回false，并将前驱节点改为-1，第二次循环如果再进入此方法，会进入阻塞并检查打断的方法。</li></ul></li></ul></li></ul></li></ul><p><strong>解锁源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// 解锁实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-comment">// 尝试释放锁, 进入 ㈠</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-comment">// 队列头节点 unpark</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <br>            <span class="hljs-keyword">if</span> (<br>                <span class="hljs-comment">// 队列不为 null</span><br>                h != <span class="hljs-literal">null</span> &amp;&amp;<br>                <span class="hljs-comment">// waitStatus == Node.SIGNAL 才需要 unpark</span><br>                h.waitStatus != <span class="hljs-number">0</span><br>            ) &#123;<br>                <span class="hljs-comment">// unpark AQS 中等待的线程, 进入 ㈡</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>        <span class="hljs-comment">// state--</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            free = <span class="hljs-literal">true</span>;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>        &#125;<br>        setState(c);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0</span><br>        <span class="hljs-comment">// 不成功也可以</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) &#123;<br>            compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>            s = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>                <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                    s = t;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>            LockSupport.unpark(s.thread);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><code>unlock</code>-&gt;<code>syn.release</code>(1)-&gt;<code>tryRelease</code>(1),如果当前线程并不持有锁，抛异常。state减去1,如果之后state为0，解锁成功，返回true；如果仍大于0，表示解锁不完全，当前线程依旧持有锁，返回false。</li><li>返回true：检查AQS队列第一个节点状态图是否为<code>SIGNAL</code>(意味着有责任唤醒其后记节点)，如果有，调用<code>unparkSuccessor</code>。<ul><li>再<code>unparkSuccessor</code>中，不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点，如果有，将其唤醒。</li></ul></li><li>返回false：</li></ul><h3 id="可重入锁原理">2）可重入锁原理</h3><p>当持有锁的线程再次尝试获取锁时，会将state的值加1，state表示锁的重入量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-comment">// state++</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>        <span class="hljs-comment">// state-- </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            free = <span class="hljs-literal">true</span>;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>        &#125;<br>        setState(c);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可打断锁原理">3）可打断锁原理</h3><h4 id="不可打断模式"><strong>不可打断模式</strong></h4><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，并将打断信号存储在一个interrupt变量中。一直要等到获得锁后方能得知自己被打断了,并且调用<code>selfInterrupt</code>方法打断自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果打断标记已经是 true, 则 park 会失效</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">// interrupted 会清除打断标记</span><br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>;<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// 还是需要获得锁后, 才能返回打断状态</span><br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<br>                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt()<br>                ) &#123;<br>                    <span class="hljs-comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span><br>                    interrupted = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<br>            !tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>        ) &#123;<br>            <span class="hljs-comment">// 如果打断状态为 true</span><br>            selfInterrupt();<br>        &#125;<br>    &#125;<br>	<br>    <span class="hljs-comment">//响应打断标记，打断自己</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selfInterrupt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 重新产生一次中断</span><br>        Thread.currentThread().interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可打断模式"><strong>可打断模式</strong></h4><p>此模式下即使线程在等待队列中等待，一旦被打断，就会立刻抛出打断异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <span class="hljs-comment">// 如果没有获得到锁, 进入 ㈠</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>            doAcquireInterruptibly(arg);<br>    &#125;<br><br>    <span class="hljs-comment">// ㈠ 可打断的获取锁流程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt()) &#123;<br>                    <span class="hljs-comment">// 在 park 过程中如果被 interrupt 会进入此</span><br>                    <span class="hljs-comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="公平锁实现原理">4）公平锁实现原理</h3><p>简而言之，<strong>公平与非公平的区别在于，公平锁中的tryAcquire方法被重写了，新来的线程即便得知了锁的state为0，也要先判断等待队列中是否还有线程等待，只有当队列没有线程等待式，才获得锁</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<br>            !tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>        ) &#123;<br>            selfInterrupt();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">//存疑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        Node s;<br>        <span class="hljs-comment">// h != t 时表示队列中有 Node</span><br>        <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>            (<br>            <span class="hljs-comment">// (s = h.next) == null 表示队列中还有没有老二</span><br>            (s = h.next) == <span class="hljs-literal">null</span> ||<br>            <span class="hljs-comment">// 或者队列中老二线程不是此线程</span><br>            s.thread != Thread.currentThread()<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件变量实现原理">5）条件变量实现原理</h3><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p><h4 id="await-流程">await 流程</h4><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程</p><p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191409420.png"></p><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191412631.png"></p><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191412689.png"></p><p>park 阻塞 Thread-0</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191414419.png"></p><p>总结：</p><ul><li>创建一个节点，关联当前线程，并插入到当前Condition队列的尾部</li><li>调用<code>fullRelease</code>，完全释放同步器中的锁，并记录当前线程的锁重入数</li><li>唤醒(park)AQS队列中的第一个线程</li><li>调用park方法，阻塞当前线程。</li></ul><h4 id="signal-流程">signal 流程</h4><p>假设 Thread-1 要来唤醒 Thread-0</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191414379.png"></p><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191414919.png"></p><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191415724.png"></p><p>Thread-1 释放锁，进入 unlock 流程，略</p><p>总结：</p><ul><li>当前持有锁的线程唤醒等待队列中的线程，调用doSignal或doSignalAll方法，将等待队列中的第一个（或全部）节点插入到AQS队列中的尾部。</li><li>将插入的节点的状态从Condition设置为0，将插入节点的前一个节点的状态设置为-1（意味着要承担唤醒后一个节点的责任）</li><li>当前线程释放锁，parkAQS队列中的第一个节点线程。</li></ul><p><strong>源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1173984872572414699L</span>;<br><br>    <span class="hljs-comment">// 第一个等待节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br><br>    <span class="hljs-comment">// 最后一个等待节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConditionObject</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// ㈠ 添加一个 Node 至等待队列</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>        <span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>            unlinkCancelledWaiters();<br>            t = lastWaiter;<br>        &#125;<br>        <span class="hljs-comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>            firstWaiter = node;<br>        <span class="hljs-keyword">else</span><br>            t.nextWaiter = node;<br>        lastWaiter = node;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <span class="hljs-comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 已经是尾节点了</span><br>            <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>) &#123;<br>                lastWaiter = <span class="hljs-literal">null</span>;<br>            &#125;<br>            first.nextWaiter = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">while</span> (<br>            <span class="hljs-comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span><br>            !transferForSignal(first) &amp;&amp;<br>            <span class="hljs-comment">// 队列还有节点</span><br>            (first = firstWaiter) != <span class="hljs-literal">null</span><br>        );<br>    &#125;<br><br>    <span class="hljs-comment">// 外部类方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">// 如果状态已经不是 Node.CONDITION, 说明被取消了</span><br>        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 加入 AQS 队列尾部</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// 上一个节点被取消</span><br>            ws &gt; <span class="hljs-number">0</span> ||<br>            <span class="hljs-comment">// 上一个节点不能设置状态为 Node.SIGNAL</span><br>            !compareAndSetWaitStatus(p, ws, Node.SIGNAL) <br>        ) &#123;<br>            <span class="hljs-comment">// unpark 取消阻塞, 让线程重新同步状态</span><br>            LockSupport.unpark(node.thread);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignalAll</span><span class="hljs-params">(Node first)</span> &#123;<br>        lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br>            first.nextWaiter = <span class="hljs-literal">null</span>;<br>            transferForSignal(first);<br>            first = next;<br>        &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// ㈡</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>            doSignal(first);<br>    &#125;<br>    <span class="hljs-comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>            doSignalAll(first);<br>    &#125;<br>    <span class="hljs-comment">// 不可打断等待 - 直到被唤醒</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>        <span class="hljs-comment">// 释放节点持有的锁, 见 ㈣</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>            <span class="hljs-comment">// park 阻塞</span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">// 如果被打断, 仅设置打断状态</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span><br>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignalAll</span><span class="hljs-params">(Node first)</span> &#123;<br>        lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br>            first.nextWaiter = <span class="hljs-literal">null</span>;<br>            transferForSignal(first);<br>            first = next;<br>        &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// ㈡</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>            doSignal(first);<br>    &#125;<br>    <span class="hljs-comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>            doSignalAll(first);<br>    &#125;<br>    <span class="hljs-comment">// 不可打断等待 - 直到被唤醒</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>        <span class="hljs-comment">// 释放节点持有的锁, 见 ㈣</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>            <span class="hljs-comment">// park 阻塞</span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">// 如果被打断, 仅设置打断状态</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span><br>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)<br>            selfInterrupt();<br>    &#125;<br><br>    <span class="hljs-comment">// 外部类方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> savedState;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                node.waitStatus = Node.CANCELLED;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 打断模式 - 在退出等待时重新设置打断状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REINTERRUPT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 打断模式 - 在退出等待时抛出异常</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THROW_IE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 判断打断模式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-keyword">return</span> Thread.interrupted() ?<br>            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<br>        <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// ㈤ 应用打断模式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-type">int</span> interruptMode)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-comment">// 等待 - 直到被唤醒或打断</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>        <span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>        <span class="hljs-comment">// 释放节点持有的锁</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>            <span class="hljs-comment">// park 阻塞</span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">// 如果被打断, 退出等待队列</span><br>            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span><br>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>            interruptMode = REINTERRUPT;<br>        <span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br>        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <br>            unlinkCancelledWaiters();<br>        <span class="hljs-comment">// 应用打断模式, 见 ㈤</span><br>        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>            reportInterruptAfterWait(interruptMode);<br>    &#125;<br>    <span class="hljs-comment">//向Condition中的等待队列中新增节点，并将此节点返回</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>        <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>            unlinkCancelledWaiters();<br>            t = lastWaiter;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>            firstWaiter = node;<br>        <span class="hljs-keyword">else</span><br>            t.nextWaiter = node;<br>        lastWaiter = node;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>    <span class="hljs-comment">//判断当前节点是否在同步器中的队列中等待锁</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>) <span class="hljs-comment">// If has successor, it must be on queue</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * node.prev can be non-null, but not yet on queue because</span><br><span class="hljs-comment">         * the CAS to place it on queue can fail. So we have to</span><br><span class="hljs-comment">         * traverse from tail to make sure it actually made it.  It</span><br><span class="hljs-comment">         * will always be near the tail in calls to this method, and</span><br><span class="hljs-comment">         * unless the CAS failed (which is unlikely), it will be</span><br><span class="hljs-comment">         * there, so we hardly ever traverse much.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> findNodeFromTail(node);<br>    &#125;<br>    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>        <span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>        <span class="hljs-comment">// 释放节点持有的锁</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>        <span class="hljs-comment">// 获得最后期限</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>            <span class="hljs-comment">// 已超时, 退出等待队列</span><br>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;<br>                transferAfterCancelledWait(node);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span><br>            <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)<br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>            <span class="hljs-comment">// 如果被打断, 退出等待队列</span><br>            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            nanosTimeout = deadline - System.nanoTime();<br>        &#125;<br>        <span class="hljs-comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span><br>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>            interruptMode = REINTERRUPT;<br>        <span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br>        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)<br>            unlinkCancelledWaiters();<br>        <span class="hljs-comment">// 应用打断模式, 见 ㈤</span><br>        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>            reportInterruptAfterWait(interruptMode);<br>        <span class="hljs-keyword">return</span> deadline - System.nanoTime();<br>    &#125;<br>    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// 工具方法 省略 ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="读写锁">8.3 读写锁</h2><h3 id="reentrantreadwritelock">8.3.1 ReentrantReadWriteLock</h3><p>当读操作远远高于写操作时，这时候使用<code>读写锁</code>让<code>读-读</code>可以并发，提高性能。 类似于数据库中的<code>select ... from ... lock in share mode</code></p><p>提供一个<code>数据容器类</code>内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainer</span> &#123;<br>    <span class="hljs-keyword">private</span> Object data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rw.readLock();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rw.writeLock();<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获取读锁...&quot;</span>);<br>        r.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;读取&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放读锁...&quot;</span>);<br>            r.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获取写锁...&quot;</span>);<br>        w.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;写入&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放写锁...&quot;</span>);<br>            w.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试<code>读锁-读锁</code>可以并发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DataContainer</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainer</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    dataContainer.read();<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    dataContainer.read();<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>输出结果，从这里可以看到 Thread-0 锁定期间，Thread-1 的读操作不受影响</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">14:05:14.341 c.DataContainer [t2] - 获取读锁... <br>14:05:14.341 c.DataContainer [t1] - 获取读锁... <br>14:05:14.345 c.DataContainer [t1] - 读取<br>14:05:14.345 c.DataContainer [t2] - 读取<br>14:05:15.365 c.DataContainer [t2] - 释放读锁... <br>14:05:15.386 c.DataContainer [t1] - 释放读锁... <br></code></pre></td></tr></table></figure><p>测试<code>读锁-写锁</code>相互阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DataContainer</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainer</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    dataContainer.read();<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>Thread.sleep(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    dataContainer.write();<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">21.838</span> c.DataContainer [t1] - 获取读锁... <br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">21.838</span> c.DataContainer [t2] - 获取写锁... <br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">21.841</span> c.DataContainer [t2] - 写入<br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">22.843</span> c.DataContainer [t2] - 释放写锁... <br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">22.843</span> c.DataContainer [t1] - 读取<br><span class="hljs-number">14</span>:<span class="hljs-number">04</span>:<span class="hljs-number">23.843</span> c.DataContainer [t1] - 释放读锁... <br></code></pre></td></tr></table></figure><p><code>写锁-写锁</code>也是相互阻塞的，这里就不测试了</p><p><strong>注意事项</strong></p><ul><li>读锁不支持条件变量</li><li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">r.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    w.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">finally</span>&#123;<br>        w.unlock();<br>    &#125;<br>&#125; <span class="hljs-keyword">finally</span>&#123;<br>    r.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>重入时降级支持：即持有写锁的情况下去获取读锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedData</span> &#123;<br>    Object data;<br>    <span class="hljs-comment">// 是否有效，如果失效，需要重新计算 data</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> cacheValid;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCachedData</span><span class="hljs-params">()</span> &#123;<br>        rwl.readLock().lock();<br>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            <span class="hljs-comment">// 获取写锁前必须释放读锁</span><br>            rwl.readLock().unlock();<br>            rwl.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span><br>                <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>                    data = ...<br>                        cacheValid = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span><br>                rwl.readLock().lock();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                rwl.writeLock().unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 自己用完数据, 释放读锁 </span><br>        <span class="hljs-keyword">try</span> &#123;<br>            use(data);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rwl.readLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用之缓存">8.3.2 <font color="green">* 应用之缓存</font></h3><h5 id="缓存更新策略">缓存更新策略</h5><p>更新时，是先清缓存还是先更新数据库 【<strong>应该先更新库再清缓存</strong>】</p><p><strong>先清缓存</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191439843.png"></p><p><strong>先更新数据库</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191439282.png"></p><p>补充一种情况，假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191439878.png"></p><p>这种情况的出现几率非常小，见 facebook 论文</p><h5 id="读写锁实现一致性缓存">读写锁实现一致性缓存</h5><p>使用读写锁实现一个简单的按需加载缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericCachedDao</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// HashMap 作为缓存非线程安全, 需要保护</span><br>    HashMap&lt;SqlPair, T&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>(); <br>    <span class="hljs-type">GenericDao</span> <span class="hljs-variable">genericDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericDao</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String sql, Object... params)</span> &#123;<br>        <span class="hljs-type">SqlPair</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlPair</span>(sql, params);<br>        <span class="hljs-comment">// 加写锁, 防止其它线程对缓存读取和更改</span><br>        lock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> genericDao.update(sql, params);<br>            map.clear();<br>            <span class="hljs-keyword">return</span> rows;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.writeLock().unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">queryOne</span><span class="hljs-params">(Class&lt;T&gt; beanClass, String sql, Object... params)</span> &#123;<br>        <span class="hljs-type">SqlPair</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlPair</span>(sql, params);<br>        <span class="hljs-comment">// 加读锁, 防止其它线程对缓存更改</span><br>        lock.readLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br>            <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.readLock().unlock();<br>        &#125;<br>        <span class="hljs-comment">// 加写锁, 防止其它线程对缓存读取和更改</span><br>        lock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据</span><br>            <span class="hljs-comment">// 为防止重复查询数据库, 再次验证</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如果没有, 查询数据库</span><br>                value = genericDao.queryOne(beanClass, sql, params);<br>                map.put(key, value);<br>            &#125;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.writeLock().unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 作为 key 保证其是不可变的</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlPair</span> &#123;<br>        <span class="hljs-keyword">private</span> String sql;<br>        <span class="hljs-keyword">private</span> Object[] params;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SqlPair</span><span class="hljs-params">(String sql, Object[] params)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sql = sql;<br>            <span class="hljs-built_in">this</span>.params = params;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-type">SqlPair</span> <span class="hljs-variable">sqlPair</span> <span class="hljs-operator">=</span> (SqlPair) o;<br>            <span class="hljs-keyword">return</span> sql.equals(sqlPair.sql) &amp;&amp;<br>                Arrays.equals(params, sqlPair.params);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Objects.hash(sql);<br>            result = <span class="hljs-number">31</span> * result + Arrays.hashCode(params);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><ul><li><p>以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑</p><ul><li><p>适合读多写少，如果写操作比较频繁，以上实现性能低</p></li><li><p>没有考虑缓存容量</p></li><li><p>没有考虑缓存过期</p></li><li><p>只适合单机</p></li><li><p>并发性还是低，目前只会用一把锁</p></li><li><p>更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key）</p></li></ul></li><li><p>乐观锁实现：用 CAS 去更新</p></li></ul></blockquote><h3 id="读写锁原理">8.3.3 <font color="blue">* 读写锁原理</font></h3><h4 id="图解流程">图解流程</h4><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p><p><strong>t1 w.lock，t2 r.lock</strong></p><p>1） t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是<strong>写锁状态占了 state 的低 16 位，而读锁 使用的是 state 的高 16 位</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191505038.png"></p><p>2）t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写 锁占据，那么 tryAcquireShared 返回 -1 表示失败</p><blockquote><p>tryAcquireShared 返回值表示</p><ul><li>-1 表示失败</li><li>0 表示成功，但后继节点不会继续唤醒</li><li>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</li></ul></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191512540.png"></p><p>3）这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191514758.png"></p><p>4）t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</p><p>5）如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191515604.png"></p><p><strong>t3 r.lock，t4 w.lock</strong></p><p>这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子</p><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201123370.png" alt="image-20220314191927467"><figcaption aria-hidden="true">image-20220314191927467</figcaption></figure><p><strong>t1 w.unlock</strong></p><p>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191516700.png"></p><p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191516767.png"></p><p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201123371.png" alt="image-20220314192048242"><figcaption aria-hidden="true">image-20220314192048242</figcaption></figure><p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191516525.png"></p><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201123372.png" alt="image-20220314192123102"><figcaption aria-hidden="true">image-20220314192123102</figcaption></figure><p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191516893.png"></p><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p><p><strong>t2 r.unlock，t3 r.unlock</strong></p><p>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191516294.png"></p><p>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191516725.png"></p><p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他 竞争，tryAcquire(1) 成功，修改头结点，流程结束</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191516206.png"></p><h4 id="源码分析">源码分析</h4><p><strong>写锁上锁流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// ... 省略无关代码</span><br><br>    <span class="hljs-comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// 尝试获得写锁失败</span><br>            !tryAcquire(arg) &amp;&amp;<br>            <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span><br>            <span class="hljs-comment">// 进入 AQS 队列阻塞</span><br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>        ) &#123;<br>            selfInterrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-comment">// 获得低 16 位, 代表写锁的 state 计数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>		<span class="hljs-comment">//表示有写锁或者有读锁</span><br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<br>                <span class="hljs-comment">// c != 0 and w == 0 表示有读锁, 或者</span><br>                w == <span class="hljs-number">0</span> ||<br>                <span class="hljs-comment">// 如果 exclusiveOwnerThread 不是自己</span><br>                current != getExclusiveOwnerThread()<br>            ) &#123;<br>                <span class="hljs-comment">// 获得锁失败</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 写锁计数超过低 16 位, 报异常</span><br>            <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-comment">// 写锁重入, 获得锁成功</span><br>            setState(c + acquires);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// 判断写锁是否该阻塞, 或者</span><br>            <span class="hljs-comment">//非公平锁下，总是返回false</span><br>            writerShouldBlock() ||<br>            <span class="hljs-comment">// 尝试更改计数失败</span><br>            !compareAndSetState(c, c + acquires)<br>        ) &#123;<br>            <span class="hljs-comment">// 获得锁失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获得锁成功</span><br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><code>lock</code> -&gt; <code>syn.acquire</code> -&gt;<code>tryAquire</code><ul><li>如果有锁：<ul><li>如果是写锁或者锁持有者不为自己，返回false</li><li>如果时写锁且为自己持有，则重入</li></ul></li><li>如果无锁：<ul><li>判断无序阻塞并设置state成功后，将owner设为自己，返回true</li></ul></li></ul></li><li>成功，则获得了锁</li><li>失败：<ul><li>调用<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>进入阻塞队列，将节点状态设置为EXCLUSIVE，之后的逻辑与之前的aquireQueued类似。</li></ul></li></ul><p><strong>写锁释放流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// ... 省略无关代码</span><br><br>    <span class="hljs-comment">// WriteLock 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-comment">// 尝试释放写锁成功</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-comment">// unpark AQS 中等待的线程</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;<br>        <span class="hljs-comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (free) &#123;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>        &#125;<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><p><code>unlock</code>-&gt;<code>syn.release</code>-&gt;<code>tryRelease</code></p><ul><li>state状态减少<ul><li>如果减为零，表示解锁成功，返回true</li><li>没有减为0，当前线程依旧持有锁</li></ul></li></ul></li><li><p>成功：解锁成功</p><ul><li>如果ASQ队列不为空，则唤醒第一个节点。</li></ul></li><li><p>失败：解锁失败。</p></li></ul><p><strong>读锁上锁流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>    <span class="hljs-comment">// ReadLock 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquireShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span><br>        <span class="hljs-comment">//大于0的情况在读写锁这里无区别，后面信号量会做进一步处理。</span><br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>) &#123;<br>            doAcquireShared(arg);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-comment">// 如果是其它线程持有写锁, 获取读锁失败</span><br>        <span class="hljs-keyword">if</span> ( <br>            exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>            getExclusiveOwnerThread() != current<br>        ) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span><br>            !readerShouldBlock() &amp;&amp;<br>            <span class="hljs-comment">// 小于读锁计数, 并且</span><br>            r &lt; MAX_COUNT &amp;&amp;<br>            <span class="hljs-comment">// 尝试增加计数成功</span><br>            compareAndSetState(c, c + SHARED_UNIT)<br>        ) &#123;<br>            <span class="hljs-comment">// ... 省略不重要的代码</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>    &#125;<br><br>    <span class="hljs-comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span><br>    <span class="hljs-comment">// true 则该阻塞, false 则不阻塞</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullTryAcquireShared</span><span class="hljs-params">(Thread current)</span> &#123;<br>        <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != current)<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readerShouldBlock()) &#123;<br>                <span class="hljs-comment">// ... 省略不重要的代码</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (sharedCount(c) == MAX_COUNT)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>                <span class="hljs-comment">// ... 省略不重要的代码</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                    <span class="hljs-comment">// 再一次尝试获取读锁</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                    <span class="hljs-comment">// 成功</span><br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// ㈠</span><br>                        <span class="hljs-comment">// r 表示可用资源数, 在这里总是 1 允许传播</span><br>                        <span class="hljs-comment">//（唤醒 AQS 中下一个 Share 节点）</span><br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                        <span class="hljs-keyword">if</span> (interrupted)<br>                            selfInterrupt();<br>                        failed = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<br>                    <span class="hljs-comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span><br>                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    <span class="hljs-comment">// park 当前线程</span><br>                    parkAndCheckInterrupt()<br>                ) &#123;<br>                    interrupted = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// Record old head for check below</span><br>        <span class="hljs-comment">// 设置自己为 head</span><br>        setHead(node);<br><br>        <span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span><br>        <span class="hljs-comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span><br>        <span class="hljs-comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span><br>        <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>            (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点</span><br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared()) &#123;<br>                <span class="hljs-comment">// 进入 ㈡</span><br>                doReleaseShared();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br>        <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-comment">// 队列还有节点</span><br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span><br>                    <span class="hljs-comment">// 下一个节点 unpark 如果成功获取读锁</span><br>                    <span class="hljs-comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><code>lock</code>-&gt;<code>syn.acquireShare</code>-&gt;<code>tryAcquireShare</code><ul><li>如果其他线程持有写锁：则失败，返回-1</li><li>否则：判断无需等待后，将state加上一个写锁的单位，返回1</li></ul></li><li>返回值大于等于0：成功</li><li>返回值小于0：<ul><li>调用doAcquireShare，类似之前的aquireQueued,将当前线程关联节点，状态设置为SHARE，插入AQS队列尾部。在for循环中判断当前节点的前驱节点是否为头节点<ul><li>是：调用<code>tryAcquireShare</code><ul><li>如果返回值大于等于0，则获取锁成功，并调用<code>setHeadAndPropagate</code>，出队，并不断唤醒AQS队列中的状态为SHARE的节点，直到下一个节点为EXCLUSIVE。记录打断标记，之后退出方法（不返回打断标记）</li></ul></li></ul></li><li>判断是否在失败后阻塞<ul><li>是：阻塞住，并监测打断信号。</li><li>否则：将前驱节点状态设为-1。（下一次循环就又要阻塞了）</li></ul></li></ul></li></ul><p><strong>读锁释放流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>    <span class="hljs-comment">// ReadLock 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-comment">// ... 省略不重要的代码</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc)) &#123;<br>                <span class="hljs-comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span><br>                <span class="hljs-comment">// 计数为 0 才是真正释放</span><br>                <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br>        <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE </span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>                <span class="hljs-comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span><br>                <span class="hljs-comment">// 防止 unparkSuccessor 被多次执行</span><br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><code>unlock</code>-&gt;<code>releaseShared</code>-&gt;<code>tryReleaseShared</code>,将state减去一个share单元，最后state为0则返回true，不然返回false。</li><li>返回tue：调用<code>doReleaseShare</code>,唤醒队列中的节点。</li><li>返回false：解锁不完全。</li></ul><h3 id="stampedlock-带戳读写锁">8.3.4 StampedLock 带戳读写锁</h3><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用 加解读锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.readLock();<br>lock.unlockRead(stamp);<br></code></pre></td></tr></table></figure><p>加解写锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure><p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br>    <span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure><p>提供一个<code>数据容器类</code>内部分别使用读锁保护数据的<code>read()</code>方法，写锁保护数据的<code>write()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainerStamped</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DataContainerStamped</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> readTime)</span> &#123;<br>        <span class="hljs-comment">//获取戳</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br>        log.debug(<span class="hljs-string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-comment">//读取数据</span><br>        sleep(readTime);<br>        <span class="hljs-comment">//读取数据之后再验戳</span><br>        <span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;<br>            log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br>        <span class="hljs-comment">//如果验戳失败，说明已经数据已经被修改，需要升级锁重新读。</span><br>        <span class="hljs-comment">// 锁升级 - 读锁</span><br>        log.debug(<span class="hljs-string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            stamp = lock.readLock();<br>            log.debug(<span class="hljs-string">&quot;read lock &#123;&#125;&quot;</span>, stamp);<br>            sleep(readTime);<br>            log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);<br>            lock.unlockRead(stamp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> newData)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>        log.debug(<span class="hljs-string">&quot;write lock &#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(<span class="hljs-number">2</span>);<br>            <span class="hljs-built_in">this</span>.data = newData;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);<br>            lock.unlockWrite(stamp);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试<code>读-读</code>可以优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">DataContainerStamped</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainerStamped</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        dataContainer.read(<span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    sleep(<span class="hljs-number">0.5</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        dataContainer.read(<span class="hljs-number">0</span>);<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果，可以看到实际没有加读锁</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH">15:58:50.217 c.DataContainerStamped [t1] - optimistic <span class="hljs-built_in">read</span> locking...256 <br>15:58:50.717 c.DataContainerStamped [t2] - optimistic <span class="hljs-built_in">read</span> locking...256 <br>15:58:50.717 c.DataContainerStamped [t2] - <span class="hljs-built_in">read</span> finish...256, data:1 <br>15:58:51.220 c.DataContainerStamped [t1] - <span class="hljs-built_in">read</span> finish...256, data:1 <br></code></pre></td></tr></table></figure><p>测试<code>读-写</code>时优化读补加读锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">DataContainerStamped</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainerStamped</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        dataContainer.read(<span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    sleep(<span class="hljs-number">0.5</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        dataContainer.write(<span class="hljs-number">100</span>);<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SH">15:57:00.219 c.DataContainerStamped [t1] - optimistic <span class="hljs-built_in">read</span> locking...256 <br>15:57:00.717 c.DataContainerStamped [t2] - write lock 384 <br>15:57:01.225 c.DataContainerStamped [t1] - updating to <span class="hljs-built_in">read</span> lock... 256 <br>15:57:02.719 c.DataContainerStamped [t2] - write unlock 384 <br>15:57:02.719 c.DataContainerStamped [t1] - <span class="hljs-built_in">read</span> lock 513 <br>15:57:03.719 c.DataContainerStamped [t1] - <span class="hljs-built_in">read</span> finish...513, data:1000 <br>15:57:03.719 c.DataContainerStamped [t1] - <span class="hljs-built_in">read</span> unlock 513 <br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><ul><li>StampedLock 不支持条件变量</li><li>StampedLock 不支持可重入</li></ul></blockquote><h2 id="semaphore信号量">8.4 Semaphore信号量</h2><p>基本使用</p><p>[ˈsɛməˌfɔr] 信号量，用来<strong>限制能同时访问共享资源的线程上限</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 1. 创建 semaphore 对象</span><br>    <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//3表示可以获得锁的线程个数 </span><br>    <span class="hljs-comment">// 2. 10个线程同时运行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 3. 获取许可</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire();<br>            <span class="hljs-comment">//对于非打断式获取，如果此过程中被打断，线程依旧会等到获取了信号量之后才进入catch块。</span><br>            <span class="hljs-comment">//catch块中的线程依旧持有信号量，捕获该异常后catch块可以不做任何处理。</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                sleep(<span class="hljs-number">1</span>);<br>                log.debug(<span class="hljs-string">&quot;end...&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 4. 释放许可</span><br>                semaphore.release();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">07:35:15.485 c.TestSemaphore [Thread-2] - running... <br>07:35:15.485 c.TestSemaphore [Thread-1] - running... <br>07:35:15.485 c.TestSemaphore [Thread-0] - running... <br>07:35:16.490 c.TestSemaphore [Thread-2] - end... <br>07:35:16.490 c.TestSemaphore [Thread-0] - end... <br>07:35:16.490 c.TestSemaphore [Thread-1] - end... <br>07:35:16.490 c.TestSemaphore [Thread-3] - running... <br>07:35:16.490 c.TestSemaphore [Thread-5] - running... <br>07:35:16.490 c.TestSemaphore [Thread-4] - running... <br>07:35:17.490 c.TestSemaphore [Thread-5] - end... <br>07:35:17.490 c.TestSemaphore [Thread-4] - end... <br>07:35:17.490 c.TestSemaphore [Thread-3] - end... <br>07:35:17.490 c.TestSemaphore [Thread-6] - running... <br>07:35:17.490 c.TestSemaphore [Thread-7] - running... <br>07:35:17.490 c.TestSemaphore [Thread-9] - running... <br>07:35:18.491 c.TestSemaphore [Thread-6] - end... <br>07:35:18.491 c.TestSemaphore [Thread-7] - end... <br>07:35:18.491 c.TestSemaphore [Thread-9] - end... <br>07:35:18.491 c.TestSemaphore [Thread-8] - running... <br>07:35:19.492 c.TestSemaphore [Thread-8] - end... <br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>Semaphore有两个构造器：<code>Semaphore(int permits)</code>和<code>Semaphore(int permits,boolean fair)</code></li><li>permits表示允许同时访问共享资源的线程数。</li><li>fair表示公平与否，与之前的ReentrantLock一样。</li></ul><h3 id="semaphore-应用">8.4.1 <font color="green">* Semaphore 应用</font></h3><p>semaphore 限制对共享资源的使用</p><ul><li>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机 线程数量，并且<strong>仅是限制线程数，而不是限制资源数</strong>（例如连接数，请对比 Tomcat LimitLatch 的实现）</li><li>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好， 注意下面的实现中线程数和数据库连接数是相等的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Pool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>    <span class="hljs-comment">// 1. 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br>    <span class="hljs-comment">// 2. 连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br>    <span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br>    <span class="hljs-comment">// 定义信号量对象</span><br>    <span class="hljs-keyword">private</span> Semaphore semaphore;<br>    <span class="hljs-comment">// 4. 构造方法初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>        <span class="hljs-comment">// 让许可数与资源数一致（许可书=process）</span><br>        <span class="hljs-built_in">this</span>.semaphore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(poolSize);<br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];<br>        <span class="hljs-built_in">this</span>.states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 5. 借连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// t1, t2, t3</span><br>        <span class="hljs-comment">// 获取许可</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            semaphore.acquire(); <span class="hljs-comment">// 没有许可的线程，在此等待</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-comment">// 获取空闲连接</span><br>            <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                    log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                    <span class="hljs-keyword">return</span> connections[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 不会执行到这里</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 6. 归还连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                states.set(i, <span class="hljs-number">0</span>);<br>                log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>                semaphore.release();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="semaphore-原理">8.4.2 <font color="blue">* Semaphore 原理</font></h3><h4 id="加锁解锁流程">加锁解锁流程</h4><p><strong>Semaphore有点像一个停车场，permits就好像停车位数量，当线程获得了permits就像是获得了停车位，然后停车场显示空余车位减一。</strong></p><p>刚开始，permits（state）为 3，这时 5 个线程来获取资源</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191603527.png"></p><p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列 park 阻塞</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191623421.png"></p><p>这时 Thread-4 释放了 permits，状态如下</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191623886.png"></p><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接 下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212191623149.png"></p><p>源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2694183684443567898L</span>;<br>    NonfairSync(<span class="hljs-type">int</span> permits) &#123;<br>        <span class="hljs-comment">// permits 即 state</span><br>        <span class="hljs-built_in">super</span>(permits);<br>    &#125;<br><br>    <span class="hljs-comment">// Semaphore 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireSharedInterruptibly(arg);<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试获得共享锁</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires; <br>            <span class="hljs-keyword">if</span> (<br>                <span class="hljs-comment">// 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly</span><br>                remaining &lt; <span class="hljs-number">0</span> ||<br>                <span class="hljs-comment">// 如果 cas 重试成功, 返回正数, 表示获取成功</span><br>                compareAndSetState(available, remaining)<br>            ) &#123;<br>                <span class="hljs-keyword">return</span> remaining;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                    <span class="hljs-comment">// 再次尝试获取许可</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head</span><br>                        <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br>                        <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE </span><br>                        <span class="hljs-comment">// r 表示可用资源数, 为 0 则不会继续传播</span><br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                        failed = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Semaphore 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>            <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>            <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// Record old head for check below</span><br>    <span class="hljs-comment">// 设置自己为 head</span><br>    setHead(node);<br>    <span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span><br>    <span class="hljs-comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span><br>    <span class="hljs-comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared()) &#123;<br>            doReleaseShared();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="加锁流程总结">加锁流程总结</h5><ul><li><code>acquire</code>-&gt;<code>acquireSharedInterruptibly(1)</code>-&gt;<code>tryAcquireShared(1)</code>-&gt;<code>nonfairTryAcquireShared(1)</code>,如果资源用完了，返回负数，<code>tryAcquireShared</code>返回负数，表示失败。否则返回正数，<code>tryAcquireShared</code>返回正数,表示成功。<ul><li>如果成功，获取信号量成功。</li><li>如果失败，调用<code>doAcquireSharedInterruptibly</code>,进入for循环：<ul><li>如果当前驱节点为头节点，调用<code>tryAcquireShared</code>尝试获取锁<ul><li>如果结果大于等于0，表明获取锁成功，调用<code>setHeadAndPropagate</code>，将当前节点设为头节点，之后又调用<code>doReleaseShared</code>，唤醒后继节点。</li></ul></li><li>调用<code>shoudParkAfterFailure</code>,第一次调用返回false，并将前驱节点改为-1，第二次循环如果再进入此方法，会进入阻塞并检查打断的方法。</li></ul></li></ul></li></ul><h5 id="解锁流程总结">解锁流程总结</h5><ul><li><code>release</code>-&gt;<code>sync.releaseShared(1)</code>-&gt;<code>tryReleaseShared(1)</code>,只要不发生整数溢出，就返回true<ul><li>如果返回true，调用<code>doReleaseShared</code>，唤醒后继节点。</li><li>如果返回false，解锁失败。</li></ul></li></ul><h2 id="countdownlatch倒计时锁">8.5 CountdownLatch倒计时锁</h2><p>用来进行线程同步协作，等待所有线程完成倒计时。</p><p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1.5</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br>    log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>    latch.await();<br>    log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">18:44:00.778 c.TestCountDownLatch [main] - waiting... <br>18:44:00.778 c.TestCountDownLatch [Thread-2] - begin... <br>18:44:00.778 c.TestCountDownLatch [Thread-0] - begin... <br>18:44:00.778 c.TestCountDownLatch [Thread-1] - begin... <br>18:44:01.782 c.TestCountDownLatch [Thread-0] - end...2 <br>18:44:02.283 c.TestCountDownLatch [Thread-2] - end...1 <br>18:44:02.782 c.TestCountDownLatch [Thread-1] - end...0 <br>18:44:02.782 c.TestCountDownLatch [main] - <span class="hljs-built_in">wait</span> end... <br></code></pre></td></tr></table></figure><p>相比于join，CountDownLatch能配合线程池使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1.5</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(()-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>            latch.await();<br>            log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用之同步等待多线程准备完毕"><font color="green">* 应用之同步等待多线程准备完毕</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>, (r) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;t&quot;</span> + num.getAndIncrement());<br>&#125;);<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);<br>String[] all = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> j;<br>    service.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//随机休眠，模拟网络延迟</span><br>                Thread.sleep(r.nextInt(<span class="hljs-number">100</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>            all[x] = Thread.currentThread().getName() + <span class="hljs-string">&quot;(&quot;</span> + (i + <span class="hljs-string">&quot;%&quot;</span>) + <span class="hljs-string">&quot;)&quot;</span>;<br>            <span class="hljs-comment">//\r可以让当前输出覆盖上一次的输出。</span><br>            System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + Arrays.toString(all));<br>        &#125;<br>        latch.countDown();<br>    &#125;);<br>&#125;<br>latch.await();<br>System.out.println(<span class="hljs-string">&quot;\n游戏开始...&quot;</span>);<br>service.shutdown();<br></code></pre></td></tr></table></figure><p>中间输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[t0(52%), t1(47%), t2(51%), t3(40%), t4(49%), t5(44%), t6(49%), t7(52%), t8(46%), t9(46%)] <br></code></pre></td></tr></table></figure><p>最后输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">[t0(100%), t1(100%), t2(100%), t3(100%), t4(100%), t5(100%), t6(100%), t7(100%), t8(100%), <br>t9(100%)] <br>游戏开始... <br></code></pre></td></tr></table></figure><h3 id="应用之同步等待多个远程调用结束"><font color="green">* 应用之同步等待多个远程调用结束</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCountDownlatchController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/order/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">order</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> id)</span> &#123;<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;id&quot;</span>, id);<br>        map.put(<span class="hljs-string">&quot;total&quot;</span>, <span class="hljs-string">&quot;2300.00&quot;</span>);<br>        sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>    <span class="hljs-meta">@GetMapping(&quot;/product/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">product</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> id)</span> &#123;<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">1</span>) &#123;<br>            map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小爱音箱&quot;</span>);<br>            map.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">300</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id == <span class="hljs-number">2</span>) &#123;<br>            map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小米手机&quot;</span>);<br>            map.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">2000</span>);<br>        &#125;<br>        map.put(<span class="hljs-string">&quot;id&quot;</span>, id);<br>        sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>    <span class="hljs-meta">@GetMapping(&quot;/logistics/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">logistics</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> id)</span> &#123;<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;id&quot;</span>, id);<br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;中通快递&quot;</span>);<br>        sleep(<span class="hljs-number">2500</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">int</span> millis)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(millis);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>rest远程调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">4</span>);<br>Future&lt;Map&lt;String,Object&gt;&gt; f1 = service.submit(() -&gt; &#123;<br>    Map&lt;String, Object&gt; r =<br>        restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/order/&#123;1&#125;&quot;</span>, Map.class, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;);<br>Future&lt;Map&lt;String, Object&gt;&gt; f2 = service.submit(() -&gt; &#123;<br>    Map&lt;String, Object&gt; r =<br>        restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;);<br>Future&lt;Map&lt;String, Object&gt;&gt; f3 = service.submit(() -&gt; &#123;<br>    Map&lt;String, Object&gt; r =<br>        restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;);<br>Future&lt;Map&lt;String, Object&gt;&gt; f4 = service.submit(() -&gt; &#123;<br>    Map&lt;String, Object&gt; r =<br>        restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/logistics/&#123;1&#125;&quot;</span>, Map.class, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;);<br>System.out.println(f1.get());<br>System.out.println(f2.get());<br>System.out.println(f3.get());<br>System.out.println(f4.get());<br>log.debug(<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>service.shutdown();<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">19:51:39.711 c.TestCountDownLatch [main] - begin <br>&#123;total=2300.00, <span class="hljs-built_in">id</span>=1&#125; <br>&#123;price=300, name=小爱音箱, <span class="hljs-built_in">id</span>=1&#125; <br>&#123;price=2000, name=小米手机, <span class="hljs-built_in">id</span>=2&#125; <br>&#123;name=中通快递, <span class="hljs-built_in">id</span>=1&#125; <br>19:51:42.407 c.TestCountDownLatch [main] - 执行完毕<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>这种等待多个带有返回值的任务的场景，还是用future比较合适，CountdownLatch适合任务没有返回值的场景。</li></ul><h2 id="cyclicbarrier循环栅栏">8.6 CyclicBarrier循环栅栏</h2><p>CountdownLatch的缺点在于不能重用，见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);<br>        service.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task1 start...&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>            latch.countDown();<br>        &#125;);<br>        service.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task2 start...&quot;</span>);<br>            sleep(<span class="hljs-number">2</span>);<br>            latch.countDown();<br>        &#125;);<br>        <span class="hljs-keyword">try</span> &#123;<br>            latch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;task1 task2 finish...&quot;</span>);<br>    &#125;<br>    service.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><p>想要重复使用CountdownLatch进行同步，必须创建多个CountDownLatch对象。</p><hr><p>我 <strong>CyclicBarrier</strong></p><p>[ˈsaɪklɪk ˈbæriɚ] <strong>循环栅栏，用来进行线程协作，等待线程满足某个计数。</strong>构造时设置『计数个数』，每个线程执 行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 个数为2时才会继续执行</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;线程1开始..&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-keyword">try</span> &#123;<br>        cb.await(); <span class="hljs-comment">// 当个数不足时，等待</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;线程1继续向下运行...&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;线程2开始..&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">2000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        cb.await(); <span class="hljs-comment">// 2 秒后，线程个数够2，继续运行</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;线程2继续向下运行...&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>&#125;).start();<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><ul><li>CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比 喻为『人满发车』</li><li>CountDownLatch的计数和阻塞方法是分开的两个方法，而CyclicBarrier是一个方法。</li><li>CyclicBarrier的构造器还有一个Runnable类型的参数，在计数为0时会执行其中的run方法。</li></ul></blockquote><h2 id="线程安全集合类概述">8.7 线程安全集合类概述</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212200941841.png"></p><p>线程安全集合类可以分为三大类：</p><ul><li>遗留的线程安全集合如<code>Hashtable</code>，<code>Vector</code></li><li>使用<code>Collections</code>装饰的线程安全集合，如：<ul><li><code>Collections.synchronizedCollection</code></li><li><code>Collections.synchronizedList</code></li><li><code>Collections.synchronizedMap</code></li><li><code>Collections.synchronizedSet</code></li><li><code>Collections.synchronizedNavigableMap</code></li><li><code>Collections.synchronizedNavigableSet</code></li><li><code>Collections.synchronizedSortedMap</code></li><li><code>Collections.synchronizedSortedSet</code></li><li>说明：以上集合均采用修饰模式设计，将非线程安全的集合包装后，在调用方法时包裹了一层synchronized代码块。其并发性并不比遗留的安全集合好。</li></ul></li><li>java.util.concurrent.*</li></ul><p>重点介绍<code>java.util.concurrent.*</code>下的线程安全集合类，可以发现它们有规律，里面包含三类关键词： Blocking、CopyOnWrite、Concurrent</p><ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法</li><li>CopyOnWrite 之类容器修改开销相对较重</li><li>Concurrent 类型的容器<ul><li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li><li>弱一致性<ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍 历，这时内容是旧的</li><li>求大小弱一致性，size 操作未必是 100% 准确</li><li>读取弱一致性</li></ul></li></ul></li></ul><blockquote><p>遍历时如果发生了修改，对于非安全容器来讲，使用 <strong>fail-fast</strong> 机制也就是让遍历立刻失败，抛出 ConcurrentModificationException，不再继续遍历</p></blockquote><h3 id="concurrenthashmap">8.7.1 ConcurrentHashMap</h3><h4 id="应用之单词计数"><font color="green">应用之单词计数</font></h4><p><strong>搭建练习环境：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//在main方法中实现两个接口</span><br>    &#125;<br>	<br>    <span class="hljs-comment">//开启26个线程，每个线程调用get方法获取map，从对应的文件读取单词并存储到list中，最后调用accept方法进行统计。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V&gt; <span class="hljs-keyword">void</span>  <span class="hljs-title function_">calculate</span><span class="hljs-params">(Supplier&lt;Map&lt;String,V&gt;&gt; supplier, BiConsumer&lt;Map&lt;String,V&gt;, List&lt;String&gt;&gt; consumer)</span> &#123;<br>        Map&lt;String, V&gt; map = supplier.get();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">26</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">27</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                read(list,k);<br>                consumer.accept(map,list);<br>                count.countDown();<br>            &#125;).start();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            count.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(map.toString());<br>    &#125;<br>	<span class="hljs-comment">//读单词方法的实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(List&lt;String&gt; list,<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            String element;<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(i + <span class="hljs-string">&quot;.txt&quot;</span>));<br>            <span class="hljs-keyword">while</span>((element = reader.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                list.add(element);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br><br>        &#125;<br>    &#125;<br>	<span class="hljs-comment">//生成测试数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">construct</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">200</span>; j++) &#123;<br>                list.add(String.valueOf(str.charAt(i)));<br>            &#125;<br>        &#125;<br>        Collections.shuffle(list);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(i + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;.txt&quot;</span>))) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">collect</span> <span class="hljs-operator">=</span> list.subList(i * <span class="hljs-number">200</span>, (i + <span class="hljs-number">1</span>) * <span class="hljs-number">200</span>).stream().collect(Collectors.joining(<span class="hljs-string">&quot;\n&quot;</span>));<br>                out.println(collect);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br>    <span class="hljs-comment">// 创建 map 集合</span><br>    <span class="hljs-comment">// 创建 ConcurrentHashMap 对不对？</span><br>    () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;String, Integer&gt;(),<br>    <span class="hljs-comment">// 进行计数</span><br>    (map, words) -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> map.get(word);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> counter == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : counter + <span class="hljs-number">1</span>;<br>            map.put(word, newValue);<br>        &#125;<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">&#123;a=186, b=192, c=187, d=184, e=185, f=185, g=176, h=185, i=193, j=189, k=187, l=157, m=189, n=181, o=180, p=178, q=185, r=188, s=181, t=183, u=177, v=186, w=188, x=178, y=189, z=186&#125;<br>47<br></code></pre></td></tr></table></figure><p>错误原因：</p><ul><li>ConcurrentHashMap虽然每个方法都是线程安全的，但是<strong>多个方法的组合并不是线程安全的</strong>。</li></ul><p><strong>正确答案一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br>    () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;String, LongAdder&gt;(),<br>    (map, words) -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-comment">// 注意不能使用 putIfAbsent，此方法返回的是上一次的 value，首次调用返回 null</span><br>            map.computeIfAbsent(word, (key) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>()).increment();<br>            <span class="hljs-comment">//computeIfAbsent 如果缺少一个key，则计算生成一个value，然后将key value放入map</span><br>        &#125;<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>computIfAbsent方法的作用是：当map中不存在以参数1为key对应的value时，会将参数2函数式接口的返回值作为value，put进map中，然后返回该value。如果存在key，则直接返回value</li><li>以上两部均是线程安全的。</li></ul><p><strong>正确答案二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br>    () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;String, Integer&gt;(),<br>    (map, words) -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-comment">// 函数式编程，无需原子变量</span><br>            map.merge(word, <span class="hljs-number">1</span>, Integer::sum);<br>        &#125;<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><h3 id="concurrenthashmap-原理">8.7.2 <font color="blue">* ConcurrentHashMap 原理</font></h3><h4 id="jdk-7-hashmap-并发死链问题">1）JDK 7 HashMap 并发死链问题</h4><p>测试代码</p><p>注意</p><ul><li>要在 JDK 7 下运行，否则扩容机制和 hash 的计算方法都变了</li><li>以下测试代码是精心准备的，不要随便改动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 测试 java 7 中哪些数字的 hash 结果相等</span><br>    System.out.println(<span class="hljs-string">&quot;长度为16时，桶下标为1的key&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (hash(i) % <span class="hljs-number">16</span> == <span class="hljs-number">1</span>) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;长度为32时，桶下标为1的key&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (hash(i) % <span class="hljs-number">32</span> == <span class="hljs-number">1</span>) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 1, 35, 16, 50 当大小为16时，它们在一个桶内</span><br>    <span class="hljs-keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>    <span class="hljs-comment">// 放 12 个元素</span><br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">4</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">5</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">6</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">7</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">8</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">9</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">10</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">16</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">35</span>, <span class="hljs-literal">null</span>);<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>);<br>    System.out.println(<span class="hljs-string">&quot;扩容前大小[main]:&quot;</span>+map.size());<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 放第 13 个元素, 发生扩容</span><br>            map.put(<span class="hljs-number">50</span>, <span class="hljs-literal">null</span>);<br>            System.out.println(<span class="hljs-string">&quot;扩容后大小[Thread-0]:&quot;</span>+map.size());<br>        &#125;<br>    &#125;.start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 放第 13 个元素, 发生扩容</span><br>            map.put(<span class="hljs-number">50</span>, <span class="hljs-literal">null</span>);<br>            System.out.println(<span class="hljs-string">&quot;扩容后大小[Thread-1]:&quot;</span>+map.size());<br>        &#125;<br>    &#125;.start();<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>    &#125;<br>    h ^= k.hashCode();<br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="死链复现"><strong>死链复现</strong></h5><p>调试工具使用 idea</p><p>在 HashMap 源码 590 行加断点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br></code></pre></td></tr></table></figure><p>断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">newTable.length==<span class="hljs-number">32</span> &amp;&amp;<br> (<br> Thread.currentThread().getName().equals(<span class="hljs-string">&quot;Thread-0&quot;</span>)||<br> Thread.currentThread().getName().equals(<span class="hljs-string">&quot;Thread-1&quot;</span>)<br> )<br></code></pre></td></tr></table></figure><p>断点暂停方式选择 Thread，否则在调试 Thread-0 时，Thread-1 无法恢复运行</p><p>运行代码，程序在预料的断点位置停了下来，输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">长度为16时，桶下标为1的key <br>1 <br>16 <br>35 <br>50 <br>长度为32时，桶下标为1的key <br>1 <br>35 <br>扩容前大小[main]:12 <br></code></pre></td></tr></table></figure><p>接下来进入扩容流程调试</p><p>在 HashMap 源码 594 行加断点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Entry&lt;K,V&gt; next = e.next; <span class="hljs-comment">// 593</span><br><span class="hljs-keyword">if</span> (rehash) <span class="hljs-comment">// 594</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>这是为了观察 e 节点和 next 节点的状态，Thread-0 单步执行到 594 行，再 594 处再添加一个断点（条件 Thread.currentThread().getName().equals("Thread-0")）</p><p>这时可以在 Variables 面板观察到 e 和 next 变量，使用<code>view as -&gt; Object</code>查看节点状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">e (<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">16</span>)-&gt;<span class="hljs-literal">null</span> <br><span class="hljs-title function_">next</span> <span class="hljs-params">(<span class="hljs-number">35</span>)</span>-&gt;(<span class="hljs-number">16</span>)-&gt;<span class="hljs-literal">null</span> <br></code></pre></td></tr></table></figure><p>在 Threads 面板选中 Thread-1 恢复运行，可以看到控制台输出新的内容如下，Thread-1 扩容已完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">newTable[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">1</span>)-&gt;<span class="hljs-literal">null</span> <br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">扩容后大小:13 <br></code></pre></td></tr></table></figure><p>这时 Thread-0 还停在 594 处， Variables 面板变量的状态已经变化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">e (<span class="hljs-number">1</span>)-&gt;<span class="hljs-literal">null</span> <br><span class="hljs-title function_">next</span> <span class="hljs-params">(<span class="hljs-number">35</span>)</span>-&gt;(<span class="hljs-number">1</span>)-&gt;<span class="hljs-literal">null</span> <br></code></pre></td></tr></table></figure><p>为什么呢，因为 Thread-1 扩容时链表也是后加入的元素放入链表头，因此链表就倒过来了，但 Thread-1 虽然结 果正确，但它结束后 Thread-0 还要继续运行</p><p>接下来就可以单步调试（F8）观察死链的产生了</p><p>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">newTable[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>)-&gt;<span class="hljs-literal">null</span> <br><span class="hljs-title function_">e</span> <span class="hljs-params">(<span class="hljs-number">35</span>)</span>-&gt;(<span class="hljs-number">1</span>)-&gt;<span class="hljs-literal">null</span> <br><span class="hljs-title function_">next</span> <span class="hljs-params">(<span class="hljs-number">1</span>)</span>-&gt;<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">newTable[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">1</span>)-&gt;<span class="hljs-literal">null</span> <br><span class="hljs-title function_">e</span> <span class="hljs-params">(<span class="hljs-number">1</span>)</span>-&gt;<span class="hljs-literal">null</span> <br>next <span class="hljs-literal">null</span> <br></code></pre></td></tr></table></figure><p>再看看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">e.next = newTable[<span class="hljs-number">1</span>];<br><span class="hljs-comment">// 这时 e (1,35)</span><br><span class="hljs-comment">// 而 newTable[1] (35,1)-&gt;(1,35) 因为是同一个对象</span><br>newTable[<span class="hljs-number">1</span>] = e; <br><span class="hljs-comment">// 再尝试将 e 作为链表头, 死链已成</span><br>e = next;<br><span class="hljs-comment">// 虽然 next 是 null, 会进入下一个链表的复制, 但死链已经形成了</span><br></code></pre></td></tr></table></figure><p><strong>源码分析</strong></p><p>HashMap 的并发死链发生在扩容时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将 table 迁移至 newTable</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-type">boolean</span> rehash)</span> &#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123;<br>            Entry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-comment">// 1 处</span><br>            <span class="hljs-keyword">if</span> (rehash) &#123;<br>                e.hash = <span class="hljs-literal">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity);<br>            <span class="hljs-comment">// 2 处</span><br>            <span class="hljs-comment">// 将新元素加入 newTable[i], 原 newTable[i] 作为新元素的 next</span><br>            e.next = newTable[i];<br>            newTable[i] = e;<br>            e = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设 map 中初始元素是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">原始链表，格式：[下标] (key,next)<br>[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">35</span>,<span class="hljs-number">16</span>)-&gt;(<span class="hljs-number">16</span>,<span class="hljs-literal">null</span>)<br>线程 a 执行到 <span class="hljs-number">1</span> 处 ，此时局部变量 e 为 (<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)，而局部变量 next 为 (<span class="hljs-number">35</span>,<span class="hljs-number">16</span>) 线程 a 挂起<br>线程 b 开始执行<br>第一次循环<br>[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>)<br>第二次循环<br>[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>)<br>第三次循环<br>[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>)<br>[<span class="hljs-number">17</span>] (<span class="hljs-number">16</span>,<span class="hljs-literal">null</span>)<br>切换回线程 a，此时局部变量 e 和 next 被恢复，引用没变但内容变了：e 的内容被改为 (<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>)，而 next 的内<br>容被改为 (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>) 并链向 (<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>)<br>第一次循环<br>[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>)<br>第二次循环，注意这时 e 是 (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>) 并链向 (<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>) 所以 next 又是 (<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>)<br>[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>)<br>第三次循环，e 是 (<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>)，而 next 是 <span class="hljs-literal">null</span>，但 e 被放入链表头，这样 e.next 变成了 <span class="hljs-number">35</span> （<span class="hljs-number">2</span> 处）<br>[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)<br>已经是死链了<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li>究其原因，是因为<strong>在多线程环境下使用了非线程安全的 map 集合</strong></li><li><strong>JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能 够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</strong></li></ul><h4 id="jdk-8-concurrenthashmap">2）JDK 8 ConcurrentHashMap</h4><h5 id="重要属性和内部类">重要属性和内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认为 0</span><br><span class="hljs-comment">// 当初始化时, 为 -1</span><br><span class="hljs-comment">// 当扩容时, 为 -(1 + 扩容线程数)</span><br><span class="hljs-comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sizeCtl;<br><span class="hljs-comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;&#125;<br><span class="hljs-comment">// hash 表</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br><span class="hljs-comment">// 扩容时的 新 hash 表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<br><span class="hljs-comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br><span class="hljs-comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReservationNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br><span class="hljs-comment">// 作为 treebin 的头节点, 存储 root 和 first</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br><span class="hljs-comment">// 作为 treebin 的节点, 存储 parent, left, right</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><h5 id="重要方法">重要方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 Node[] 中第 i 个 Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span><br> <br><span class="hljs-comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span><br> <br><span class="hljs-comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; v)</span><br></code></pre></td></tr></table></figure><h5 id="构造器源码分析">构造器源码分析</h5><p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0.0f</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; concurrencyLevel) <span class="hljs-comment">// Use at least as many bins</span><br>        initialCapacity = concurrencyLevel; <span class="hljs-comment">// as estimated threads</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)(<span class="hljs-number">1.0</span> + (<span class="hljs-type">long</span>)initialCapacity / loadFactor);<br>    <span class="hljs-comment">// tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ... </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> (size &gt;= (<span class="hljs-type">long</span>)MAXIMUM_CAPACITY) ?<br>        MAXIMUM_CAPACITY : tableSizeFor((<span class="hljs-type">int</span>)size);<br>    <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="get流程">get流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br>    <span class="hljs-comment">// spread 方法能确保返回结果是正数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果头结点已经是要查找的 key</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-comment">// hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 正常遍历链表, 用 equals 比较</span><br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>如果table不为空且长度大于0且索引位置有元素<ul><li>if 头节点key的hash值相等<ul><li>头节点的key指向同一个地址或者equals<ul><li>返回value</li></ul></li></ul></li><li>else if 头节点的hash为负数（bin在扩容或者是treebin）<ul><li>调用find方法查找</li></ul></li><li>进入循环（e不为空）：<ul><li>节点key的hash值相等，且key指向同一个地址或equals<ul><li>返回value</li></ul></li></ul></li></ul></li><li>返回null</li></ul><h5 id="put-流程">put 流程</h5><p>以下数组简称（table），链表简称（bin）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 其中 spread 方法会综合高位低位, 具有更好的 hash 性</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        <span class="hljs-comment">// f 是链表头节点</span><br>        <span class="hljs-comment">// fh 是链表头结点的 hash</span><br>        <span class="hljs-comment">// i 是链表在 table 中的下标</span><br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-comment">// 要创建 table</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 初始化 table 使用了 cas, 无需 synchronized 创建成功, 进入下一轮循环</span><br>            tab = initTable();<br>        <span class="hljs-comment">// 要创建链表头节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 添加链表头使用了 cas, 无需 synchronized</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 帮忙扩容</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            <span class="hljs-comment">// 帮忙之后, 进入下一轮循环</span><br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 锁住链表头节点</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-comment">// 再次确认链表头节点没有被移动</span><br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">// 链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">// 遍历链表</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-comment">// 找到相同的 key</span><br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-comment">// 更新</span><br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-comment">// 已经是最后的节点了, 新增 Node, 追加至链表尾</span><br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 红黑树</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-comment">// putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode</span><br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                              value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 释放链表头节点的锁</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123; <br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    <span class="hljs-comment">// 如果链表长度 &gt;= 树化阈值(8), 进行链表转为红黑树</span><br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 增加 size 计数</span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.yield();<br>        <span class="hljs-comment">// 尝试将 sizeCtl 设置为 -1（表示初始化 table）</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">// 获得锁, 创建 table, 这时其它线程会在 while() 循环中 yield 直至 table 创建</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br><span class="hljs-comment">// check 是之前 binCount 的个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCount</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">int</span> check)</span> &#123;<br>    CounterCell[] as; <span class="hljs-type">long</span> b, s;<br>    <span class="hljs-keyword">if</span> (<br>        <span class="hljs-comment">// 已经有了 counterCells, 向 cell 累加</span><br>        (as = counterCells) != <span class="hljs-literal">null</span> ||<br>        <span class="hljs-comment">// 还没有, 向 baseCount 累加</span><br>        !U.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)<br>    ) &#123;<br>        CounterCell a; <span class="hljs-type">long</span> v; <span class="hljs-type">int</span> m;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// 还没有 counterCells</span><br>            as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            <span class="hljs-comment">// 还没有 cell</span><br>            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            <span class="hljs-comment">// cell cas 增加计数失败</span><br>            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))<br>        ) &#123;<br>            <span class="hljs-comment">// 创建累加单元数组和cell, 累加重试</span><br>            fullAddCount(x, uncontended);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 获取元素个数</span><br>        s = sumCount();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab, nt; <span class="hljs-type">int</span> n, sc;<br>        <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-literal">null</span> &amp;&amp;<br>               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(n);<br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-literal">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// newtable 已经创建了，帮忙扩容</span><br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-comment">// 需要扩容，这时 newtable 未创建</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc,<br>                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-literal">null</span>);<br>            s = sumCount();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>进入for循环：<ul><li>if table为null或者长度 为0<ul><li>初始化表</li></ul></li><li>else if 索引处无节点<ul><li>创建节点，填入key和value，放入table，退出循环</li></ul></li><li>else if 索引处节点的hash值为MOVE（ForwardingNode），表示正在扩容和迁移<ul><li>帮忙</li></ul></li><li>else<ul><li>锁住头节点<ul><li>if 再次确认头节点没有被移动<ul><li>if 头节点hash值大于0（表示这是一个链表）<ul><li>遍历链表找到对应key，如果没有，创建。</li></ul></li><li>else if 节点为红黑树节点<ul><li>调用<code>putTreeVal</code>查看是否有对应key的数节点<ul><li>如果有且为覆盖模式，将值覆盖，返回旧值</li><li>如果没有，创建并插入，返回null</li></ul></li></ul></li></ul></li><li>解锁</li></ul></li><li>if binCount不为0<ul><li>如果binCount大于树化阈值8<ul><li>树化</li></ul></li><li>如果旧值不为null<ul><li>返回旧值</li></ul></li><li>break</li></ul></li></ul></li></ul></li><li>增加size计数</li><li>return null</li></ul><h5 id="size-计算流程">size 计算流程</h5><p>size 计算实际发生在 put，remove 改变集合元素的操作之中</p><ul><li>没有竞争发生，向 baseCount 累加计数</li><li>有竞争发生，新建 counterCells，向其中的一个 cell 累加计<ul><li>counterCells 初始有两个 cell</li><li>如果计数竞争比较激烈，会创建新的 cell 来累加计数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sumCount();<br>    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> :<br>            (n &gt; (<span class="hljs-type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :<br>            (<span class="hljs-type">int</span>)n);<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>    CounterCell[] as = counterCells; CounterCell a;<br>    <span class="hljs-comment">// 将 baseCount 计数与所有 cell 计数累加</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="总结">总结</h5><p><strong>Java 8</strong> 数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）</p><ul><li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li><li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程 会用 synchronized 锁住链表头</li><li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素 添加至 bin 的尾部</li><li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索</li><li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可 做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中</li><li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加 即可</li></ul><p>源码分析 http://www.importnew.com/28263.html</p><p>其它实现 <a target="_blank" rel="noopener" href="https://github.com/boundary/high-scale-lib">Cliff Click's high scale lib</a></p><h4 id="jdk-7-concurrenthashmap">3）JDK 7 ConcurrentHashMap</h4><p>它维护了一个 segment 数组，每个 segment 对应一把锁</p><ul><li>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的</li><li>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</li></ul><h5 id="构造器分析">构造器分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)<br>        concurrencyLevel = MAX_SEGMENTS;<br>    <span class="hljs-comment">// ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sshift</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ssize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;<br>        ++sshift;<br>        ssize &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// segmentShift 默认是 32 - 4 = 28</span><br>    <span class="hljs-built_in">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;<br>    <span class="hljs-comment">// segmentMask 默认是 15 即 0000 0000 0000 1111</span><br>    <span class="hljs-built_in">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> initialCapacity / ssize;<br>    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)<br>        ++c;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;<br>    <span class="hljs-keyword">while</span> (cap &lt; c)<br>        cap &lt;&lt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 创建 segments and segments[0]</span><br>    Segment&lt;K,V&gt; s0 =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="hljs-type">int</span>)(cap * loadFactor),<br>                         (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap]);<br>    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>[ssize];<br>    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span><br>    <span class="hljs-built_in">this</span>.segments = ss;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造完成，如下图所示</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201105506.png"></p><p>可以看到 ConcurrentHashMap 没有实现懒惰初始化，空间占用不友好</p><p>其中 this.segmentShift 和 this.segmentMask 的作用是决定将 key 的 hash 结果匹配到哪个 segment</p><p>例如，根据某一 hash 值求 segment 位置，先将高位向低位移动 this.segmentShift 位</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201105040.png"></p><p>结果再与 this.segmentMask 做位于运算，最终得到 1010 即下标为 10 的 segment</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201105293.png"></p><h5 id="put-流程-1">put 流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    Segment&lt;K,V&gt; s;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-comment">// 计算出 segment 下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br><br>    <span class="hljs-comment">// 获得 segment 对象, 判断是否为 null, 是则创建该 segment</span><br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject <br>         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 这时不能确定是否真的为 null, 因为其它线程也发现该 segment 为 null,</span><br>        <span class="hljs-comment">// 因此在 ensureSegment 里用 cas 方式保证该 segment 安全性</span><br>        s = ensureSegment(j);<br>    &#125;<br>    <span class="hljs-comment">// 进入 segment 的put 流程</span><br>    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>segment 继承了可重入锁（ReentrantLock），它的 put 方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// 尝试加锁</span><br>    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-literal">null</span> :<br>    <span class="hljs-comment">// 如果不成功, 进入 scanAndLockForPut 流程</span><br>    <span class="hljs-comment">// 如果是多核 cpu 最多 tryLock 64 次, 进入 lock 流程</span><br>    <span class="hljs-comment">// 在尝试期间, 还可以顺便看该节点在链表中有没有, 如果没有顺便创建出来</span><br>    scanAndLockForPut(key, hash, value);<br><br>    <span class="hljs-comment">// 执行到这里 segment 已经被成功加锁, 可以安全执行</span><br>    V oldValue;<br>    <span class="hljs-keyword">try</span> &#123;<br>        HashEntry&lt;K,V&gt;[] tab = table;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (tab.length - <span class="hljs-number">1</span>) &amp; hash;<br>        HashEntry&lt;K,V&gt; first = entryAt(tab, index);<br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 更新</span><br>                K k;<br>                <span class="hljs-keyword">if</span> ((k = e.key) == key ||<br>                    (e.hash == hash &amp;&amp; key.equals(k))) &#123; <br>                    oldValue = e.value;<br>                    <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                        e.value = value;<br>                        ++modCount;<br>                    &#125; <span class="hljs-keyword">break</span>;<br>                &#125;<br>                e = e.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 新增</span><br>                <span class="hljs-comment">// 1) 之前等待锁时, node 已经被创建, next 指向链表头</span><br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>                    node.setNext(first);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// 2) 创建新 node</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count + <span class="hljs-number">1</span>; <br>                <span class="hljs-comment">// 3) 扩容</span><br>                <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)<br>                    rehash(node);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// 将 node 作为链表头</span><br>                    setEntryAt(tab, index, node);<br>                ++modCount;<br>                count = c;<br>                oldValue = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="rehash-流程">rehash 流程</h5><p>发生在 put 中，因为此时已经获得了锁，因此 rehash 时不需要考虑线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">(HashEntry&lt;K,V&gt; node)</span> &#123;<br>    HashEntry&lt;K,V&gt;[] oldTable = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity &lt;&lt; <span class="hljs-number">1</span>;<br>    threshold = (<span class="hljs-type">int</span>)(newCapacity * loadFactor);<br>    HashEntry&lt;K,V&gt;[] newTable =<br>        (HashEntry&lt;K,V&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[newCapacity];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sizeMask</span> <span class="hljs-operator">=</span> newCapacity - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; oldCapacity ; i++) &#123;<br>        HashEntry&lt;K,V&gt; e = oldTable[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            HashEntry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> e.hash &amp; sizeMask;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) <span class="hljs-comment">// Single node on list</span><br>                newTable[idx] = e;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Reuse consecutive sequence at same slot</span><br>                HashEntry&lt;K,V&gt; lastRun = e;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">lastIdx</span> <span class="hljs-operator">=</span> idx;<br>                <span class="hljs-comment">// 过一遍链表, 尽可能把 rehash 后 idx 不变的节点重用</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next;<br>                     last != <span class="hljs-literal">null</span>;<br>                     last = last.next) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> last.hash &amp; sizeMask;<br>                    <span class="hljs-keyword">if</span> (k != lastIdx) &#123;<br>                        lastIdx = k;<br>                        lastRun = last;<br>                    &#125;<br>                &#125;<br>                newTable[lastIdx] = lastRun;<br>                <span class="hljs-comment">// 剩余节点需要新建</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;<br>                    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> p.value;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> p.hash;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> h &amp; sizeMask;<br>                    HashEntry&lt;K,V&gt; n = newTable[k];<br>                    newTable[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 扩容完成, 才加入新的节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nodeIndex</span> <span class="hljs-operator">=</span> node.hash &amp; sizeMask; <span class="hljs-comment">// add the new node</span><br>    node.setNext(newTable[nodeIndex]);<br>    newTable[nodeIndex] = node;<br><br>    <span class="hljs-comment">// 替换为新的 HashEntry table</span><br>    table = newTable;<br>&#125;<br></code></pre></td></tr></table></figure><p>附，调试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ConcurrentHashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(i);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">segmentIndex</span> <span class="hljs-operator">=</span> (hash &gt;&gt;&gt; <span class="hljs-number">28</span>) &amp; <span class="hljs-number">15</span>;<br>        <span class="hljs-keyword">if</span> (segmentIndex == <span class="hljs-number">4</span> &amp;&amp; hash % <span class="hljs-number">8</span> == <span class="hljs-number">2</span>) &#123;<br>            System.out.println(i + <span class="hljs-string">&quot;\t&quot;</span> + segmentIndex + <span class="hljs-string">&quot;\t&quot;</span> + hash % <span class="hljs-number">2</span> + <span class="hljs-string">&quot;\t&quot;</span> + hash % <span class="hljs-number">4</span> +<br>                               <span class="hljs-string">&quot;\t&quot;</span> + hash % <span class="hljs-number">8</span>);<br>        &#125;<br>    &#125;<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>    map.put(<span class="hljs-number">15</span>, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// 2 扩容为 4 15 的 hash%8 与其他不同</span><br>    map.put(<span class="hljs-number">169</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>    map.put(<span class="hljs-number">197</span>, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// 4 扩容为 8</span><br>    map.put(<span class="hljs-number">341</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>    map.put(<span class="hljs-number">484</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>    map.put(<span class="hljs-number">545</span>, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// 8 扩容为 16</span><br>    map.put(<span class="hljs-number">912</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>    map.put(<span class="hljs-number">941</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-number">0</span> != h) &amp;&amp; (k <span class="hljs-keyword">instanceof</span> String)) &#123;<br>        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>    &#125;<br>    h ^= k.hashCode();<br>    <span class="hljs-comment">// Spread bits to regularize both segment and index locations,</span><br>    <span class="hljs-comment">// using variant of single-word Wang/Jenkins hash.</span><br>    h += (h &lt;&lt; <span class="hljs-number">15</span>) ^ <span class="hljs-number">0xffffcd7d</span>;<br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">10</span>);<br>    h += (h &lt;&lt; <span class="hljs-number">3</span>);<br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">6</span>);<br>    h += (h &lt;&lt; <span class="hljs-number">2</span>) + (h &lt;&lt; <span class="hljs-number">14</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="get-流程">get 流程</h5><p>get 时并未加锁，用了 UNSAFE 方法保证了可见性，扩容过程中，get 先发生就从旧表取内容，get 后发生就从新 表取内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Segment&lt;K,V&gt; s; <span class="hljs-comment">// manually integrate access methods to reduce overhead</span><br>    HashEntry&lt;K,V&gt;[] tab;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-comment">// u 为 segment 对象在数组中的偏移量</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;<br>    <span class="hljs-comment">// s 即为 segment</span><br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-literal">null</span> &amp;&amp;<br>        (tab = s.table) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile<br>             (tab, ((<span class="hljs-type">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);<br>             e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>            K k;<br>            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))<br>                <span class="hljs-keyword">return</span> e.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="size-计算流程-1">size 计算流程</h5><ul><li>计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回</li><li>如果不一样，进行重试，重试次数超过 3，将所有 segment 锁住，重新计算个数返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Try a few times to get accurate count. On failure due to</span><br>    <span class="hljs-comment">// continuous async changes in table, resort to locking.</span><br>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="hljs-built_in">this</span>.segments;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">boolean</span> overflow; <span class="hljs-comment">// true if size overflows 32 bits</span><br>    <span class="hljs-type">long</span> sum; <span class="hljs-comment">// sum of modCounts</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>; <span class="hljs-comment">// previous sum</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">retries</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// first iteration isn&#x27;t retry</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;<br>                <span class="hljs-comment">// 超过重试次数, 需要创建所有 segment 并加锁</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; segments.length; ++j)<br>                    ensureSegment(j).lock(); <span class="hljs-comment">// force creation</span><br>            &#125;<br>            sum = <span class="hljs-number">0L</span>;<br>            size = <span class="hljs-number">0</span>;<br>            overflow = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; segments.length; ++j) &#123;<br>                Segment&lt;K,V&gt; seg = segmentAt(segments, j);<br>                <span class="hljs-keyword">if</span> (seg != <span class="hljs-literal">null</span>) &#123;<br>                    sum += seg.modCount;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> seg.count;<br>                    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span> || (size += c) &lt; <span class="hljs-number">0</span>)<br>                        overflow = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sum == last)<br>                <span class="hljs-keyword">break</span>;<br>            last = sum;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; segments.length; ++j)<br>                segmentAt(segments, j).unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> overflow ? Integer.MAX_VALUE : size;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="blockingqueue">8.8 BlockingQueue</h2><h3 id="linkedblockingqueue-原理">8.8.1 <font color="blue">* LinkedBlockingQueue 原理</font></h3><h4 id="基本的入队出队">基本的入队出队</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E item;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment"> 		* 下列三种情况之一</span><br><span class="hljs-comment"> 		* - 真正的后继节点</span><br><span class="hljs-comment"> 		* - 自己, 发生在出队时</span><br><span class="hljs-comment"> 		* - null, 表示是没有后继节点, 是最后了</span><br><span class="hljs-comment"> 		*/</span><br>        Node&lt;E&gt; next;<br>        Node(E x) &#123; item = x; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>初始化链表</strong></p><p><code>last = head = new Node(null);</code>Dummy 节点用来占位，item 为 null</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201106146.png"></p><p><strong>当一个节点入队</strong></p><p><code>last = last.next = node;</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201106817.png"></p><p>再来一个节点入队<code>last = last.next = node;</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201106530.png"></p><p><strong>出队</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//临时变量h用来指向哨兵</span><br>Node&lt;E&gt; h = head;<br><span class="hljs-comment">//first用来指向第一个元素</span><br>Node&lt;E&gt; first = h.next;<br>h.next = h; <span class="hljs-comment">// help GC</span><br><span class="hljs-comment">//head赋值为first，表示first节点就是下一个哨兵。</span><br>head = first;<br><span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;<br><span class="hljs-comment">//删除first节点中的数据，表示真正成为了哨兵，第一个元素出队。</span><br>first.item = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure><p><code>h = head</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201106035.png"></p><p><code>first = h.next</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201106537.png"></p><p><code>h.next = h</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201106985.png"></p><p><code>head = first</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201107415.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;<br>first.item = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201107876.png"></p><h4 id="加锁分析">加锁分析</h4><p><strong>高明之处</strong>在于用了两把锁和 dummy 节点</p><ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><p>线程安全分析</p><ul><li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争</li><li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于 put(阻塞) offer(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">// 用户 take(阻塞) poll(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br></code></pre></td></tr></table></figure><p>put 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//LinkedBlockingQueue不支持空元素</span><br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;<br>    <span class="hljs-comment">// count 用来维护元素计数</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>    putLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 满了等待</span><br>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;<br>            <span class="hljs-comment">// 倒过来读就好: 等待 notFull</span><br>            notFull.await();<br>        &#125;<br>        <span class="hljs-comment">// 有空位, 入队且计数加一</span><br>        enqueue(node);<br>        c = count.getAndIncrement(); <br>        <span class="hljs-comment">// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程</span><br>        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)<br>            notFull.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        putLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 如果队列中有一个元素, 叫醒 take 线程</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争</span><br>        signalNotEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><p>take 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    E x;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;<br>    takeLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;<br>            notEmpty.await();<br>        &#125;<br>        x = dequeue();<br>        c = count.getAndDecrement();<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)<br>            notEmpty.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        takeLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 如果队列中只有一个空位时, 叫醒 put 线程</span><br>    <span class="hljs-comment">// 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity</span><br>    <span class="hljs-keyword">if</span> (c == capacity)<br>        <span class="hljs-comment">// 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span><br>        signalNotFull()<br>        <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由 put 唤醒 put 是为了避免信号不足</p></blockquote><h4 id="性能比较">性能比较</h4><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p><ul><li>Linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Array 实现是数组</li><li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁</li></ul><h2 id="concurrentlinkedqueue">8.9 ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p><ul><li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li><li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</li><li>只是这【锁】使用了 cas 来实现</li></ul><p>事实上，ConcurrentLinkedQueue 应用还是非常广泛的</p><p>例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了 ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201122663.png"></p><h3 id="concurrentlinkedqueue-原理"><font color="blue">*ConcurrentLinkedQueue 原理</font></h3><h4 id="模仿-concurrentlinkedqueue">模仿 ConcurrentLinkedQueue</h4><p>初始代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.concurrent.thirdpart.test;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-string">&quot;1&quot;</span>);<br>        queue.offer(<span class="hljs-string">&quot;2&quot;</span>);<br>        queue.offer(<span class="hljs-string">&quot;3&quot;</span>);<br>        System.out.println(queue);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; p = head; p != <span class="hljs-literal">null</span>; p = p.next.get()) &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> p.item;<br>            <span class="hljs-keyword">if</span> (item != <span class="hljs-literal">null</span>) &#123;<br>                sb.append(item).append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            &#125;<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;null&quot;</span>);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">element</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        head = last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; last;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;<br>    <span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/*Node&lt;E&gt; h = head;</span><br><span class="hljs-comment"> 		Node&lt;E&gt; first = h.next;</span><br><span class="hljs-comment"> 		h.next = h;</span><br><span class="hljs-comment"> 		head = first;</span><br><span class="hljs-comment">        E x = first.item;</span><br><span class="hljs-comment"> 		first.item = null;</span><br><span class="hljs-comment"> 		return x;*/</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        <span class="hljs-keyword">volatile</span> E item;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E item, Node&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.item = item;<br>            <span class="hljs-built_in">this</span>.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(next);<br>        &#125;<br>        AtomicReference&lt;Node&lt;E&gt;&gt; next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>offer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    Node&lt;E&gt; n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(e, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 获取尾节点</span><br>        AtomicReference&lt;Node&lt;E&gt;&gt; next = last.next;<br>        <span class="hljs-comment">// S1: 真正尾节点的 next 是 null, cas 从 null 到新节点</span><br>        <span class="hljs-keyword">if</span>(next.compareAndSet(<span class="hljs-literal">null</span>, n)) &#123;<br>            <span class="hljs-comment">// 这时的 last 已经是倒数第二, next 不为空了, 其它线程的 cas 肯定失败</span><br>            <span class="hljs-comment">// S2: 更新 last 为倒数第一的节点</span><br>            last = n;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="copyonwritearraylist">8.10 CopyOnWriteArrayList</h2><p><code>CopyOnWriteArraySet</code>是它的马甲 底层实现采用了 写入时拷贝 的思想，增删改操作会将底层数组拷贝一份，更 改操作在新数组上执行，这时不影响其它线程的<strong>并发读</strong>，<strong>读写分离</strong>。 以新增为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 获取旧的数组</span><br>        Object[] es = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> es.length;<br>        <span class="hljs-comment">// 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）</span><br>        es = Arrays.copyOf(es, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 添加新元素</span><br>        es[len] = e;<br>        <span class="hljs-comment">// 替换旧的数组</span><br>        setArray(es);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的源码版本是 Java 11，在 Java 1.8 中使用的是可重入锁而不是 synchronized</p></blockquote><p>其它读操作并未加锁，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>    Objects.requireNonNull(action);<br>    <span class="hljs-keyword">for</span> (Object x : getArray()) &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) x;<br>        action.accept(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>适合『读多写少』的应用场景</p><h3 id="get-弱一致性">get 弱一致性</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212201123881.png"></p><table><thead><tr class="header"><th style="text-align:center">时间点</th><th style="text-align:center">操作</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">1</td><td style="text-align:center">Thread-0 getArray()</td></tr><tr class="even"><td style="text-align:center">2</td><td style="text-align:center">Thread-1 getArray()</td></tr><tr class="odd"><td style="text-align:center">3</td><td style="text-align:center">Thread-1 setArray(arrayCopy)</td></tr><tr class="even"><td style="text-align:center">4</td><td style="text-align:center">Thread-0 array[index]</td></tr></tbody></table><blockquote><p>不容易测试，但问题确实存在</p></blockquote><h3 id="迭代器弱一致性">迭代器弱一致性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">CopyOnWriteArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Iterator&lt;Integer&gt; iter = list.iterator();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    list.remove(<span class="hljs-number">0</span>);<br>    System.out.println(list);<br>&#125;).start();<br>sleep1s();<br><span class="hljs-comment">//此时主线程的iterator依旧指向旧的数组。</span><br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>    System.out.println(iter.next());<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不要觉得弱一致性就不好</p><ul><li>数据库的 MVCC 都是弱一致性的表现</li><li>并发高和一致性是矛盾的，需要权衡</li></ul></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Unicorn-acc.github.io">Miraclo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://unicorn-acc.github.io/posts/31546.html">http://unicorn-acc.github.io/posts/31546.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Unicorn-acc.github.io" target="_blank">Miraclo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/1p/wallhaven-1pjml1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/31541.html"><img class="next-cover" src="https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC-04--共享模型之无锁、不可变【CAS、原子并发典型实现、ABA问题、日期转换问题、不可变设计】</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/59995.html" title="JUC-01--进程与线程、Java线程【线程创建、API、状态】"><img class="cover" src="https://w.wallhaven.cc/full/d6/wallhaven-d65mzm.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-30</div><div class="title">JUC-01--进程与线程、Java线程【线程创建、API、状态】</div></div></a></div><div><a href="/posts/31540.html" title="JUC-03--共享模型之内存【java内存模型、可见性、有序性】"><img class="cover" src="https://w.wallhaven.cc/full/1p/wallhaven-1pjml1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-13</div><div class="title">JUC-03--共享模型之内存【java内存模型、可见性、有序性】</div></div></a></div><div><a href="/posts/31541.html" title="JUC-04--共享模型之无锁、不可变【CAS、原子并发典型实现、ABA问题、日期转换问题、不可变设计】"><img class="cover" src="https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-13</div><div class="title">JUC-04--共享模型之无锁、不可变【CAS、原子并发典型实现、ABA问题、日期转换问题、不可变设计】</div></div></a></div><div><a href="/posts/47599.html" title="JUC-02--共享模型之管程【synchronized、变量线程安全分析、Monitior概念、wait和notify、park和unpark、✨Java状态转换、ReentrantLock】"><img class="cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p9273e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">JUC-02--共享模型之管程【synchronized、变量线程安全分析、Monitior概念、wait和notify、park和unpark、✨Java状态转换、ReentrantLock】</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7"><span class="toc-text">8.共享模型之工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">8.1 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">8.1.1 自定义线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpoolexecutor"><span class="toc-text">8.1.2 ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-text">1）线程池状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">2）构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newfixedthreadpool%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">3）newFixedThreadPool固定大小线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newcachedthreadpool%E5%B8%A6%E7%BC%93%E5%86%B2%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">4）newCachedThreadPool带缓冲线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newsinglethreadexecutor%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">5）newSingleThreadExecutor单线程线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-text">6）提交任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">7）关闭线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8Fworker-thread"><span class="toc-text">8）*模式之工作模式Worker Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">9）任务调度线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8"><span class="toc-text">10）正确处理执行任务异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-text">11）* 应用之定时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tomcat-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">12）Tomcat 线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoin-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">8.1.3 Fork&#x2F;Join 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E6%B1%82%E5%92%8C"><span class="toc-text">应用之求和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#j.u.c%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">8.2 J.U.C并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E9%98%BB%E5%A1%9E%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-text">8.2.1 *AQS 阻塞式锁原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">1）实现不可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E5%BE%97"><span class="toc-text">2）心得</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reentrantlock-%E5%8E%9F%E7%90%86"><span class="toc-text">8.2.2 ReentrantLock 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">1）非公平锁实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E4%B8%8E%E8%A7%A3%E9%94%81%E6%BA%90%E7%A0%81"><span class="toc-text">加锁与解锁源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-text">2）可重入锁原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-text">3）可打断锁原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E6%89%93%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="toc-text">不可打断模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="toc-text">可打断模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4）公平锁实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">5）条件变量实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#await-%E6%B5%81%E7%A8%8B"><span class="toc-text">await 流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#signal-%E6%B5%81%E7%A8%8B"><span class="toc-text">signal 流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">8.3 读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reentrantreadwritelock"><span class="toc-text">8.3.1 ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E7%BC%93%E5%AD%98"><span class="toc-text">8.3.2 * 应用之缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-text">缓存更新策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98"><span class="toc-text">读写锁实现一致性缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-text">8.3.3 * 读写锁原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B"><span class="toc-text">图解流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stampedlock-%E5%B8%A6%E6%88%B3%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">8.3.4 StampedLock 带戳读写锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">8.4 Semaphore信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#semaphore-%E5%BA%94%E7%94%A8"><span class="toc-text">8.4.1 * Semaphore 应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#semaphore-%E5%8E%9F%E7%90%86"><span class="toc-text">8.4.2 * Semaphore 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-text">加锁解锁流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-text">加锁流程总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-text">解锁流程总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#countdownlatch%E5%80%92%E8%AE%A1%E6%97%B6%E9%94%81"><span class="toc-text">8.5 CountdownLatch倒计时锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E5%90%8C%E6%AD%A5%E7%AD%89%E5%BE%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%87%86%E5%A4%87%E5%AE%8C%E6%AF%95"><span class="toc-text">* 应用之同步等待多线程准备完毕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E5%90%8C%E6%AD%A5%E7%AD%89%E5%BE%85%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%93%E6%9D%9F"><span class="toc-text">* 应用之同步等待多个远程调用结束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cyclicbarrier%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F"><span class="toc-text">8.6 CyclicBarrier循环栅栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-text">8.7 线程安全集合类概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrenthashmap"><span class="toc-text">8.7.1 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E5%8D%95%E8%AF%8D%E8%AE%A1%E6%95%B0"><span class="toc-text">应用之单词计数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrenthashmap-%E5%8E%9F%E7%90%86"><span class="toc-text">8.7.2 * ConcurrentHashMap 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-7-hashmap-%E5%B9%B6%E5%8F%91%E6%AD%BB%E9%93%BE%E9%97%AE%E9%A2%98"><span class="toc-text">1）JDK 7 HashMap 并发死链问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%93%BE%E5%A4%8D%E7%8E%B0"><span class="toc-text">死链复现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-8-concurrenthashmap"><span class="toc-text">2）JDK 8 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">重要属性和内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">重要方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">构造器源码分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get%E6%B5%81%E7%A8%8B"><span class="toc-text">get流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#put-%E6%B5%81%E7%A8%8B"><span class="toc-text">put 流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#size-%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B"><span class="toc-text">size 计算流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-7-concurrenthashmap"><span class="toc-text">3）JDK 7 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%86%E6%9E%90"><span class="toc-text">构造器分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#put-%E6%B5%81%E7%A8%8B-1"><span class="toc-text">put 流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rehash-%E6%B5%81%E7%A8%8B"><span class="toc-text">rehash 流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get-%E6%B5%81%E7%A8%8B"><span class="toc-text">get 流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#size-%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B-1"><span class="toc-text">size 计算流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blockingqueue"><span class="toc-text">8.8 BlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedblockingqueue-%E5%8E%9F%E7%90%86"><span class="toc-text">8.8.1 * LinkedBlockingQueue 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F"><span class="toc-text">基本的入队出队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-text">加锁分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-text">性能比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentlinkedqueue"><span class="toc-text">8.9 ConcurrentLinkedQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrentlinkedqueue-%E5%8E%9F%E7%90%86"><span class="toc-text">*ConcurrentLinkedQueue 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E4%BB%BF-concurrentlinkedqueue"><span class="toc-text">模仿 ConcurrentLinkedQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearraylist"><span class="toc-text">8.10 CopyOnWriteArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get-%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">get 弱一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">迭代器弱一致性</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Miraclo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人只有在走上坡路的时候才会累和迷茫。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.1},options:{renderActions:{findScript:[10,t=>{for(const n of document.querySelectorAll('script[type^="math/tex"]')){var e=!!n.type.match(/; *mode=display/),e=new t.options.MathItem(n.textContent,t.inputJax[0],e),a=document.createTextNode("");n.parentNode.replaceChild(a,n),e.start={node:a,delim:"",n:0},e.end={node:a,delim:"",n:0},t.math.push(e)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t.hasAttribute("display")?btf.wrap(t,"div",{class:"mathjax-overflow"}):btf.wrap(t,"span",{class:"mathjax-overflow"})})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script></div><link rel="stylesheet" href="/css/Lete.css"><script src="/js/custom.js"></script><script src="/js/mouth.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1s"),arr[i].setAttribute("data-wow-delay","1ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>