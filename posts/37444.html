<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>JVM系列-26-3、性能监控与调优篇---JVM常用参数设置与GC日志分析 | Miraclo</title><meta name="author" content="Miraclo"><meta name="copyright" content="Miraclo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM运行时参数 JVM 参数选项类型 类型一：标准参数选项 特点 比较稳定，后续版本基本不会变化，以-开头。 各种选项 运行 Java 或者 java -help 可以看到所有的标准选项。 补充内容：-server 与 -client HotSpot JVM 有两种模式，分别是 server 和 client，分别通过 -server 和 -client 模式设置：  在 32 位 Window"><meta property="og:type" content="article"><meta property="og:title" content="JVM系列-26-3、性能监控与调优篇---JVM常用参数设置与GC日志分析"><meta property="og:url" content="http://unicorn-acc.github.io/posts/37444.html"><meta property="og:site_name" content="Miraclo"><meta property="og:description" content="JVM运行时参数 JVM 参数选项类型 类型一：标准参数选项 特点 比较稳定，后续版本基本不会变化，以-开头。 各种选项 运行 Java 或者 java -help 可以看到所有的标准选项。 补充内容：-server 与 -client HotSpot JVM 有两种模式，分别是 server 和 client，分别通过 -server 和 -client 模式设置：  在 32 位 Window"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w.wallhaven.cc/full/d6/wallhaven-d65mzm.jpg"><meta property="article:published_time" content="2022-11-30T10:08:02.000Z"><meta property="article:modified_time" content="2023-03-24T08:00:20.849Z"><meta property="article:author" content="Miraclo"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/d6/wallhaven-d65mzm.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://unicorn-acc.github.io/posts/37444"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:2e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:800,languages:{author:"作者: Miraclo",link:"链接: ",source:"来源: Miraclo",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JVM系列-26-3、性能监控与调优篇---JVM常用参数设置与GC日志分析",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-03-24 08:00:20"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mouth.css"><link rel="stylesheet" href="/css/codecolor.css"><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">147</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://w.wallhaven.cc/full/d6/wallhaven-d65mzm.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Miraclo</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM系列-26-3、性能监控与调优篇---JVM常用参数设置与GC日志分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-11-30T10:08:02.000Z" title="发表于 2022-11-30 10:08:02">2022-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/">Java技术栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JVM%E7%B3%BB%E5%88%97/">JVM系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="JVM系列-26-3、性能监控与调优篇---JVM常用参数设置与GC日志分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="jvm运行时参数">JVM运行时参数</h1><h2 id="jvm-参数选项类型">JVM 参数选项类型</h2><h3 id="类型一标准参数选项">类型一：标准参数选项</h3><p><strong>特点</strong></p><p>比较稳定，后续版本基本不会变化，以<code>-</code>开头。</p><p><strong>各种选项</strong></p><p>运行 Java 或者 <code>java -help</code> 可以看到所有的标准选项。</p><p><strong>补充内容：-server 与 -client</strong></p><p>HotSpot JVM 有两种模式，分别是 server 和 client，分别通过 -server 和 -client 模式设置：</p><ol type="1"><li>在 32 位 Windows 系统上，默认使用 Client 类型的 JVM。要想使用 Server 模式，则机器配置至少有 2 个以上的 CPU 和 2G 以上的物理内存。Client 模式适用于对内存要求较小的桌面应用程序，默认使用 Serial 串行垃圾收集器。</li><li>64 位机器上只支持 Server 模式的 JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器。</li></ol><p>关于 Server 和 Client 的官网介绍为：https://docs.oracle.com/javase/8/docs/techontes/guides/vm/server-class.html</p><h3 id="类型二-x-参数选项">类型二：-X 参数选项</h3><p><strong>特点</strong></p><p>非标准化参数，功能比较稳定，以 <code>-X</code> 开头。</p><p><strong>各种选项</strong></p><p>运行 <code>java -X</code> 命令可以看到所有的 X 选项。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sh">-Xmixed								混合模式执行（默认）<br>-Xint								仅解释模式执行<br>-Xcomp								仅采用即时编译器模式<br>-Xbootclasspath:&lt;用;分隔的目录和 zip/jar 文件&gt;	设置搜索路径以引导类和资源<br>-Xbootclasspath/a:&lt;用;分隔的目录和 zip/jar 文件&gt;	附加在引导类路径末尾<br>-Xbootclasspath/p:&lt;用;分隔的目录和 zip/jar 文件&gt;	置于引导类路径之前<br>-Xdiag								显示附加诊断消息<br>-Xnoclassgc							禁用类垃圾收集<br>-Xincgc								启用增量垃圾收集<br>-Xloggc:&lt;file&gt;						将 GC 状态记录在文件中（带时间戳）<br>-Xbatch								禁用后台编译<br>-Xms&lt;size&gt;							设置初始 Java 堆大小<br>-Xmx&lt;size&gt;							设置最大 Java 堆大小<br>-Xss&lt;size&gt;							设置 Java 线程堆栈大小<br>-Xprof								输出 CPU 配置文件数据<br>-Xfuture							启用最严格的检查，预期将来的默认值<br>-Xrs								减少 Java/VM 对操作系统信号的使用<br>-Xcheck:jni							对 JNI 函数执行其他检查<br>-Xshare:off							不尝试使用共享类数据<br>-Xshare:auto						在可能的情况下使用共享类数据（默认）<br>-Xshare:on							要求使用共享类数据，否则将失败<br>-XshowSettings						显示所有设置并继续<br>-XshowSettings:all					显示所有设置并继续<br>-XshowSettings:vm					显示所有与 VM 相关的设置并继续<br>-XshowSettings:properties			显示所有属性设置并继续<br>-XshowSettings:locale				显示所有与区域设置相关的设置并继续<br></code></pre></td></tr></table></figure><p><strong>JVM 的 JIT 编译模式相关的选项</strong></p><ul><li><code>-Xint</code>：禁用 JIT，所有字节码都被解释执行，这个模式的速度是最慢的。</li><li><code>-Xcomp</code>：所有字节码第一次使用就都被编译成本地代码，然后再执行。</li><li><code>-Xmixed</code>：混合模式，默认模式，让 JIT 根据程序运行的情况，有选择地将某些代码编译成本地代码</li></ul><p><strong>特别地</strong></p><p>-Xmx -Xms -Xss 属于 XX 参数？</p><ul><li><code>-Xms&lt;size&gt;</code>：设置初始 Java 堆大小，等价于 <code>-XX:InitialHeapSize</code>。</li><li><code>-Xmx&lt;size&gt;</code>：设置最大 Java 堆大小，等价于 <code>-XX:MaxHeapSize</code>。</li><li><code>-Xss&lt;size&gt;</code>：设置 Java 线程堆栈大小，<code>-XX:ThreadStackSize</code>。</li></ul><p>✨✨</p><h3 id="类型三-xx-参数选项">类型三：-XX 参数选项</h3><p><strong>特点</strong></p><ul><li>非标准化参数</li><li>使用的最多的参数类型</li><li>实验性选项</li><li>以 <code>-XX</code> 开头</li></ul><p><strong>作用</strong></p><p>用于开发和调试 JVM。</p><p><strong>分类</strong></p><ul><li><p>Boolean 类型格式</p><ul><li><p><code>-XX:+&lt;option&gt;</code> 表示启用 option 属性。</p></li><li><p><code>-XX:- &lt;option&gt;</code> 表示禁用 option 属性。</p></li><li><p>说明：因为有的指令默认是开启的，所以可以使用 <code>-</code> 关闭。</p><blockquote><p><code>-XX:+UseParallelGC</code> 选择垃圾收集器为并行收集器</p><p><code>-XX:+UseG1GC</code> 表示启用 G1 收集器</p><p><code>-XX:+UseAdaptiveSizePolicy</code> 自动选择年轻代区大小和相应的 Survivor 区比例</p></blockquote></li></ul></li><li><p>非 Boolean 类型模式（key-value 类型）</p><ul><li><p>子类型 1：数值型格式 <code>-XX:&lt;option&gt;=&lt;number&gt;</code>。</p><blockquote><p>number 表示数值，number 可以带上单位，比如：'m'、'M' 表示兆，'k'、'K' 表示 Kb，'g'、'G' 表示 g</p><p>例如：</p><p><code>-XX:NewSize=1024m</code>：表示设置新生代初始大小为 1024M。</p><p><code>-XX:MaxGCPauseMillis=500</code>：表示设置 GC 停顿时间：500 毫秒。</p><p><code>-XX:GCTimeRatio=19</code>：表示设置吞吐量。</p><p><code>-XX:NewRatio=2</code>：表示新生代与老年代的比例。</p></blockquote></li><li><p>子类型 2：非数值型格式 <code>-XX:&lt;name&gt;=&lt;string&gt;</code>。</p><blockquote><p><code>-XX:HeapDumpPath=/usr/local/heapdump.hprof</code>：用来指定 Heap 转存文件的存储路径。</p></blockquote></li></ul></li></ul><p><strong>特别地</strong></p><ul><li><code>-XX:+PrintFlagsFinal</code><ul><li>输出所有参数的名称和默认值。</li><li>默认不包括 Diagnostic 和 Experimental 的参数。</li><li>可以配合 <code>-XX:+UnlockDiagnosticVMOptions</code> 和 <code>-XX:UnlockExperimentalVMOptions</code> 使用。</li></ul></li></ul><h2 id="添加-jvm-参数选项">添加 JVM 参数选项</h2><h3 id="eclipse">Eclipse</h3><h3 id="idea">IDEA</h3><h3 id="运行-jar-包">运行 jar 包</h3><p><code>java -Xms50m -Xmx50m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -jar demo.jar</code></p><h3 id="通过-tomcat-运行-war-包">通过 Tomcat 运行 war 包</h3><ul><li>Linux 系统下可以在 tomcat/bin/catalina.sh 中添加类似如下配置： JAVA_OPTS="-Xms512M -Xmx1024M"。</li><li>Windows 系统下在 catalina.bat 中添加类似如下配置： set "JAVA_OPTS=Xms512M -Xmx1024M"。</li></ul><h3 id="程序运行过程中">程序运行过程中</h3><ul><li>使用 jinfo -flag<name>=<value><pid>设置非 Boolean 类型参数。</pid></value></name></li><li>使用 jinfo -flag [+ | -]<name><pid>设置 Boolean 类型参数。</pid></name></li></ul><h2 id="常用的-jvm-参数选项">✨✨✨常用的 JVM 参数选项</h2><h3 id="打印设置的-xx-选项及值">打印设置的 XX 选项及值</h3><ul><li><code>-XX:+PrintCommandLineFlags</code>：可以让在程序运行前打印出用户手动设置或者 JVM 自动设置的 XX 选项。</li><li><code>-XX:+PrintFlagsInitial</code>：表示打印所有 XX 选项的默认值。</li><li><code>-XX:+PrintFlagsFinal</code>：表示打印出 XX 选项在运行程序时生效的值。</li><li><code>-XX:+PrintVMOptions</code>：打印 JVM 的参数。</li></ul><h3 id="堆栈方法区等内存大小设置">堆、栈、方法区等内存大小设置</h3><p>栈：</p><ul><li><code>-Xss128k</code><ul><li>设置每个线程的栈大小为 128k。</li><li>等价于 <code>-XX:ThreadStackSize=128k</code>。</li></ul></li></ul><p>堆内存：</p><ul><li><code>-Xms3550m</code>：等价于 <code>-XX:InitialHeapSize</code>，设置 JVM 初始堆内存为 3550M。</li><li><code>-Xmx3550m</code>：等价于 <code>-XX:MaxHeapSize</code>，设置 JVM 最大堆内存为 3550M。</li><li><code>-Xmn2g</code><ul><li>设置年轻代大小为 2G。</li><li>官方推荐配置为整个堆大小的 3/8。</li></ul></li><li><code>-XX:NewSize=1024m</code>：设置年轻代初始值为 1024M。</li><li><code>-XX:MaxNewSize=1024m</code>：设置年轻代最大值为 1024M。</li><li><code>-XX:SurvivorRatio=8</code>：设置年轻代中 Eden 区与一个 Survivor 区的比值，默认为 8。</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：自动选择各区大小比例。</li><li><code>-XX:NewRatio=4</code>：设置老年代与年轻代（包括 1 个 Eden 和 2 个 Survivor 区）的比值。</li><li><code>-XX:PretenureSizeThreadshold=1024</code><ul><li>设置让大于此阈值的对象直接分配在老年代，单位为字节。</li><li>只对 Serial、ParNew 收集器有效。</li></ul></li><li><code>-XX:MaxTenuringThreshold=15</code><ul><li>默认值为 15。</li><li>新生代每次 MinorGC 后，还存活的对象年龄 +1，当对象的年龄大于设置的这个值时就进入老年代。</li></ul></li><li><code>-XX:+PrintTenuringDistribution</code>：让 JVM 在每次 MinorGC 后打印出当前使用的 Survivor 中对象的年龄分布。</li><li><code>-XX:TargetSurvivoRatio</code>：表示 MinorGC 结束后 Survivor 区域中占用空间的期望比例。</li></ul><p>方法区：</p><ul><li>永久代：<ul><li><code>-XX:PermSize=256m</code>：设置永久代初始值为 256M。</li><li><code>-XX:MaxPermSize=256m</code>：设置永久代最大值为 256M。</li></ul></li><li>元空间：<ul><li><code>-XX:MetaspaceSize</code>：初始空间大小。</li><li><code>-XX:MaxMetaspaceSize</code>：最大空间，默认没有限制。</li><li><code>-XX:+UseCompressedOops</code>：压缩对象指针。</li><li><code>-XX:CompressedClassSpaceSize</code>：设置 Class Metaspace 的大小，默认 1G。</li></ul></li></ul><p>直接内存：</p><ul><li><code>-XX:MaxDirectMemorySize</code>：指定 DirectMemory 容量，若未指定，则默认与 Java 堆最大值一样。</li></ul><h3 id="outofmemory-相关的选项">OutOfMemory 相关的选项</h3><ul><li><p><code>-XX:+HeapDumpOnOutOfMemoryError</code>：表示在内存出现 OOM 的时候，把 Heap 转存（Dump）到文件以便后续分析。</p></li><li><p><code>-XX:+HeapDumpBeforeFullGC</code>：表示在出现 FullGC 之前，生成 Heap 转储文件。</p></li><li><p><code>-XX:HeapDumpPath=&lt;path&gt;</code>：指定 Heap 转存文件的存储路径。</p></li><li><p><code>-XX:OnOutOfMemoryError</code>：指定一个可行性程序或者脚本的路径，当发生 OOM 的时候，去执行这个脚本。</p><blockquote><p>对 OnOutOfMemoryError 的运维处理</p><p>以部署在 Linux 系统 /opt/Server 目录下的 Server.jar 为例</p><ol type="1"><li>在 run.sh 启动脚本添加 JVM 参数：<code>-XX:OnOutOfMemoryError=/opt/Server/restart.sh</code></li><li>restart.sh 脚本</li></ol><p>Linux 环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>pid=$&#123;ps -ef | grep Server.jar | awk &#x27;&#123;if($8==&quot;java&quot;) &#123;print $2&#125;&#125;&#x27;&#125;<br>kill -9 pid<br>cd /opt/Server/;sh run.sh<br></code></pre></td></tr></table></figure><p>Windows 环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo off<br>wmic process where Name=&#x27;java.exe&#x27; delete<br>cd D:\Server<br>start run.bat<br></code></pre></td></tr></table></figure></blockquote></li></ul><h3 id="垃圾收集器相关选项">✨✨✨垃圾收集器相关选项</h3><p>7 款经典垃圾收集器与垃圾分代之间的关系：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs01/202211301003232.png"></p><p>垃圾收集器的组合关系：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs01/202211301004791.png"></p><ul><li><p>查看默认垃圾收集器</p><ul><li><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）。</li><li>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 PID</code>。</li></ul></li><li><p>Serial 回收器</p><blockquote><p>Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾回收器。Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器。</p><p><code>-XX:+UseSerialGC</code>：指定年轻代和老年代都使用串行回收器。等价于新生代用 Serial GC，且老年代用 Serial Old GC。可以获得最高的单线程收集效率。</p></blockquote></li><li><p>ParNew 回收器</p><blockquote><p><code>-XX:+UseParNewGC</code>：手动指定使用 ParNew 回收器执行内存回收任务。它表示年轻代使用并行回收器，不影响老年代。</p><p><code>-XX:ParallelGCThreads=N</code>：限制线程数量，默认开启和 CPU 数据相同的线程数。</p></blockquote></li><li><p>Parallel 回收器</p><blockquote><ul><li><p><code>-XX:+UseParallelGC</code>：手动指定年轻代使用 Parallel 并行回收器执行内存回收任务。</p></li><li><p><code>-XX:+UseParallelOldGC</code>：手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认 JDK 8 是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（相互激活）</li></ul></li><li><p><code>-XX:ParallelGCThread</code>：设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p><ul><li>在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 的数量。</li><li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU_Count]/8。</li></ul></li><li><p><code>-XX:MaxGCPauseMillis</code>：设置垃圾回收器最大停顿时间（即 STW 的时间）。单位是毫秒。</p><ul><li>为了尽可能地把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。</li><li>该参数使用需谨慎。</li></ul></li><li><p><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例 （=1/(N+1)）。用于衡量吞吐量的大小。</p><ul><li>取值范围 (0,100)。默认值 99，也就是垃圾回收时间不超过 1%。</li><li>与前一个 <code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性，暂停时间越长，Ratio 参数就容易超过设定的比例。</li></ul></li><li><p><code>-XX:+UseAdaptiveSizePolicy</code>：设置 Parallel Scavenge 收集器具有自适应调节策略。</p><ul><li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</li></ul></li></ul></blockquote></li><li><p>CMS 回收器</p><blockquote><ul><li><code>-XX:+UseConcMarkSweepGC</code>：手动指定使用 CMS 收集器执行内存回收任务。<ul><li>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开。即：ParNew（Young 区用）+CMS（Old 区用）+Serial Old 的组合。</li></ul></li><li><code>-XX:CMSInitiatingOccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。<ul><li>JDK 5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次 CMS 回收。JDK 6 及以上版本默认值为 92%。</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Full GC 的执行次数。</li></ul></li><li><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li><li><code>-XX:CMSFullGCsBeforeCompaction</code>：设置在执行多少次 Full GC 后对内存空间进行压缩整理。</li><li><code>-XX:ParallelCMSThreads</code>：设置 CMS 的线程数量。<ul><li>CMS 默认启动的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads 是年轻代并行收集器的线程数，当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><p>另外，CMS 收集器还有如下常用参数：</p><ul><li><code>-XX:ConcGCThreads</code>：设置并发垃圾收集的线程数，默认该值是基于 ParallelGCThreads 计算出来的。</li><li><code>-XX:+UseCMSInitiatingOccupancyOnly</code>：是否动态可调，用这个参数可以使 CMS 一直按 CMSInitiatingOccupancyFraction 设定的值启动。</li><li><code>-XX:+CMSScavengeBeforeRemark</code>：强制 HotSpot 虚拟机在 CMS Remark 阶段之前做一次 Minor GC，用于提高 Remark 阶段的速度。</li><li><code>-XX:+CMSClassUnloadingEnable</code>：如果有的话，启用回收 Perm 区（JDK 8 之前）。</li><li><code>-XX:+CMSParallelInitialEnabled</code>：用于开启 CMS Initial-Mark 阶段采用多线程的方式进行标记，用于提高标记速度，在 Java 8 开始已经默认开启。</li><li><code>-XX:+CMSParallelRemarkEnables</code>：用户开启 CMS Remark 阶段采用多线程的方式进行重新标记，默认开启。</li><li><code>-XX:+ExplicitGCInvokesConcurrent</code>、<code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code>：这两个参数用户指定 HotSpot 虚拟机在执行 System.gc() 时使用 CMS 周期。</li><li><code>-XX:+CMSPrecleaningEnabled</code>：指定 CMS 是否需要进行 Pre Cleaning 这个阶段。</li></ul><p>特别说明：</p><ul><li>JDK 9 新特性：CMS 被标记为 Deprecate（JEP291）<ul><li>如果对 JDK 9 及以上版本的 HotSpot 虚拟机使用参数 <code>-XX:+UseConcMarkSweepGC</code> 来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li></ul></li><li>JDK 14 新特性：删除 CMS 垃圾回收器（JEP363）<ul><li>移除了 CMS 垃圾回收器，如果在 JDK 14 中使用 <code>-XX:+UseConcMarkSweepGC</code> 的话，JVM 不会报错，只是给出一个 Warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM。</li></ul></li></ul></blockquote></li><li><p>G1 回收器</p><blockquote><ul><li><code>-XX:+UseG1GC</code>：手动指定使用 G1 收集器执行内存回收任务。</li><li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1/2000。</li><li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms。</li><li><code>-XX:ParallelGCThread</code>：设置 STW 时 GC 线程数的值，最多设置为 8。</li><li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li><li><code>-XX:G1NewSizePercent、-XX:G1MaxNewSizePercent</code>：新生代占用整个堆内存的最小百分比（默认 5%）、最大百分比（默认 60%）。</li><li><code>-XX:G1ReservePercent=10</code>：保留内存区域，防止 To Space（Survivor 中的 To 区）溢出。</li></ul><p>注意：G1 收集器主要涉及到 Mixed GC，Mixed GC 会回收 Young 区和部分 Old 区。</p><p>G1 关于 Mixed GC 调优常用参数：</p><ul><li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置堆占用率的百分比（0 到 100）达到这个数值的时候触发 Global Concurrent Marking（全局并发标记），默认为 45%。值为 0 表示间断进行全局并发标记。</li><li><code>-XX:G1MixedGCLiveThreadholdPercent</code>：设置 Old 区的 Region 被回收时候的对象占比，默认占用率 85%。只有 Old 区的 Region 中存活的对象占用达到了这个百分比，才会在 Mixed GC 中被回收。</li><li><code>-XX:G1HeapWastePercent</code>：在 Global Concurrent Marking（全局并发标记）结束之后，可以知道所有的区有多少空间要被回收，在每次 Young GC 之后和再次发生 Mixed GC 之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生 Mixed GC。</li><li><code>-XX:G1MixedGCCountTarget</code>：一次 Global Concurrent Marking（全局并发标记）之后，最多执行 Mixed GC 的次数，默认是 8。</li><li><code>-XX:G1OldGCSetRegionThresholdPercent</code>：设置 Mixed GC 收集周期中要收集的 Old Region 数的上限。默认值是 Java 堆的 10%。</li></ul></blockquote></li><li><p>怎么选择垃圾回收器</p><blockquote><ul><li>优先调整堆的大小让 JVM 自适应完成。</li><li>如果内存小于 100M，使用串行收集器。</li><li>如果是单核、单机程序，并且没有停顿时间的要求，使用串行收集器。</li><li>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择。</li><li>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器。官方推荐 G1，性能高。现在互联网的项目，基本都是使用 G1。</li></ul><p>特别说明：</p><ol type="1"><li>没有最好的收集器，更没有万能的收集器；</li><li>调优永远都是针对特定场景、特定需要，不存在一劳永逸的收集器。</li></ol></blockquote></li></ul><h3 id="gc-日志相关选项">GC 日志相关选项</h3><ul><li><code>-verbose:gc</code>：输出 GC 日志信息，默认输出到标准输出。</li><li><code>-XX:+PrintGC</code>：等同于 <code>-verbose:gc</code> 表示打开简化的 GC 日志。</li><li><code>-XX:+PrintGCDetails</code>：在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况。</li><li><code>-XX:+PrintGCTimeStamps</code>：输出 GC 发生时的时间戳。</li><li><code>-XX:+PrintGCDateStamps</code>：输出 GC 发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800。</li><li><code>-XX:+PrintHeapAtGC</code>：每一次 GC 前和 GC 后，都打印堆信息。</li><li><code>-Xloggc:&lt;file&gt;</code>：把 GC 日志写入到一个文件夹中去，而不是打印到标准输出中。</li><li><code>-XX:+TraceClassLoading</code>：监控类的加载。</li><li><code>-XX:+PrintGCApplicationStoppedTime</code>：打印 GC 时线程的停顿时间。</li><li><code>-XX:+PrintReferenceGC</code>：记录回收了多少种不同引用类型的引用。</li><li><code>-XX:+UseGCLogFileRotation</code>：启用 GC 日志文件的自动转储。</li><li><code>-XX:+PrintTenuringDistribution</code>：让 JVM 在每次 Minor GC 后打印出当前使用的 Survivor 中对象的年龄分布。</li><li><code>-XX:NumberOfGClogFiles=1</code>：GC 日志文件的循环数目。</li><li><code>-XX:GCLogFileSize=1M</code>：控制 GC 日志文件的大小。</li></ul><h3 id="其他参数">其他参数</h3><ul><li><code>-XX:+DisableExplicitGC</code>：禁止 HotSpot 执行 System.gc()，默认禁用。</li><li><code>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]</code>：指定代码缓存的大小。</li><li><code>-XX:+UseCodeCacheFlushing</code>：使用该参数让 JVM 放弃一些被编译的代码，避免代码缓存被占满时 JVM 切换到 Interpreted-only 的情况。</li><li><code>-XX:+DoEscapeAnalysis</code>：开启逃逸分析。</li><li><code>-XX:+UseBiasedLocking</code>：开启偏向锁。</li><li><code>-XX:+UseLargePages</code>：开启使用大页面。</li><li><code>-XX:+UseTLAB</code>：使用 TLAB，默认打开。</li><li><code>-XX:+PrintTLAB</code>：打印 TLAB 的使用情况。</li><li><code>-XX:TLABSize</code>：设置 TLAB 大小。</li></ul><h2 id="通过-java-代码获-jvm-参数">通过 Java 代码获 JVM 参数</h2><p>Java 提供了 java.lang.management 包用于监视和管理 Java 虚拟机和 Java 运行时中的其他组件，它允许本地和远程监控和管理运行的 Java 虚拟机。其中 ManagementFactory 这个类还是挺常用的。另外还有 Runtime 类也可以获取一些内存、CPU 核数等相关问题。</p><p>通过这些 API 可以监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryMonitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MemoryMXBean</span> <span class="hljs-variable">memorymbean</span> <span class="hljs-operator">=</span> ManagementFactory.getMemoryMXBean();<br>        <span class="hljs-type">MemoryUsage</span> <span class="hljs-variable">usage</span> <span class="hljs-operator">=</span> memorymbean.getHeapMemoryUsage();<br>        System.out.println(<span class="hljs-string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;\n Full Information: &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());<br>        System.out.println(<span class="hljs-string">&quot;No-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());<br>        System.out.println(<span class="hljs-string">&quot;============通过 Java 来获取相关系统状态============&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;当前堆内存大小 TotalMemory：&quot;</span> + (<span class="hljs-type">int</span>)Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;空闲堆内存大小 FreeMemory：&quot;</span> + (<span class="hljs-type">int</span>)Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最大可用总堆内存 MaxMemory：&quot;</span> + (<span class="hljs-type">int</span>)Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSpaceInitial</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 返回 Java 虚拟机中的堆内存总量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">initialMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-comment">// 返回 Java 虚拟机试图使用的最大堆内存量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <br>        System.out.println(<span class="hljs-string">&quot;-Xmx: &quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-Xms: &quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="hljs-number">4.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="hljs-number">64.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分析gc日志">分析GC日志</h1><h2 id="gc-日志参数">GC 日志参数</h2><ul><li><code>-verbose:gc</code>：输出 GC 日志信息，默认输出到标准输出。</li><li><code>-XX:+PrintGC</code>：输出 GC 日志。类似：<code>-verbose:gc</code>。</li><li><code>-XX:+PrintGCDetails</code>：在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况。</li><li><code>-XX:+PrintGCTimeStamps</code>：输出 GC 发生时的时间戳。</li><li><code>-XX:+PrintGCDateStamps</code>：输出 GC 发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.534+0800）。</li><li><code>-XX:+PrintHeapAtGC</code>：每一次 GC 前和 GC 后，都打印堆信息。</li><li><code>-Xloggc:&lt;file&gt;</code>：表示把 GC 日志写入到一个文件中去，而不是打印到标准输出中。</li></ul><h2 id="gc-日志格式">GC 日志格式</h2><h3 id="gc-分类">GC 分类</h3><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆手机（Full GC）。</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集，其中又分为：<ul><li>新生代收集（Minor GC / Young GC）：只是新生代（Eden / S0 / S1）的垃圾收集。</li><li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。<ul><li>目前，只有 CMS GC 会有单独收集老年代的行为。</li><li>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有 G1 GC 会有这种行为。</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</li></ul><h3 id="gc-日志分类">GC 日志分类</h3><ul><li><p>Minor GC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[GC (Allocation Failure) [PSYoungGen: 31744K -&gt; 2192K(36864K)]<br>31744K -&gt; 2200K(121856K), 0.0139308 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]<br></code></pre></td></tr></table></figure></li><li><p>Full GC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[Full GC (Metadata GC Threshold) [PSYoungGen: 5104K -&gt; 0K(132096K)]<br>[ParOldGen: 416K -&gt; 5453K(50176K)] 5520K -&gt; 5453K(182272K), [MetaSpace:<br>20637K -&gt; 20637K(106700)]， 0.0245883 secs] [Times: user=0.06 sys=0.00,<br>real=0.02 secs]<br></code></pre></td></tr></table></figure></li></ul><h3 id="gc-日志结构剖析">GC 日志结构剖析</h3><ul><li><p>垃圾收集器</p><blockquote><ul><li>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是"[DefNew"。</li><li>使用 ParNew 收集器在新生代的名字会变成"[ParNew"，意思是"Parallel New Generation"。</li><li>使用 Parallel Scavenge 收集器在新生代的名字是"[PSYoungGen"，这里的 JDK 1.7 使用的就是 PSYoungGen。</li><li>使用 Parallel Old Generation 收集器在老年代的名字是"[ParOldGen"。</li><li>使用 G1 收集器的话，会显示为"Garbage-First Heap"。</li></ul><p>Allocation Failure：表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p></blockquote></li><li><p>GC 前后情况</p><blockquote><p>可以发现 GC 日志格式的规律一般都是：GC 前内存占用 -&gt; GC 后内存占用（该区域内存总大小）</p><p>[PSYoungGen: 5986K -&gt; 696K(8704K)] 5986K -&gt; 704K(9216K)</p><p>中括号内：GC 回收前年轻代堆大小，回收后大小。（年轻代堆总大小）</p><p>括号外：GC 回收前年轻代和老年代大小，回收后大小。（年轻代和老年代总大小）</p></blockquote></li><li><p>GC 时间</p><blockquote><p>GC 日志中有三个时间：user、sys 和 real</p><ul><li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的的实际 CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间。</li><li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的的 CPU 时间。</li><li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。对于并行 GC，这个数字应该接近（用户时间+系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核的原因，一般的 GC 事件中，Real Time 是小于 sys + user time 的，因为一般是多个线程并发的去做 GC，所以 Real Time 是要小于 sys + user time 的。如果 real &gt; sys + user 的话，则你的应用可能存在下列问题：IO 负载非常重或者是 CPU 不够用。</p></blockquote></li></ul><h3 id="minor-gc-日志解析">Minor GC 日志解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2020-11-20T17:19:43.265-0800:0.822:[GC (ALLOCATION FAILURE) [PSYOUNGGEN:<br>76800k -&gt; 8433K(89600K)] 76800K -&gt; 8449K(294400K), 0.0088371 SECS [TIMES:<br>USER=0.02 SYS=0.01, REAL=0.01 SECS]]<br></code></pre></td></tr></table></figure><blockquote><ul><li>2020-11-20T17:19:43.265-0800：日志打印时间日期格式。</li><li>0.822:：GC 发生时，Java 虚拟机启动以来经过的秒数。</li><li>GC (ALLOCATION FAILURE)：发生了一次垃圾回收，这是一次 Minor GC。它不区分新生代 GC 还是老年代 GC，括号里的内容是 GC 发生的原因，这里的 Allocation Failure 的原因是新生代中没有足够区域能够存放需要分配的数据而失败。</li><li>[PSYOUNGGEN:76800k -&gt; 8433K(89600K)]：<ul><li>PSYoungGen：表示 GC 发生的区域，区域名称与使用的 GC 收集器是密切相关的。<ul><li>Serial 收集器：Default New Generation 显示 DefNew。</li><li>ParNew 收集器：ParNew。</li><li>Parallel Scanvenge 收集器：PSYoung，老年代和新生代同理，也是和收集器名称相关。</li></ul></li><li><strong>76800k -&gt; 8433K(89600K)：GC 前该内存区域已使用容量 -&gt; GC 后该区域容量（该区域总容量）。</strong><ul><li>如果是新生代，总容量则会显示整个新生代内存的 9/10，即 Eden + From/To 区。</li><li>如果是老年代，总容量则是全部内存大小，无变化。</li></ul></li></ul></li><li><strong>76800K -&gt; 8449K(294400K)：在显示完区域容量 GC 的情况之后，会接着显示整个堆内存区域的 GC 情况：GC 前堆内存已使用容量 -&gt; GC 堆内存容量（堆内存总容量）</strong>堆内存总容量 = 9/10 新生代 + 老年代 &lt; 初始化的内存大小。</li><li>0.0088371 SECS：整个 GC 所花费的时间，单位是秒。</li><li>[TIMES:USER=0.02 SYS=0.01, REAL=0.01 SECS]：<ul><li>user：指的是 CPU 工作在用户态所花费的时间。</li><li>sys：指的是 CPU 工作在内核态所花费的时间。</li><li>real：指的是在此次 GC 事件中所花费的总时间。</li></ul></li></ul></blockquote><h3 id="full-gc-日志解析">Full GC 日志解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2020-11-20T17:19:43.794-0800: 1.351: [FULL GC (METADATA GC THRESHOLD)<br>[PSYOUNGGEN:10082K -&gt; 0K(89600K)] [PAROLDGEN: 32K -&gt; 9638K(204800K)]<br>10114K -&gt; 9638K(294400K),<br>[METASPACE: 20158K -&gt; 20156K(1067008K)], 0.0285388 SECS] [TIMES: USER=0.11 SYS=0.0, REAL=0.03 SECS]<br></code></pre></td></tr></table></figure><blockquote><ul><li>2020-11-20T17:19:43.794-0800：日志打印时间日期格式。</li><li>1.351：GC 发生时，Java 虚拟机启动以来经过的秒数。</li><li>FULL GC (METADATA GC THRESHOLD)：发生了一次垃圾回收，这是一次 FULL GC。它不区分新生代 GC 还是老年代 GC。括号里的内容是 GC 发生的原因，这里的 Metadata GC Threshold 的原因是 Metaspace 区不够用了。<ul><li>Full GC（Ergonomics）：JVM 自适应调整导致的 GC。</li><li>Full GC（System）：调整了 System.gc() 方法。</li></ul></li><li>[PSYOUNGGEN:10082K -&gt; 0K(89600K)]：<ul><li>PSYoungGen：表示 GC 发生的区域，区域名称与使用的 GC 收集器是密切相关的。<ul><li>Serial 收集器：Default New Generation 显示 DefNew。</li><li>ParNew 收集器：ParNew。</li><li>Parallel Scanvenge 收集器：PSYoung，老年代和新生代同理，也是和收集器名称相关。</li></ul></li><li>10082K -&gt; 0K(89600K)：GC 前该内存区域已使用容量 -&gt; GC 后该区域容量（该区域总容量）。<ul><li>如果是新生代，总容量则会显示整个新生代内存的 9/10，即 Eden + From/To 区。</li><li>如果是老年代，总容量则是全部内存大小，无变化。</li></ul></li></ul></li><li><strong>[PAROLDGEN: 32K -&gt; 9638K(204800K)]：老年代区域没有发生 GC，因为本次 GC 是 Metaspace 引起的。</strong></li><li><strong>10114K -&gt; 9638K(294400K)：在显示完区域容量 GC 的情况之后，会接着显示整个堆内存区域的 GC 情况：GC 前堆内存已使用容量 -&gt; GC 堆内存容量（堆内存总容量）</strong>堆内存总容量 = 9/10 新生代 + 老年代 &lt; 初始化的内存大小。</li><li>[METASPACE: 20158K -&gt; 20156K(1067008K)]：Metaspace GC 回收 2K 空间。</li><li>0.0285388 SECS：整个 GC 所花费的时间，单位是秒。</li><li>[TIMES:USER=0.11 SYS=0.00, REAL=0.03 SECS]：<ul><li>user：指的是 CPU 工作在用户态所花费的时间。</li><li>sys：指的是 CPU 工作在内核态所花费的时间。</li><li>real：指的是在此次 GC 事件中所花费的总时间。</li></ul></li></ul></blockquote><h2 id="gc-日志分析工具">GC 日志分析工具</h2><p>上节介绍了 GC 日志的打印及含义，但是 GC 日志看起来比较麻烦，本节将会介绍一下 GC 日志可视化分析工具 GCeasy 和 GCViewer 等。通过 GC 日志可视化分析工具，我们可以很方便的看到 JVM 各个分代的内存使用情况、垃圾回收次数、垃圾回收的原因、垃圾回收占用的时间、吞吐量等，这些指标在我们进行 JVM 调优的时候是很有用的。</p><p>如果想把 GC 日志存到文件的话，是下面这个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-Xloggc:/path/to/gc.log<br></code></pre></td></tr></table></figure><p>然后就可以用一些工具去分析这些 GC 日志。</p><h3 id="gceasy">GCeasy</h3><ul><li><p>基本概念：</p><p>官网地址：https://gceasy.io/，GCeasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄漏检测、GC 暂停原因分析、JVM 配置建议优化等功能，而且是可以免费使用的（有一些服务是收费的）。</p></li></ul><h3 id="gcviewer">GCViewer</h3><ul><li><p>基本概念</p><p>上面介绍了一款在线的 GC 日志分析器，下面介绍一个离线版的 GCViewer。GCViewer 是一个免费的、开源的分析小工具，用于可视化查看由 SUN/Oracle、IBM、HP 和 BEA Java 虚拟机产生的垃圾收集器的日志。GCViewer 用于可视化 Java VM 选项 <code>-verbose:gc</code> 和 .NET 生成的数据 <code>-Xloggc:&lt;file&gt;</code>。它还计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p></li><li><p>安装</p><ul><li><p>下载 GCViewer 工具</p><blockquote><p>源码下载：https://github.com/chewiebug/GCViewer</p><p>运行版本下载：https://github.com/chewiebug/GCViewer/wiki/Changelog</p></blockquote></li><li><p>只需双击 gcviewer-1.3x.jar 或运行 java -jar gcviewer-1.3x.jar（它需要运行 Java 1.8 VM），即可启动 GCViewer（GUI）。</p></li></ul></li></ul><p><strong>其他工具</strong></p><ul><li><p>GChisto</p><p>GChisto 是一款专业分析 GC 日志的工具，可以通过 GC 日志来分析：Minor GC、Full GC 的次数、频率、持续时间等，通过列表、报表、图表等不同形式来反应 GC 的情况。</p></li><li><p>HPjmeter</p><p>工具很强大，但只能打开由一下参数生成的 GC log，<code>-verbose:gc、-Xloggc:gc.log</code>。添加其他参数生成的 gc.log 无法打开。HPjmeter 集成了以前的 HPjtune 功能，可以分析在 HP 机器上产生的垃圾回收日志文件。</p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Unicorn-acc.github.io">Miraclo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://unicorn-acc.github.io/posts/37444.html">http://unicorn-acc.github.io/posts/37444.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Unicorn-acc.github.io" target="_blank">Miraclo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/d6/wallhaven-d65mzm.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/22760.html"><img class="prev-cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p9273e.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM系列-01-1、内存与垃圾回收篇---JVM与Java体系结构</div></div></a></div><div class="next-post pull-right"><a href="/posts/30841.html"><img class="next-cover" src="https://w.wallhaven.cc/full/x6/wallhaven-x619o3.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM系列-22-3、性能监控与调优篇---性能调优概述、部分命令行与GUI监控与诊断工具、再谈内存泄漏</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/40761.html" title="JVM系列-03-1、内存与垃圾回收篇---运行时数据区概述及线程"><img class="cover" src="https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-17</div><div class="title">JVM系列-03-1、内存与垃圾回收篇---运行时数据区概述及线程</div></div></a></div><div><a href="/posts/65236.html" title="JVM系列-04-1、内存与垃圾回收篇---程序计数器"><img class="cover" src="https://w.wallhaven.cc/full/kx/wallhaven-kx3p1q.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-17</div><div class="title">JVM系列-04-1、内存与垃圾回收篇---程序计数器</div></div></a></div><div><a href="/posts/25470.html" title="JVM系列-06-1、内存与垃圾回收篇---本地方法接口"><img class="cover" src="https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-18</div><div class="title">JVM系列-06-1、内存与垃圾回收篇---本地方法接口</div></div></a></div><div><a href="/posts/51740.html" title="JVM系列-07-1、内存与垃圾回收篇---本地方法栈"><img class="cover" src="https://w.wallhaven.cc/full/d6/wallhaven-d65mzm.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-19</div><div class="title">JVM系列-07-1、内存与垃圾回收篇---本地方法栈</div></div></a></div><div><a href="/posts/24153.html" title="JVM系列-10-1、内存与垃圾回收篇---对象的实例化内存布局与访问定位（重要）"><img class="cover" src="https://w.wallhaven.cc/full/1p/wallhaven-1pjml1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-23</div><div class="title">JVM系列-10-1、内存与垃圾回收篇---对象的实例化内存布局与访问定位（重要）</div></div></a></div><div><a href="/posts/26417.html" title="JVM系列-11-1、内存与垃圾回收篇---直接内存Direct Memory（元空间使用直接内存）"><img class="cover" src="https://w.wallhaven.cc/full/d6/wallhaven-d65mzm.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-24</div><div class="title">JVM系列-11-1、内存与垃圾回收篇---直接内存Direct Memory（元空间使用直接内存）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0"><span class="toc-text">JVM运行时参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">JVM 参数选项类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%80%E6%A0%87%E5%87%86%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-text">类型一：标准参数选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BA%8C-x-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-text">类型二：-X 参数选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%89-xx-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-text">类型三：-XX 参数选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-jvm-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-text">添加 JVM 参数选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#eclipse"><span class="toc-text">Eclipse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#idea"><span class="toc-text">IDEA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C-jar-%E5%8C%85"><span class="toc-text">运行 jar 包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-tomcat-%E8%BF%90%E8%A1%8C-war-%E5%8C%85"><span class="toc-text">通过 Tomcat 运行 war 包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD"><span class="toc-text">程序运行过程中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-jvm-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-text">✨✨✨常用的 JVM 参数选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E8%AE%BE%E7%BD%AE%E7%9A%84-xx-%E9%80%89%E9%A1%B9%E5%8F%8A%E5%80%BC"><span class="toc-text">打印设置的 XX 选项及值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E6%96%B9%E6%B3%95%E5%8C%BA%E7%AD%89%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE"><span class="toc-text">堆、栈、方法区等内存大小设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outofmemory-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-text">OutOfMemory 相关的选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E5%85%B3%E9%80%89%E9%A1%B9"><span class="toc-text">✨✨✨垃圾收集器相关选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3%E9%80%89%E9%A1%B9"><span class="toc-text">GC 日志相关选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0"><span class="toc-text">其他参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-java-%E4%BB%A3%E7%A0%81%E8%8E%B7-jvm-%E5%8F%82%E6%95%B0"><span class="toc-text">通过 Java 代码获 JVM 参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%9E%90gc%E6%97%A5%E5%BF%97"><span class="toc-text">分析GC日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0"><span class="toc-text">GC 日志参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-text">GC 日志格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E5%88%86%E7%B1%BB"><span class="toc-text">GC 分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E6%97%A5%E5%BF%97%E5%88%86%E7%B1%BB"><span class="toc-text">GC 日志分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90"><span class="toc-text">GC 日志结构剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#minor-gc-%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90"><span class="toc-text">Minor GC 日志解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#full-gc-%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90"><span class="toc-text">Full GC 日志解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">GC 日志分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gceasy"><span class="toc-text">GCeasy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gcviewer"><span class="toc-text">GCViewer</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Miraclo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人只有在走上坡路的时候才会累和迷茫。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.1},options:{renderActions:{findScript:[10,t=>{for(const n of document.querySelectorAll('script[type^="math/tex"]')){var e=!!n.type.match(/; *mode=display/),e=new t.options.MathItem(n.textContent,t.inputJax[0],e),a=document.createTextNode("");n.parentNode.replaceChild(a,n),e.start={node:a,delim:"",n:0},e.end={node:a,delim:"",n:0},t.math.push(e)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t.hasAttribute("display")?btf.wrap(t,"div",{class:"mathjax-overflow"}):btf.wrap(t,"span",{class:"mathjax-overflow"})})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script></div><link rel="stylesheet" href="/css/Lete.css"><script src="/js/custom.js"></script><script src="/js/mouth.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1s"),arr[i].setAttribute("data-wow-delay","1ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>