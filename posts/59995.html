<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>JUC-01--进程与线程、Java线程【线程创建、API、状态】 | Miraclo</title><meta name="author" content="Miraclo"><meta name="copyright" content="Miraclo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言：文中出现的示例代码地址为：gitee代码地址 二、线程与进程 2.1 进程与线程 进程  程序由指令和数据组成，但是这些指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令管理内存管理IO的 当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程 进程就可以视为程序的一个实例，大部分程序都可以运行"><meta property="og:type" content="article"><meta property="og:title" content="JUC-01--进程与线程、Java线程【线程创建、API、状态】"><meta property="og:url" content="http://unicorn-acc.github.io/posts/59995.html"><meta property="og:site_name" content="Miraclo"><meta property="og:description" content="前言：文中出现的示例代码地址为：gitee代码地址 二、线程与进程 2.1 进程与线程 进程  程序由指令和数据组成，但是这些指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令管理内存管理IO的 当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程 进程就可以视为程序的一个实例，大部分程序都可以运行"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w.wallhaven.cc/full/1p/wallhaven-1p1qjg.jpg"><meta property="article:published_time" content="2022-11-30T10:09:02.000Z"><meta property="article:modified_time" content="2023-07-12T08:23:55.157Z"><meta property="article:author" content="Miraclo"><meta property="article:tag" content="JUC"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/1p/wallhaven-1p1qjg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://unicorn-acc.github.io/posts/59995"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:2e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:800,languages:{author:"作者: Miraclo",link:"链接: ",source:"来源: Miraclo",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JUC-01--进程与线程、Java线程【线程创建、API、状态】",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-07-12 08:23:55"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mouth.css"><link rel="stylesheet" href="/css/codecolor.css"><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">149</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://w.wallhaven.cc/full/1p/wallhaven-1p1qjg.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Miraclo</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC-01--进程与线程、Java线程【线程创建、API、状态】</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-11-30T10:09:02.000Z" title="发表于 2022-11-30 10:09:02">2022-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/">Java技术栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">JUC并发编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="JUC-01--进程与线程、Java线程【线程创建、API、状态】"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>前言：文中出现的示例代码地址为：<a target="_blank" rel="noopener" href="https://gitee.com/gu_chun_bo/java-construct/tree/master/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/jdk8">gitee代码地址</a></p><h1 id="二线程与进程">二、线程与进程</h1><h2 id="进程与线程">2.1 进程与线程</h2><p><strong>进程</strong></p><ul><li>程序由指令和数据组成，但是这些指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令管理内存管理IO的</li><li>当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程</li><li>进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）</li></ul><p><strong>线程</strong></p><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器（这里感觉要学了计算机组成原理之后会更有感觉吧！）</li></ul><h3 id="二者对比">二者对比</h3><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享</p><p>进程间通信较为复杂</p><p>同一台计算机的进程通信称为 IPC（Inter-process communication）</p><p>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p><h2 id="并行与并发">2.2 并行与并发</h2><p><strong>并发</strong></p><p>在单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。一般会将这种线程轮流使用 CPU 的做法称为并发（concurrent）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212021001554.png"></p><p><strong>并行</strong></p><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212021001077.png"></p><h3 id="二者对比-1">二者对比</h3><p>引用 Rob Pike 的一段描述：并发（concurrent）是同一时间应对（dealing with）多件事情的能力，并行（parallel）是同一时间动手做（doing）多件事情的能力</p><ul><li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li><li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li><li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</li></ul><h2 id="应用">2.3 应用</h2><h3 id="应用之异步调用案例1">应用之异步调用（案例1）</h3><p>以调用方角度来讲，如果</p><ul><li><p>需要等待结果返回，才能继续运行就是同步</p></li><li><p>不需要等待结果返回，就能继续运行就是异步</p></li></ul><p><strong>1)</strong> <strong>设计</strong></p><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停...</p><p><strong>2)</strong> <strong>结论</strong></p><p>比如在项目中，<strong>视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</strong></p><p>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</p><p>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p><h3 id="应用之提高效率案例1">应用之提高效率（案例1）</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">计算 1 花费 10 ms<br>计算 2 花费 11 ms<br>计算 3 花费 9 ms<br>汇总需要 1 ms<br></code></pre></td></tr></table></figure><p>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms</p><p>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms</p><p><strong>注意</strong></p><p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p><p><strong>2)</strong> <strong>结论</strong></p><ol type="1"><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】），也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</p></li><li><p>IO 操作不占用 cpu，只是我们一般<strong>拷贝文件使用的是【阻塞 IO】</strong>，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的<strong>【非阻塞 IO】和【异步 IO】优化</strong></p></li></ol><h1 id="三java线程">三、java线程</h1><p>本章内容</p><p>1、创建和运行线程</p><p>2、查看线程</p><p>3、线程 API</p><p>4、线程状态</p><h2 id="创建和运行线程">3.1 创建和运行线程</h2><h3 id="方法一直接使用-thread">方法一，直接使用 Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法的参数是给线程指定名字，，推荐给线程起个名字</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-comment">// run 方法内实现了要执行的任务</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br> &#125;<br>&#125;;<br>t1.start();<br></code></pre></td></tr></table></figure><h3 id="方法二使用-runnable-配合-thread推荐">方法二，使用 Runnable 配合 Thread（推荐）</h3><p>把【线程】和【任务】（要执行的代码）分开，Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）Test2.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建任务对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br> &#125;<br>&#125;;<br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐给线程起个名字</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><p>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。通过查看源码可以发现，方法二其实到底还是通过方法一执行的！</p><h4 id="使用lambda接口">使用Lambda接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt; &#123;Log.debug(<span class="hljs-string">&quot;running&quot;</span>);&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;Log.debug(<span class="hljs-string">&quot;running&quot;</span>);&#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>原理之 Thread 与 Runnable 的关系</strong></p><p>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</p><p>用 Runnable 更容易与线程池等高级 API 配合</p><p>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p><h3 id="方法三futuretask-配合-thread">方法三，FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况 Test3.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-comment">// 实现多线程的第三种方法可以返回数据</span><br>    <span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            log.debug(<span class="hljs-string">&quot;多线程任务&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask,<span class="hljs-string">&quot;我的名字&quot;</span>).start();<br>    log.debug(<span class="hljs-string">&quot;主线程&quot;</span>);<br>    <span class="hljs-comment">// get()方法用来(阻塞)等待 返回的结果</span><br>    <span class="hljs-comment">// 即 阻塞等待</span><br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,futureTask.get());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Future提供了三种功能： <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RX5rVuGr6Ab0SmKigmZEag">FutureTask是Future和Runable的实现</a>　</p><ol type="1"><li><p>判断任务是否完成； 　　</p></li><li><p>能够中断任务； 　　</p></li><li><p>能够获取任务执行结果。</p></li></ol><h2 id="线程运行原理">3.2 线程运行原理</h2><h3 id="虚拟机栈与栈帧">虚拟机栈与栈帧</h3><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个<strong>栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法返回值、一些附加信息</strong>，是属于线程的私有的。当java中使用多线程时，每个线程都会维护它自己的栈帧！</p><ul><li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li></ul><h3 id="线程上下文切换thread-context-switch">线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li><p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p></li><li><p>Context Switch 频繁发生会影响性能</p></li></ul><h2 id="thread的常见方法">3.3 ✨✨Thread的常见方法</h2><p><strong>①常见构造方法</strong></p><table><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>Thread()</td><td>创建线程对象</td></tr><tr class="even"><td>Thread(Runnable target)</td><td>使用 Runnable 对象创建线程对象</td></tr><tr class="odd"><td>Thread(String name)</td><td>创建线程对象并命名</td></tr><tr class="even"><td>Thread(Runnable target,String name)</td><td>使用 Runnable 对象创建线程对象并命名</td></tr></tbody></table><p>线程创建根本上来讲有两种创建方法：</p><blockquote><ol type="1"><li>创建一个<code>继承自 Thread 类</code>的子类，重写 Thread 中的 run 方法，调用 start 方法</li><li>创建一个<code>实现 Runnable 接口</code>的类，重写 Thread 中的 run 方法。创建 Thread 实例，将自己写的实现 Runnable 接口的类的实例设置进去，调用 start 方法</li></ol></blockquote><p><strong>②常见属性</strong></p><table><thead><tr class="header"><th>属性</th><th>方法</th></tr></thead><tbody><tr class="odd"><td>ID</td><td>getId()</td></tr><tr class="even"><td>名称</td><td>getName()</td></tr><tr class="odd"><td>状态</td><td>getState()</td></tr><tr class="even"><td>优先级</td><td>getPriority()</td></tr><tr class="odd"><td>是否为后台线程</td><td>isDaemon()</td></tr><tr class="even"><td>是否存活</td><td>isAlive()</td></tr><tr class="odd"><td>是否被中断</td><td>isInterrupted()</td></tr></tbody></table><p>解释：</p><ol type="1"><li><p>线程的唯一标识就是<code>线程 Id</code></p></li><li><p><code>名称</code>在上面的案例中有所体现，为调试提供了便利</p></li><li><p><code>状态</code>表示线程当前所处的情况，上面的案例中，线程因为调用了 sleep 方法就进入了阻塞状态</p></li><li><p><code>优先级</code>表示该线程被调度到的难易度，高的更容易被调度到</p></li><li><p>判断<code>是否为后台线程</code>。如果是后台线程，那么该后台线程不会影响 java 进程的结束；如果是非后台线程，JVM 就会等到所有的非后台线程执行完毕，才会结束运行，因此会影响到总进程的结束</p></li><li><p><code>是否存活</code>是来判断线程是否还存在的方法。当创建出 Thread 实例对象时，线程未必就创建了，需要调用 start 方法，才是真正的创建了线程。当线程中的 run 方法执行完毕，线程结束被销毁了，创建出的实例对象还没被销毁回收。所以说，<code>创建出的实例对象和线程的生命周期是不完全相同的</code></p><p>在线程的状态中，除了<code>NEW</code> 和 <code>TERMINATED</code>以外的状态都是活着的</p></li></ol><p><strong>③创建线程</strong></p><p>创建 Thread 类的对象不意味着线程被创建出，<code>start() 方法才是真正的在操作系统内部创建一个新的线程</code>，通过重写 run 方法来描述需要执行的任务，从而真正实现了多线程运行。</p><p><strong>④中断线程</strong></p><p>方法一：<code>手动设置标志位</code>，作为中断线程的条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">func9</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//手动设置的标志位 flag</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (!flag) &#123;<br>                <span class="hljs-comment">//flag 为真时停止循环</span><br>                System.out.println(<span class="hljs-string">&quot;myThread&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//打印一次，阻塞一秒</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        t.start();<span class="hljs-comment">//创建了线程 t</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//等3秒后，在主线程中将 flag 的值改成 true，从而使线程t循环条件不成立</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>方法二：<code>使用 Thread 实例中的标志位</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">func10</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">//通过 isInerrupted()判断标志位是否为true，为true说明线程要退出</span><br>                <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.isInterrupted()) &#123;<br>                   System.out.println(<span class="hljs-string">&quot;my Thread&quot;</span>);<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       Thread.sleep(<span class="hljs-number">1000</span>);<br>                   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                       e.printStackTrace();<br>                       <span class="hljs-comment">//System.out.println(&quot;完善工作&quot;);</span><br>                       <span class="hljs-comment">//break;</span><br>                   &#125;<br>               &#125;<br>            &#125;<br>        &#125;;<br>        t.start();<span class="hljs-comment">//创建新的线程</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        t.interrupt();<br>        <span class="hljs-comment">//t线程运行3秒后，通过 interrupt() 方法将标志位设置为 true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>⑤线程等待</strong></p><p>通过<code>join() 方法</code>来决定线程执行顺序（主要控制结束线程的顺序）。</p><ul><li>在没有调用 join 方法时，main 线程和 t1 线程是并发的，结果输出是相间的。调用 join 方法后，main 线程就会阻塞等待，要等 t1 线程执行完毕，才会执行 join 方法后的内容</li></ul><p><strong>⑥获取线程引用</strong></p><p>方法一：通过<code>继承 Thread 类创建的线程</code>，可以在重写的 run 方法中通过 <code>this</code>获取当前线程的实例</p><p>方法二：通过 <code>Thread 类的 currentThread() 方法</code>，哪个线程调用了该方法，就返回哪个线程的实例对象</p><p><strong>⑦线程休眠</strong></p><p>该方法在前面经常介绍，那就是 <code>sleep 方法</code></p><p>一旦调用 sleep 方法，线程就会阻塞等待，等待的时间取决于指定的参数</p><p>操作系统是以线程为单位进行调度的，每个线程都对应着一个 PCB，并通过双向链表组织这些 PCB</p><p>操作系统调度 PCB 时，就是从<code>就绪队列</code>中选出一个 PCB 去 CPU 上执行，当执行着的线程调用了 sleep 方法，这个 PCB 就会被移动到<code>阻塞队列</code>中，等到 sleep 的时间到了，就会回到就绪队列中，准备好被执行</p><p>join 方法也会产生阻塞等待，就像线程等待中的例子，main 线程执行到 join方法后，就到阻塞队列中，等待对应的 t1 线程执行完毕，才会回到就绪队列中，做好被执行的准备</p><p><strong>⑧线程状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程的状态是一个枚举类型 Thread.State</span><br><span class="hljs-comment">//打印 Java 线程中的所有状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">func13</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Thread.State state : Thread.State.values()) &#123;<br>            System.out.println(state);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>NEW</code>：表示 Thread 类的对象创建出，但是线程还没有被创建，即没有调用 start 方法</li><li><code>RUNNABLE</code>：就绪状态</li><li><code>BLOCKED</code>：等待锁时的状态</li><li><code>WAITING</code>：通过 wait 方法触发</li><li><code>TIMED_WAITING</code>：通过 sleep 方法产生</li><li><code>TERMINATED</code>：线程已经执行完毕，但 Thread 类的对象还存在，未被销毁</li></ul><h3 id="start-与-run">3.3.1 start 与 run</h3><p><strong>调用start</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>          log.debug(<span class="hljs-string">&quot;我是一个新建的线程正在运行中&quot;</span>);<br>          FileReader.read(fileName);<br>      &#125;<br>    &#125;;<br>    thread.setName(<span class="hljs-string">&quot;新建线程&quot;</span>);<br>    thread.start();<br>    log.debug(<span class="hljs-string">&quot;主线程&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：程序在 t1 线程运行， <code>run()</code>方法里面内容的调用是<strong>异步的 Test4.java</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">11</span>:<span class="hljs-string">59:40.711 [main] DEBUG com.concurrent.test.Test4 - 主线程</span><br><span class="hljs-attr">11</span>:<span class="hljs-string">59:40.711 [新建线程] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中</span><br><span class="hljs-attr">11</span>:<span class="hljs-string">59:40.732 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] start ...</span><br><span class="hljs-attr">11</span>:<span class="hljs-string">59:40.735 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 3 ms</span><br></code></pre></td></tr></table></figure><p><strong>调用run</strong></p><p>将上面代码的<code>thread.start();</code>改为 <code>thread.run();</code>输出结果如下：程序仍在 main 线程运行， <code>run()</code>方法里面内容的<strong>调用还是同步的</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">12</span>:<span class="hljs-string">03:46.711 [main] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中</span><br><span class="hljs-attr">12</span>:<span class="hljs-string">03:46.727 [main] DEBUG com.concurrent.test.FileReader - read [test] start ...</span><br><span class="hljs-attr">12</span>:<span class="hljs-string">03:46.729 [main] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 2 ms</span><br><span class="hljs-attr">12</span>:<span class="hljs-string">03:46.730 [main] DEBUG com.concurrent.test.Test4 - 主线程</span><br></code></pre></td></tr></table></figure><h4 id="小结">小结</h4><p>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程 使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</p><h3 id="sleep-与-yield">3.3.2 sleep 与 yield</h3><p><strong>sleep</strong></p><ol type="1"><li><strong>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</strong></li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常<ul><li>【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li></ul></li><li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)</li><li>建议用 TimeUnit 的 <code>sleep()</code> 代替 Thread 的 <code>sleep()</code>来获得更好的可读性</li></ol><p><strong>yield</strong></p><ol type="1"><li><strong>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</strong></li><li>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</li></ol><h4 id="小结-1">小结</h4><p>yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h3 id="线程优先级setpriority">3.3.3 线程优先级setPriority</h3><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span> (;;) &#123;<br> System.out.println(<span class="hljs-string">&quot;----&gt;1 &quot;</span> + count++);<br> &#125;<br>&#125;;<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span> (;;) &#123;<br> <span class="hljs-comment">// Thread.yield();</span><br> System.out.println(<span class="hljs-string">&quot; ----&gt;2 &quot;</span> + count++);<br> &#125;<br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task1, <span class="hljs-string">&quot;t1&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br><span class="hljs-comment">// t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="hljs-comment">// t2.setPriority(Thread.MAX_PRIORITY);</span><br>t1.start();<br>t2.start();<br></code></pre></td></tr></table></figure><h3 id="join">3.3.4 join</h3><p>在主线程中调用t1.join，则<strong>主线程会等待t1线程执行完之后再继续执行 Test10.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>        r = <span class="hljs-number">10</span>;<br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    t1.join();<br>    log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r);<br>    log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212021507023.png"></p><h3 id="interrupt-方法详解">3.3.5 interrupt 方法详解</h3><h4 id="打断-sleepwaitjoin-的线程">打断 sleep，wait，join 的线程</h4><p>先了解一些interrupt()方法的相关知识：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/noteless/p/10372826.html#0">博客地址</a></p><p>sleep，wait，join 的线程，这几个方法都会让线程进入阻塞状态，以 sleep 为例Test7.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;线程任务执行&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10000</span>); <span class="hljs-comment">// wait, join</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">//e.printStackTrace();</span><br>                log.debug(<span class="hljs-string">&quot;被打断&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;;<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    log.debug(<span class="hljs-string">&quot;111是否被打断？&#123;&#125;&quot;</span>,t1.isInterrupted());<br>    t1.interrupt();<br>    log.debug(<span class="hljs-string">&quot;222是否被打断？&#123;&#125;&quot;</span>,t1.isInterrupted());<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    log.debug(<span class="hljs-string">&quot;222是否被打断？&#123;&#125;&quot;</span>,t1.isInterrupted());<br>    log.debug(<span class="hljs-string">&quot;主线程&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：（我下面将中断和打断两个词混用）可以看到，打断 sleep 的线程, 会清空中断状态，刚被中断完之后<code>t1.isInterrupted()</code>的值为<code>true</code>，后来变为<code>false</code>，即中断状态会被清除。那么线程是否被中断过可以通过异常来判断。【同时要注意如果打断被<code>join()</code>，<code>wait()</code> blocked的线程也是一样会被清除，被清除(interrupt status will be cleared)的意思即中断状态设置为<code>false</code>，被设置( interrupt status will be set)的意思就是中断状态设置为<code>true</code>】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">17</span>:<span class="hljs-string">06:11.890 [Thread-0] DEBUG com.concurrent.test.Test7 - 线程任务执行</span><br><span class="hljs-attr">17</span>:<span class="hljs-string">06:12.387 [main] DEBUG com.concurrent.test.Test7 - 111是否被打断？false</span><br><span class="hljs-attr">17</span>:<span class="hljs-string">06:12.390 [Thread-0] DEBUG com.concurrent.test.Test7 - 被打断</span><br><span class="hljs-attr">17</span>:<span class="hljs-string">06:12.390 [main] DEBUG com.concurrent.test.Test7 - 222是否被打断？true</span><br><span class="hljs-attr">17</span>:<span class="hljs-string">06:12.890 [main] DEBUG com.concurrent.test.Test7 - 222是否被打断？false</span><br><span class="hljs-attr">17</span>:<span class="hljs-string">06:12.890 [main] DEBUG com.concurrent.test.Test7 - 主线程</span><br></code></pre></td></tr></table></figure><h4 id="打断正常运行的线程">打断正常运行的线程</h4><p>打断正常运行的线程, 线程并不会暂停，只是调用方法<code>Thread.currentThread().isInterrupted();</code>的返回值为true，可以判断<code>Thread.currentThread().isInterrupted();</code>的值来手动停止线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> Thread.currentThread().isInterrupted();<br>            <span class="hljs-keyword">if</span>(interrupted) &#123;<br>                log.debug(<span class="hljs-string">&quot;被打断了, 退出循环&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    log.debug(<span class="hljs-string">&quot;interrupt&quot;</span>);<br>    t1.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="终止模式之两阶段终止模式">终止模式之两阶段终止模式</h4><p>Two Phase Termination，就是<strong>考虑在一个线程T1中如何优雅地终止另一个线程T2？这里的优雅指的是给T2一个料理后事的机会（如释放锁）。</strong></p><p>如下所示：那么线程的<code>isInterrupted()</code>方法可以取得线程的打断标记，<strong>如果线程在睡眠<code>sleep</code>期间被打断，打断标记是不会变的，为false，但是<code>sleep</code>期间被打断会抛出异常，我们据此手动设置打断标记为<code>true</code>；</strong>如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为<code>true</code>。处理好这两种情况那我们就可以放心地来料理后事啦！</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212021554720.png"></p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test11</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">TwoParseTermination</span> <span class="hljs-variable">twoParseTermination</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoParseTermination</span>();<br>        twoParseTermination.start();<br>        Thread.sleep(<span class="hljs-number">3000</span>);  <span class="hljs-comment">// 让监控线程执行一会儿</span><br>        twoParseTermination.stop(); <span class="hljs-comment">// 停止监控线程</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoParseTermination</span>&#123;<br>    Thread thread ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted())&#123;<br>                    log.debug(<span class="hljs-string">&quot;线程结束。。正在料理后事中&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                    log.debug(<span class="hljs-string">&quot;正在执行监控的功能&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-comment">//重新设置打断标记，使自己在下一次循环时料理后事</span><br>                    Thread.currentThread().interrupt();<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="打断-park-线程">打断 park 线程</h4><p>打断 park 线程, 不会清空打断状态</p><ul><li>如果打断标记已经是 true, 则 park 会失效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br> <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br> log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br> LockSupport.park();<br> log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br> log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<br> &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br> t1.start();<br> sleep(<span class="hljs-number">0.5</span>);<br> t1.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">52.795</span> [t1] c.TestInterrupt - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53.295</span> [t1] c.TestInterrupt - unpark... <br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53.295</span> [t1] c.TestInterrupt - 打断状态：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="sleepyieldwaitjoin-对比">3.3.6 sleep，yield，wait，join 对比</h3><p>关于join的原理和这几个方法的对比：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dataiyangu/article/details/104956755">看这里</a></p><blockquote><p>补充：</p><ol type="1"><li>sleep，join，yield，interrupted是Thread类中的方法</li><li>wait/notify是object中的方法</li></ol><p>sleep 不释放锁、释放cpu</p><p>join 释放锁、抢占cpu</p><p>yiled 不释放锁、释放cpu</p><p>wait 释放锁、释放cpu</p></blockquote><h2 id="守护线程">3.4 守护线程</h2><p>默认情况下，java进程需要等待所有的线程结束后才会停止，但是有一种特殊的线程，叫做守护线程，在其他线程全部结束的时候即使守护线程还未结束代码未执行完java进程也会停止。普通线程t1可以调用<code>t1.setDeamon(true);</code> 方法变成守护线程</p><blockquote><p>注意</p><p><strong>垃圾回收器线程就是一种守护线程</strong></p><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p></blockquote><h2 id="线程状态之五种状态">3.5 线程状态之五种状态</h2><p>五种状态的划分主要是从操作系统的层面进行划分的</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212021656363.png"></p><ol type="1"><li><strong>初始状态</strong>，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</li><li><strong>可运行状态</strong>，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</li><li><strong>运行状态</strong>，指线程获取了CPU时间片，正在运行<ol type="1"><li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ol></li><li><strong>阻塞状态</strong><ol type="1"><li>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】</li><li>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</li></ol></li><li><strong>终止状态</strong>，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ol><h2 id="线程状态之六种状态">3.6 线程状态之六种状态</h2><p>这是从 Java API 层面来描述的，我们主要研究的就是这种。状态转换详情图：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ec94ed32895f">地址</a></p><p>根据 Thread.State 枚举，分为六种状态 Test12.java</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs02/202212021725677.png"></p><ol type="1"><li><code>NEW</code> 线程刚被创建，但是还没有调用 <code>start()</code> 方法</li><li><code>RUNNABLE</code> 是当调用了 <code>start()</code> 方法之后的状态<ul><li>注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li></ul></li><li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述</li><li><code>TERMINATED</code> 当线程代码运行结束</li></ol><hr><ul><li><p><code>NEW</code>：表示 Thread 类的对象创建出，但是线程还没有被创建，即没有调用 start 方法</p></li><li><p><code>RUNNABLE</code>：就绪状态</p></li><li><p><code>BLOCKED</code>：等待锁时的状态</p></li><li><p><code>WAITING</code>：通过 wait 方法触发</p></li><li><p><code>TIMED_WAITING</code>：通过 sleep 方法产生</p></li><li><p><code>TERMINATED</code>：线程已经执行完毕，但 Thread 类的对象还存在，未被销毁</p></li></ul><h2 id="本章小结">本章小结</h2><p>本章的重点在于掌握</p><ul><li><p>线程创建</p></li><li><p>线程重要 api，如 start，run，sleep，join，interrupt 等</p></li><li><p>线程状态</p></li></ul><p>应用方面</p><ul><li><p>异步调用：主线程执行期间，其它线程异步执行耗时操作</p></li><li><p>提高效率：并行计算，缩短运算时间</p></li><li><p>同步等待：join</p></li><li><p>统筹规划：合理使用线程，得到最优效果</p></li></ul><p>原理方面</p><ul><li><p>线程运行流程：栈、栈帧、上下文切换、程序计数器</p></li><li><p>Thread 两种创建方式 的源码</p></li></ul><p>模式方面</p><ul><li>终止模式之两阶段终止</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Unicorn-acc.github.io">Miraclo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://unicorn-acc.github.io/posts/59995.html">http://unicorn-acc.github.io/posts/59995.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Unicorn-acc.github.io" target="_blank">Miraclo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/1p/wallhaven-1p1qjg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/47599.html"><img class="prev-cover" src="https://w.wallhaven.cc/full/1p/wallhaven-1p1qjg.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JUC-02--共享模型之管程【synchronized、变量线程安全分析、Monitior概念、wait和notify、park和unpark、✨Java状态转换、ReentrantLock】</div></div></a></div><div class="next-post pull-right"><a href="/posts/22760.html"><img class="next-cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p9273e.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM系列-01-1、内存与垃圾回收篇---JVM与Java体系结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/31540.html" title="JUC-03--共享模型之内存【java内存模型、可见性、有序性】"><img class="cover" src="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-13</div><div class="title">JUC-03--共享模型之内存【java内存模型、可见性、有序性】</div></div></a></div><div><a href="/posts/31541.html" title="JUC-04--共享模型之无锁、不可变【CAS、原子并发典型实现、ABA问题、日期转换问题、不可变设计】"><img class="cover" src="https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-13</div><div class="title">JUC-04--共享模型之无锁、不可变【CAS、原子并发典型实现、ABA问题、日期转换问题、不可变设计】</div></div></a></div><div><a href="/posts/47599.html" title="JUC-02--共享模型之管程【synchronized、变量线程安全分析、Monitior概念、wait和notify、park和unpark、✨Java状态转换、ReentrantLock】"><img class="cover" src="https://w.wallhaven.cc/full/1p/wallhaven-1p1qjg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">JUC-02--共享模型之管程【synchronized、变量线程安全分析、Monitior概念、wait和notify、park和unpark、✨Java状态转换、ReentrantLock】</div></div></a></div><div><a href="/posts/31546.html" title="JUC-05--共享模型之工具【线程池、JUC并发编程、读写锁、Semaphore信号量、CountdownLatch倒计时锁、CyclicBarrier循环栅栏、CurrentHashMap】"><img class="cover" src="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">JUC-05--共享模型之工具【线程池、JUC并发编程、读写锁、Semaphore信号量、CountdownLatch倒计时锁、CyclicBarrier循环栅栏、CurrentHashMap】</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-text">二、线程与进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.1 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-text">二者对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-text">2.2 并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94-1"><span class="toc-text">二者对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">2.3 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%A1%88%E4%BE%8B1"><span class="toc-text">应用之异步调用（案例1）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E6%A1%88%E4%BE%8B1"><span class="toc-text">应用之提高效率（案例1）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89java%E7%BA%BF%E7%A8%8B"><span class="toc-text">三、java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">3.1 创建和运行线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-thread"><span class="toc-text">方法一，直接使用 Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BD%BF%E7%94%A8-runnable-%E9%85%8D%E5%90%88-thread%E6%8E%A8%E8%8D%90"><span class="toc-text">方法二，使用 Runnable 配合 Thread（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8lambda%E6%8E%A5%E5%8F%A3"><span class="toc-text">使用Lambda接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89futuretask-%E9%85%8D%E5%90%88-thread"><span class="toc-text">方法三，FutureTask 配合 Thread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">3.2 线程运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%8E%E6%A0%88%E5%B8%A7"><span class="toc-text">虚拟机栈与栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2thread-context-switch"><span class="toc-text">线程上下文切换（Thread Context Switch）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">3.3 ✨✨Thread的常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#start-%E4%B8%8E-run"><span class="toc-text">3.3.1 start 与 run</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E4%B8%8E-yield"><span class="toc-text">3.3.2 sleep 与 yield</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7setpriority"><span class="toc-text">3.3.3 线程优先级setPriority</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-text">3.3.4 join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.3.5 interrupt 方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E6%96%AD-sleepwaitjoin-%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">打断 sleep，wait，join 的线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E6%96%AD%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">打断正常运行的线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F"><span class="toc-text">终止模式之两阶段终止模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E6%96%AD-park-%E7%BA%BF%E7%A8%8B"><span class="toc-text">打断 park 线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleepyieldwaitjoin-%E5%AF%B9%E6%AF%94"><span class="toc-text">3.3.6 sleep，yield，wait，join 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">3.4 守护线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">3.5 线程状态之五种状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">3.6 线程状态之六种状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-text">本章小结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Miraclo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人只有在走上坡路的时候才会累和迷茫。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.1},options:{renderActions:{findScript:[10,t=>{for(const n of document.querySelectorAll('script[type^="math/tex"]')){var e=!!n.type.match(/; *mode=display/),e=new t.options.MathItem(n.textContent,t.inputJax[0],e),a=document.createTextNode("");n.parentNode.replaceChild(a,n),e.start={node:a,delim:"",n:0},e.end={node:a,delim:"",n:0},t.math.push(e)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t.hasAttribute("display")?btf.wrap(t,"div",{class:"mathjax-overflow"}):btf.wrap(t,"span",{class:"mathjax-overflow"})})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script></div><link rel="stylesheet" href="/css/Lete.css"><script src="/js/custom.js"></script><script src="/js/mouth.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1s"),arr[i].setAttribute("data-wow-delay","1ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>