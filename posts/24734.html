<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>JS相关WebApi（DOM基础、事件高级、BOM基础、PC端网页特效、移动端网页特效、本地存储） | Miraclo</title><meta name="author" content="Miraclo"><meta name="copyright" content="Miraclo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Web Api 简介 1. Web APIs 和 JS 基础关联性 1.1 JS 组成  ECMAScript: JS 语法 BOM: Web API DOM: Web API  2. API 和 Web API 2.1 API API：Application Programming Interface，应用程序接口。 2.2 Web API Web API 是浏览器提供得一套操作浏览器功能和"><meta property="og:type" content="article"><meta property="og:title" content="JS相关WebApi（DOM基础、事件高级、BOM基础、PC端网页特效、移动端网页特效、本地存储）"><meta property="og:url" content="http://unicorn-acc.github.io/posts/24734.html"><meta property="og:site_name" content="Miraclo"><meta property="og:description" content="一、Web Api 简介 1. Web APIs 和 JS 基础关联性 1.1 JS 组成  ECMAScript: JS 语法 BOM: Web API DOM: Web API  2. API 和 Web API 2.1 API API：Application Programming Interface，应用程序接口。 2.2 Web API Web API 是浏览器提供得一套操作浏览器功能和"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg"><meta property="article:published_time" content="2023-07-28T14:53:00.000Z"><meta property="article:modified_time" content="2023-09-20T08:55:49.520Z"><meta property="article:author" content="Miraclo"><meta property="article:tag" content="JS"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://unicorn-acc.github.io/posts/24734"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:2e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:800,languages:{author:"作者: Miraclo",link:"链接: ",source:"来源: Miraclo",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JS相关WebApi（DOM基础、事件高级、BOM基础、PC端网页特效、移动端网页特效、本地存储）",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-09-20 08:55:49"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mouth.css"><link rel="stylesheet" href="/css/codecolor.css"><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">162</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Miraclo</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JS相关WebApi（DOM基础、事件高级、BOM基础、PC端网页特效、移动端网页特效、本地存储）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-07-28T14:53:00.000Z" title="发表于 2023-07-28 14:53:00">2023-07-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/">Java技术栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/">前端技术栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/HTML-CSS-JS/">HTML\CSS\JS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="JS相关WebApi（DOM基础、事件高级、BOM基础、PC端网页特效、移动端网页特效、本地存储）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一web-api-简介">一、Web Api 简介</h1><h2 id="web-apis-和-js-基础关联性">1. Web APIs 和 JS 基础关联性</h2><h3 id="js-组成">1.1 JS 组成</h3><ul><li>ECMAScript: JS 语法</li><li>BOM: Web API</li><li>DOM: Web API</li></ul><h2 id="api-和-web-api">2. API 和 Web API</h2><h3 id="api">2.1 API</h3><p>API：Application Programming Interface，应用程序接口。</p><h3 id="web-api">2.2 Web API</h3><p>Web API 是浏览器提供得一套操作浏览器功能和页面元素得 API（BOM 和 DOM）。</p><h1 id="二dom-基础document-object-model">二、DOM 基础（Document Object Model）</h1><h2 id="dom-简介">1. DOM 简介</h2><h3 id="什么是-dom">1.1 什么是 DOM</h3><p>文档对象模型（Document Object Model，简称DOM )，是W3C组织推荐的处理可扩展标记语言（HTML或者XML)的标准编程接口。</p><p>W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。</p><h3 id="dom-树">1.2 DOM 树</h3><ul><li>文档：一个页面就是一个文档，DOM中使用document表示</li><li>元素：页面中的所有标签都是元素，DOM中使用element表示</li><li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示</li></ul><p>以上内容都称之为对象</p><h2 id="获取元素重要">2. 获取元素【重要】</h2><h3 id="如何获取页面元素">2.1 如何获取页面元素</h3><p><strong>DOM 在我们实际开发中主要用来操作元素。我们如何来获取页面中的元素呢?</strong></p><p>获取页面中的元素可以使用以下几种方式: - 根据ID获取 - 根据标签名获取 - 通过HTML5新增的方法获取 - 特殊元素获取</p><h3 id="根据-id-获取">2.2 根据 ID 获取</h3><p>使用 <code>getElementByld()</code> 方法可以获取带有 ID 的元素对象，并返回一个 <code>Element</code> 对象。</p><ul><li><code>console.dir()</code> 可打印元素的属性和方法</li></ul><h3 id="根据标签名获取">2.3 根据标签名获取</h3><p>使用 <code>getElementsByTagName()</code> 方法可以返回带有指定标签名的对象的集合。</p><ul><li>返回的是 <strong>元素对象的集合，伪数组形式表示</strong>。</li><li>可以遍历返回的伪数组。</li><li>得到的元素对象是动态的。</li><li>若没有元素，则返回空的伪数组 <code>[]</code>。</li></ul><p>指定父元素，父元素必须是指定的单个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ol = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;ol&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ol[<span class="hljs-number">0</span>].<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;li&#x27;</span>));<br></code></pre></td></tr></table></figure><p>若给 <code>ol</code> 指定了 id: <code>ol</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ol = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ol&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ol.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="通过-html5-新增方法获取">2.4 通过 HTML5 新增方法获取</h3><ol type="1"><li><p>根据类名返回元素对象集合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;类名&#x27;</span>); <br></code></pre></td></tr></table></figure><p></p></li><li><p>根据指定选择器返回第一个元素对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;选择器&#x27;</span>); <br></code></pre></td></tr></table></figure><p></p></li><li><p>返回指定选择器的所有元素集合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;选择器&#x27;</span>) <br></code></pre></td></tr></table></figure><p></p></li></ol><blockquote><p>[!TIP] 对于这些获取事件，要不就是返回一个元素对象，要不就是返回一个对象集合。对于返回的对象集合，都可以是作为一种伪数组，可以通过 <code>elems.length</code> 来获取元素对象个数。</p></blockquote><h3 id="获取特殊元素">2.5 获取特殊元素</h3><ol type="1"><li><p>获取 <code>body</code> 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>;<br></code></pre></td></tr></table></figure><p></p></li><li><p>获取 <code>html</code> 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>;<br></code></pre></td></tr></table></figure><p></p></li></ol><h2 id="事件基础">3. 事件基础</h2><h3 id="事件概述">3.1 事件概述</h3><p>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p><p>简单理解︰触发--响应机制。</p><p>网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。</p><h3 id="事件三要素">3.2 事件三要素</h3><ul><li>事件源：事件被触发的对象（按钮）。</li><li>事件类型：如何触发、什么事件（点击按钮）。</li><li>事件处理程序：可通过一个函数赋值的方式实现。</li></ul><ol type="1"><li>获取事件源<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>唐伯虎<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>注册事件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li>添加事件处理程序<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;点秋香&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>[!TIP] 执行事件的步骤</p><ol type="1"><li>获取事件源</li><li>注册事件（绑定事件）</li><li>添加事件处理程序（函数赋值）</li></ol></blockquote><h3 id="常见鼠标事件重要">3.4 常见鼠标事件【重要】</h3><table><thead><tr class="header"><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr class="odd"><td><code>onclick</code></td><td>鼠标点击左键触发</td></tr><tr class="even"><td><code>onmouseover</code></td><td>鼠标经过触发</td></tr><tr class="odd"><td><code>onmouseout</code></td><td>鼠标离开触发</td></tr><tr class="even"><td><code>onfocus</code></td><td>获得鼠标焦点触发</td></tr><tr class="odd"><td><code>onblur</code></td><td>失去鼠标焦点触发</td></tr><tr class="even"><td><code>onmousemove</code></td><td>鼠标移动触发</td></tr><tr class="odd"><td><code>onmouseup</code></td><td>鼠标弹起触发</td></tr><tr class="even"><td><code>onmousedown</code></td><td>鼠标按下触发</td></tr></tbody></table><h2 id="操作元素">4. 操作元素</h2><p>使用 JavaScript DOM 可以改变网页内容、结构和样式。以下是元素的属性。</p><h3 id="改变元素内容">4.1 改变元素内容</h3><p>从起始位置到终止位置的内容,但它去除html标签，同时空格和换行也会去掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">innerText</span><br></code></pre></td></tr></table></figure><p>起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">innerHTML</span><br></code></pre></td></tr></table></figure><h3 id="innertext-和-innerhtml-的区别">4.2 innerText 和 innerHTML 的区别</h3><ol type="1"><li><p><code>innerText</code> 不识别 html 标签，<code>innerHTML</code> 识别 html 标签。</p><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">div.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27; &lt;strong&gt;今天是：&lt;/strong&gt;2021-3-23&#x27;</span>;<br></code></pre></td></tr></table></figure><p></p></li><li><p><code>innerText</code> 会取出空格和换行，<code>innerHTML</code> 保留换行和空格。</p></li></ol><h3 id="常用元素的属性操作">4.3 常用元素的属性操作</h3><ol type="1"><li><code>innerText</code>、<code>innerHTML</code> 改变元素内容</li><li><code>src</code>、<code>href</code></li><li><code>id</code>、<code>alt</code>、<code>title</code></li></ol><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> vsc = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;vsc&#x27;</span>);<br><span class="hljs-keyword">let</span> zh = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;zh&#x27;</span>);<br><span class="hljs-keyword">let</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;img&#x27;</span>);<br>vsc.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    img.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;images/vscode.jpg&#x27;</span>;<br>    img.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;vscode&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表单元素的属性操作">4.4 表单元素的属性操作</h3><p>利用 DOM 可以操控以下表单元素的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">type, value, checked, selected, disabled<br></code></pre></td></tr></table></figure><h3 id="样式属性操作">4.5 样式属性操作</h3><p>我们可以通过JS修改元素的大小、颜色、位置等样式。</p><ol type="1"><li><code>element.style</code>：行内样式操作</li><li><code>element.className</code>：类名样式操作</li></ol><blockquote><p>[!tip] 1. Js 里面的样式采取驼峰命名法比如 <code>fontSize</code>、<code>backgroundColor</code> 2. JS修改 <code>style</code> 样式操作，产生的是行内样式，css 权重比较高 3. 如果样式修改较多，可以采取操作类名方式更改元素样式 4. class 因为是个保留字，因此使用 <code>className</code> 来操作元素类名属性 5. <code>className</code> 会直接更改元素的类名，会覆盖原先的类名。</p></blockquote><h3 id="排他思想">4.6 排他思想</h3><p>如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法：</p><ol type="1"><li>所有元素全部清除样式（干掉其他人）</li><li>给当前元素设置样式（留下我自己）</li><li>注意顺序不能颠倒，首先干掉其他人，再设置自己。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btns = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; btns.<span class="hljs-property">length</span>; i++) &#123;<br>       btns[i].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;btns.<span class="hljs-property">length</span>;j++) &#123;<br>               btns[j].<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>           &#125;<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;pink&#x27;</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!TIP] 根据这个算法可以用来实现鼠标经过每一行时背景变色。</p></blockquote><h3 id="h5自定义属性">4.7 H5自定义属性</h3><p>自定义属性目的：是为了保存并使用数据，有些数据可以保存到页面中而不用保存到数据库中。</p><h4 id="设置h5自定义属性">4.7.1 设置H5自定义属性</h4><p>H5规定自定义属性以 <code>data-</code> 开头作为属性名并赋值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="获取h5自定义属性">4.7.2 获取H5自定义属性</h4><ol type="1"><li>兼容性获取 <code>element.getAttribute('data-index')</code></li><li>H5新增方法 <code>element.dataset.index</code> 或 <code>element.dataset['index']</code> 获取。（&gt;=ie11）</li><li>如果自定义属性里面有多个链接的单词，则使用驼峰命名法获取。</li></ol><blockquote><p>[!warning] 对于 <code>element.dataset.index</code> 和 <code>element.dataset['index']</code> 方法，注意 <code>index</code> 和 <code>data-index</code> 中的要对应。</p></blockquote><h3 id="元素属性操作">4.8 元素属性操作</h3><h4 id="获取属性值">4.8.1 获取属性值</h4><ul><li><code>element.属性</code>;：一般用于获取本身自带属性值。</li><li><code>element.getAttribute('属性');</code>：主要获得自定义的属性（标准）我们程序员自定义的属性。</li></ul><h4 id="设置属性值">4.8.2 设置属性值</h4><ul><li><code>element.属性='值';</code>：设置内置属性值。</li><li><code>element.setAttribute('属性', '值');</code>：设置自定义属性。</li></ul><blockquote><p>[!TIP] 对于 <code>element.setAttribute</code> 方法，若属已存在，则更新该属性值；否则，创建一个新属性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">div.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-number">1</span>);<br>div.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;footer&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>[!warning] 使用 <code>element.属性</code> 获取或设置类名时，要用 <code>className</code>，而对于 <code>element.setAttribute()</code> 方法，直接使用 <code>class</code>，即：<code>div.setAttribute('class', 'footer')</code>。</p></blockquote><h4 id="移除属性">4.8.3 移除属性</h4><ul><li><code>element.removeAttribute(属性);</code></li></ul><h2 id="结点操作">5. 结点操作</h2><h3 id="为什么学节点操作">5.1为什么学节点操作</h3><p>获取元素通常使用两种方式:</p><ol type="1"><li>利用DOM提供的方法获取元素，缺点：逻辑性不强、繁琐<ul><li><code>document.getElementByld()</code></li><li><code>document.getElementsByTagName()</code></li><li><code>document.querySelector()</code></li></ul></li><li>利用 <strong>节点层级关系</strong> 获取元素<ul><li>利用父子兄节点关系获取元素</li><li>优点：逻辑性强</li><li>缺点：兼容性稍差</li></ul></li></ol><h3 id="节点概述">5.2 节点概述</h3><p>网页中的所有内容都是节点(标签、属性、文本、注释等），在DOM中，节点使用 <code>node</code> 来表示。</p><p>HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</p><p>一般地，节点至少拥有 <code>nodeType</code> (节点类型)、<code>nodeName</code> (节点名称）和 <code>nodeValue</code> (节点值）这三个基本属性。</p><p><strong>三种基本节点类型：</strong> - 元素节点 <code>nodeType</code> 为 <code>1</code> - 属性节点 <code>nodeType</code> 为 <code>2</code> - 文本节点 <code>nodeType</code> 为 <code>3</code>（文字、空格、换行）</p><p>实际开发中，主要操作的还是元素节点。</p><h3 id="节点层级">5.3 节点层级</h3><h4 id="父级节点">5.3.1 父级节点</h4><p>获取离元素最近的父节点，若找不到则返回 <code>null</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">node.<span class="hljs-property">parentNode</span><br></code></pre></td></tr></table></figure><h4 id="子节点">5.3.2 子节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parentNode.<span class="hljs-property">childNodes</span><br></code></pre></td></tr></table></figure><p><code>parentNode.childNodes</code> 返回包含指定 <strong>节点的子节点的集合</strong>，该集合为即时更新的集合。</p><blockquote><p>[!warning] 注意：<code>parentNode.childNodes</code> 包含了所有的子节点，包括元素节点，文本节点等。 如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用 <code>childNodes</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 筛选元素节点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ul.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (ul.<span class="hljs-property">childNodes</span>[i].<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ul.<span class="hljs-property">childNodes</span>[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>更加好的方法：获取子元素节点</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parentNode.<span class="hljs-property">children</span>;<br></code></pre></td></tr></table></figure><p>子节点方法：</p><p>① 获取 <strong>所有结点</strong> 中的第一个和最后一个：</p><ul><li><code>parentNode.firstChild</code></li><li><code>parentNode.lastChild</code></li></ul><p>② 获取 <strong>元素节点</strong>中第一个和最后一个</p><ul><li><code>parentNode.firstElementChild</code></li><li><code>parentNode.lastElementChild</code></li></ul><p>（&gt;=IE9）</p><p>③ <strong>实际开发</strong>：</p><ul><li><code>parentNode.children[0]</code></li><li><code>parentNode.children[parentNode.children.length -1]</code></li></ul><h4 id="兄弟节点">5.3.3 兄弟节点</h4><ol type="1"><li><p>返回下一个兄弟节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">node.<span class="hljs-property">nextSibling</span><br></code></pre></td></tr></table></figure><p></p></li><li><p>返回上一个的兄弟节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">node.previousSibling<br></code></pre></td></tr></table></figure><code>nextsibling</code> / <code>previousSibling</code> 返回当前元素的下/上一个兄弟节点，找不到则返回 <code>null</code>。这个兄弟节点可能是是所有的节点之一（即元素节点、文本节点等）。<p></p></li><li><p>返回下一个 <strong>兄弟元素节点</strong>（≥IE9）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">node.<span class="hljs-property">nextElementSibling</span><br></code></pre></td></tr></table></figure><p></p></li><li><p>返回上一个 <strong>兄弟元素节点</strong>（≥IE9）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">node.<span class="hljs-property">previousElementSibling</span><br></code></pre></td></tr></table></figure><code>nextElementSibling</code> / <code>previousElementSibling</code> 返回当前元素下/上一个兄弟元素节点，找不到则返回 <code>null</code>。<p></p></li></ol><blockquote><p>[!warning] 这两个方法（<code>nextElementSibling</code> / <code>previousElementSibling</code>）有兼容性问题，IE9 以上才支持。</p></blockquote><p>解决方法：封装一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 处理 &lt;IE9 兼容性问题</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNextElementSibling</span>(<span class="hljs-params">node</span>) &#123;<br>    <span class="hljs-keyword">let</span> n = node;<br>    <span class="hljs-keyword">while</span> (n = n.<span class="hljs-property">nextSibling</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p></p><h4 id="创建并添加节点">5.3.4 创建并添加节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;tagName&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>document.createElement()</code> 方法创建由 <code>tagName</code> 指定的 HTML 元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为 <strong>动态创建元素节点</strong>。</p><p>在创建了元素节点后，还需要将节点添加到页面中。<code>appendChild()</code> 方法可以给元素节点添加子元素节点，若某元素已存在则重复添加，在页面已存在的元素 <strong>后面追加新节点</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parentNode.<span class="hljs-title function_">appendChild</span>(chileNode)<br></code></pre></td></tr></table></figure><p></p><p>类似的，也可以使用 <code>insertBefore()</code> 方法在指定元素的前面插入节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> insertedNode = parentNode.<span class="hljs-title function_">insertBefore</span>(newNode, referenceNode)<br></code></pre></td></tr></table></figure><p></p><p>参数说明： - <code>insertedNode</code>：同 <code>newNode</code>，待插入的新节点。 - <code>parentNode</code>：被插入的父节点。 - <code>newNode</code>：待插入的新节点。 - <code>referenceNode</code>：指定元素节点，新节点将插入到该元素节点的前面。</p><blockquote><p>[!TIP] 在一个页面中要添加元素节点，先创建节点，然后添加节点。</p></blockquote><h4 id="删除节点">5.3.5 删除节点</h4><p>DOM 提供了 <code>removeChild(childNode)</code> 方法，删除一个子节点，并返回删除的节点。其中 <code>childNode</code> 为待删除的子节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 方式一</span><br>parentNode.<span class="hljs-title function_">removeChild</span>(childNode);<br><span class="hljs-comment">// 方式二</span><br><span class="hljs-keyword">let</span> oldChild = parentNode.<span class="hljs-title function_">removeChild</span>(childNode);<br></code></pre></td></tr></table></figure><h4 id="复制节点">5.3.6 复制节点</h4><p><code>node.cloneNode()</code> 方法返回调用该方法的节点的一个副本。也称为克隆节点/拷贝节点。其中 <code>node</code> 为被克隆的元素节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">node.<span class="hljs-title function_">cloneNode</span>([deep]);<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> newClone = node.<span class="hljs-title function_">cloneNode</span>([deep]);<br></code></pre></td></tr></table></figure><p></p><p>对于 <code>deep</code> 参数，可以为 <code>true</code> 或 <code>false</code>，或为空的：</p><table><thead><tr class="header"><th><code>deep</code> 参数值</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>true</code></td><td>深拷贝，同时复制节点本身和里面的子节点</td></tr><tr class="even"><td><code>false</code></td><td>浅拷贝，只复制节点本身，不复制子节点</td></tr><tr class="odd"><td><code>空</code></td><td>空，同 <code>false</code></td></tr></tbody></table><h4 id="三种动态创建元素的区别">5.3.7 三种动态创建元素的区别</h4><ul><li><code>document.write()</code></li><li><code>element.innerHTML</code></li><li><code>element.createElement()</code></li></ul><p>区别：</p><ol type="1"><li><code>document.write()</code> 创建元素，是直接将内容写入页面的内容流，但是 <strong>当文档流执行完毕，会导致页面全部重绘</strong>。即覆盖原本的页面。</li><li><code>innerHTML</code> 是将内容写入某个 DOM 节点，不会导致页面全部重绘。<br></li><li><code>innerHTML</code> 创建多个元素效率更高（<strong>不要拼接字符串，采取数组形式拼接</strong>），结构稍微复杂。<br></li><li><code>createElement()</code> 创建多个元素效率稍低一点点，但是结构更清晰。</li></ol><p>总结：不同浏览器下，<code>innerHTML</code> 效率要比 <code>creatElement</code>高。</p><h2 id="dom-学习阶段核心总结重要">6. DOM 学习阶段核心总结【重要】</h2><p>关于 dom 操作，我们主要针对于元素的操作。主要有创（建）、增、删、改、查、属性操作、事件操作。</p><h3 id="创">6.1 创</h3><ul><li><code>document.write</code></li><li><code>innerHTML</code></li><li><code>createElement</code></li></ul><h3 id="增">6.2 增</h3><ul><li><code>appendChild</code></li><li><code>insertBefore</code></li></ul><h3 id="删">6.3 删</h3><ul><li><code>removeChild</code></li></ul><h3 id="改">6.4 改</h3><p>主要修改 dom 的元素属性，dom 元素的内容、属性，表单的值等。 - 修改元素属性：<code>src</code>、<code>href</code>、<code>title</code> 等 - 修改普通元素内容：<code>innerHTML</code>、<code>innerText</code> - 修改表单元素：<code>value</code>、<code>type</code>、<code>disabled</code> 等 - 修改元素样式：<code>style</code>、<code>className</code></p><h3 id="查">6.5 查</h3><p>主要获取查询dom的元素 - DOM提供的API 方法：<code>getElementById</code>、<code>getElementsByTagName</code>（<strong>古老用法不太推荐</strong>） - H5提供的新方法：<code>querySelector</code>、<code>querySelectorAll</code> 提倡 - 利用节点操作获取元素：父（<code>parentNode</code>)、子（<code>children</code>）、兄（<code>previousElementSibling</code>、 <code>nextElementSibling</code>）提倡</p><h3 id="属性操作">6.6 属性操作</h3><p>主要针对于自定义属性</p><ul><li><code>setAttribute</code>：设置dom的属性值</li><li><code>getAttribute</code>：得到dom的属性值</li><li><code>removeAttribute</code>：移除属性</li></ul><h3 id="事件操作">6.7 事件操作</h3><p>给元素注册事件，格式：<code>事件源.事件类型 = 事件处理程序</code></p><table><thead><tr class="header"><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr class="odd"><td><code>onclick</code></td><td>鼠标点击左键触发</td></tr><tr class="even"><td><code>onmouseover</code></td><td>鼠标经过触发</td></tr><tr class="odd"><td><code>onmouseout</code></td><td>鼠标离开触发</td></tr><tr class="even"><td><code>onfocus</code></td><td>获得鼠标焦点触发</td></tr><tr class="odd"><td><code>onblur</code></td><td>失去鼠标焦点触发</td></tr><tr class="even"><td><code>onmousemove</code></td><td>鼠标移动触发</td></tr><tr class="odd"><td><code>onmouseup</code></td><td>鼠标弹起触发</td></tr><tr class="even"><td><code>onmousedown</code></td><td>鼠标按下触发</td></tr></tbody></table><h1 id="三事件高级">三、事件高级</h1><h2 id="注册事件绑定事件">1. 注册事件（绑定事件）</h2><h3 id="注册事件概述">1.1 注册事件概述</h3><p>给元素添加事件，称为注册事件或者绑定事件。 注册事件有两种方式：<strong>传统方式</strong> 和 <strong>事件监听注册方式</strong>。</p><h4 id="传统注册方式">1.1.1 传统注册方式</h4><ul><li>利用on 开头的事件onclick</li><li><code>&lt;button onclick="alert('hi~')"&gt;&lt;/button&gt;</code></li><li><code>btn.onclick = function() &#123;&#125;;</code></li><li>特点：注册事件的 <strong>唯一性</strong></li><li>同一个元素同一个事件只能设置一个处理函数，最 后注册的处理函数将会 <strong>覆盖</strong> 前面注册的处理函数。</li></ul><h4 id="事件监听注册方式">1.1.2 事件监听注册方式</h4><ul><li>w3c 标准推荐方式</li><li><code>addEventListener()</code> 它是一个方法</li><li>IE9 之前的 IE 不支持此方法，可使用 <code>attachEvent()</code> 代替</li><li>特点：<strong>同一个元素同一个事件可以注册多个监听器</strong></li><li>按注册顺序依次执行</li></ul><h3 id="addeventlistener-事件监听方式">1.2 addEventListener 事件监听方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">eventTarget.<span class="hljs-title function_">addEventListener</span>(type, listener[, useCapture])<br></code></pre></td></tr></table></figure><p><code>eventTarget.addEventListener()</code> 方法将指定的监听器注册到 <code>eventTarget</code>（目标对象）上，当该对 象触发指定的事件时，就会执行事件处理函数。</p><p>该方法接收三个参数： - <code>type</code>：事件类型字符串，比如 <code>click</code> 、<code>mouseover</code>，注意这里不要带 on。 - <code>listener</code>：事件处理函数，事件发生时，会调用该监听函数 - <code>useCapture</code>：可选参数，是一个布尔值，默认是 <code>false</code>。学完 DOM 事件流后，我们再进一步学习。</p><blockquote><p>[!warning] ≥IE9 版本支持</p></blockquote><h3 id="attachevent-事件监听方式ie8以及早期版本独有">1.3 attachEvent 事件监听方式（IE8以及早期版本独有）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">eventTarget.<span class="hljs-title function_">attachEvent</span>(eventNameWithOn, callback)<br></code></pre></td></tr></table></figure><p><code>eventTarget.attachEvent()</code> 方法将指定的监听器注册到 <code>eventTarget</code>（目标对象）上，当该对象触 发指定的事件时，指定的回调函数就会被执行。 该方法接收两个参数： - <code>eventNameWithOn</code>：事件类型字符串，比如 <code>onclick</code>、<code>onmouseover</code>，这里要带 <code>on</code> - <code>callback</code>：事件处理函数，当目标触发事件时回调函数被调用</p><blockquote><p>[!warning] IE8 及早期版本独有，在 chrome 不起作用。如要兼容，可自定义兼容新函数。</p></blockquote><h2 id="删除事件解绑事件">2. 删除事件（解绑事件）</h2><h3 id="传统注册方式-1">2.1 传统注册方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">eventTarget.<span class="hljs-property">onclick</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h3 id="方法监听注册方式">2.2 方法监听注册方式</h3><h4 id="removeeventlistenerie9">2.2.1 removeEventListener（≥IE9）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">eventTarget.<span class="hljs-title function_">removeEventListener</span>(type, listener[, useCapture]);<br></code></pre></td></tr></table></figure><blockquote><p>[!TIP] 一个对象可能绑定了很多事件，对于 <code>removeEventListener</code> 方法，需要指定要删除的事件 <code>listener</code>。所以在注册事件的时候需要提前将事件函数封装在一个变量里。然后把变量传给 <code>removeEventListener</code> 方法。</p></blockquote><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> btns = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><span class="hljs-keyword">var</span> func1 = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I \&#x27;m click(addEventListener)&quot;</span>);<br>    btns[<span class="hljs-number">0</span>].<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, func1);<br>&#125;;<br>btns[<span class="hljs-number">0</span>].<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, func1);<br></code></pre></td></tr></table></figure><h4 id="detachevent仅适用于ie8及以下">2.2.2 detachEvent（仅适用于IE8及以下）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">eventTarget.<span class="hljs-title function_">detachEvent</span>(eventNameWithOn, callback);<br></code></pre></td></tr></table></figure><h2 id="dom-事件流">3. DOM 事件流</h2><h3 id="定义">3.1 定义</h3><p><strong>事件流</strong> 描述的是从页面中接收事件的顺序。</p><p><strong>事件</strong> 发生时会在元素节点之间 <strong>按照特定的顺序</strong> 传播，这个传播过程即 <strong>DOM 事件流</strong>。</p><p>比如我们给一个 <code>div</code> 注册了点击事件。<br>DOM 事件流分为3个阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">捕获阶段 =&gt; 当前目标阶段 =&gt; 冒泡阶段<br></code></pre></td></tr></table></figure><p></p><ul><li><strong>事件冒泡</strong>：IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。</li><li><strong>事件捕获</strong>：网景最早提出，由DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。</li></ul><p>我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具 体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（最具体元素）之后漂浮到水面上，这个过 程相当于事件冒泡。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/js1.3f1t9u88n880.png"></p><h3 id="注意">3.2 注意</h3><ol type="1"><li>JS 代码中只能执行捕获或者冒泡其中的一个阶段。</li><li><code>onclick</code> 和 <code>attachEvent</code> 只能得到冒泡阶段。</li><li><code>addEventListener(type, listener[, useCapture])</code> 第三个参数如果是 <code>true</code>，表示在事件捕 获阶段调用事件处理程序；如果是 <code>false</code>（不写默认就是 <code>false</code>），表示在事件冒泡阶段调用事件处理 程序。</li><li>实际开发中我们很少使用事件捕获，我们 <strong>更关注事件冒泡</strong>。</li><li><strong>有些事件是没有冒泡的</strong>，比如 <code>onblur</code>、<code>onfocus</code>、<code>onmouseenter</code>、<code>onmouseleave</code></li><li><strong>事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解</strong>。</li></ol><h2 id="事件对象">4. 事件对象</h2><h3 id="什么是事件对象">4.1 什么是事件对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">eventTarget.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;&#125;<br>eventTarget.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;&#125;）<br><span class="hljs-comment">// 这个event 就是事件对象，我们还喜欢的写成 e 或者evt</span><br></code></pre></td></tr></table></figure><ul><li>官方解释：<code>event</code> 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。</li><li>简单理解：事件发生后，跟 <strong>事件相关的一系列信息数据的集合</strong> 都放到这个对象里面，这个对象就是事件对象 <code>event</code>，它有很多属性和方法。</li></ul><p>比如： 1. 谁绑定了这个事件。 2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。 3. 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</p><h3 id="事件对象的使用语法">4.2 事件对象的使用语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">eventTarget.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br><span class="hljs-comment">// 这个event 就是事件对象，我们还喜欢的写成e 或者evt</span><br>&#125;<br>eventTarget.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br><span class="hljs-comment">// 这个event 就是事件对象，我们还喜欢的写成e 或者evt</span><br>&#125;）<br></code></pre></td></tr></table></figure><p>这个 <code>event</code> 是个形参，系统帮我们设定为事件对象，不需要传递实参过去。<br>当我们注册事件时，<code>event</code> 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。</p><h3 id="事件对象的兼容性方案">4.3 事件对象的兼容性方案</h3><p>事件对象本身的获取存在兼容问题： 1. 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 <code>e</code> 就可以获取到。 2. 在IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 <code>window.event</code> 中获取查找。</p><p>解决方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">e = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br></code></pre></td></tr></table></figure><p></p><h3 id="事件对象的常见属性和方法">4.4 事件对象的常见属性和方法</h3><table><thead><tr class="header"><th>事件对象属性方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>e.target</code></td><td>返回触发事件的对象（标准）</td></tr><tr class="even"><td><code>e.srcElement</code></td><td>返回触发事件的对象（非标准）</td></tr><tr class="odd"><td><code>e.type</code></td><td>返回事件类型</td></tr><tr class="even"><td><code>e.preventDefault()</code></td><td>阻止默认事件（标准）</td></tr><tr class="odd"><td><code>e.returnValue = true</code></td><td>阻止默认事件（非标准，IE678）</td></tr><tr class="even"><td><code>e.stopPropagation()</code></td><td>阻止冒泡（标准）</td></tr><tr class="odd"><td><code>e.cancelBubble</code></td><td>阻止冒泡（非标准，IE678）</td></tr></tbody></table><blockquote><p>[!warning] 非标准（IE678）方案只需要了解。</p></blockquote><h4 id="事件对象属性-e.target-和-this-的比较">4.4.1 事件对象属性 <code>e.target</code> 和 <code>this</code> 的比较</h4><ul><li><code>e.target</code>：<code>e.target</code> 返回的是触发事件的对象（元素），点击了哪个元素触发了事件，就返回那个元素。</li><li><code>this</code>：事件绑定的元素，这个事件函数的调用者。</li></ul><blockquote><p>[!TIP] 点击了某一个元素节点，这个节点不一定绑定了事件。但是由于 DOM 事件流的冒泡现象，会触发其父节点所绑定的事件。</p></blockquote><p>一个简单的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>456<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>789<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;ul&quot;</span>);</span><br><span class="language-javascript">        ul.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 点击 li 中的 123</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>); <span class="hljs-comment">// &lt;li&gt;...&lt;/li&gt;</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// &lt;ul&gt;...&lt;/ul&gt;</span></span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p></p><h4 id="阻止事件默认行为">4.4.2 阻止事件默认行为</h4><p>阻止 a 链接跳转: - 标准</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">a.<span class="hljs-property">addEventListener</span> (<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>- 兼容IE678<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">a.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    e.<span class="hljs-property">returnValue</span>;<br>    <span class="hljs-comment">// 或者</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p></p><h2 id="阻止事件冒泡">5. 阻止事件冒泡</h2><h3 id="阻止事件冒泡的两种方式">5.1 阻止事件冒泡的两种方式</h3><p>事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。 事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。</p><p>阻止事件冒泡： - 标准写法：利用事件对象里面的 <code>stopPropagation()</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">e.<span class="hljs-title function_">stopPropagation</span>();<br></code></pre></td></tr></table></figure>- 非标准写法：IE 6-8 利用事件对象 <code>cancelBubble</code> 属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">e.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p></p><blockquote><p>[!TIP] 给相应的子元素节点设置事件的 <code>stopPropagation()</code> 方法，相当于在这个节点阻断了事件冒泡。事件无法继续传递至父节点。</p></blockquote><p>一个例子：点击 son 子盒子，在设置阻断事件冒泡前，点击子盒子也触发了父盒子 fahter 的事件。设置了之后，打印台不再输出 father。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> father = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.father&quot;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> son = father.<span class="hljs-property">firstElementChild</span>;</span><br><span class="language-javascript">    father.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fahter&quot;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    son.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        e.<span class="hljs-title function_">stopPropagation</span>();</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="阻止事件冒泡的兼容性解决方案">5.2 阻止事件冒泡的兼容性解决方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(e &amp;&amp; e.<span class="hljs-property">stopPropagation</span>) &#123;<br>    e.<span class="hljs-title function_">stopPropagation</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事件委托代理委派">6. 事件委托（代理、委派）</h2><h3 id="前言">6.1 前言</h3><p>事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。生活中有如下场景： - 咱们班有100个学生，快递员有100个快递，如果一个个的送花费时间较长。同时每个学生领取的时候，也需 要排队领取，也花费时间较长，何如？ - <strong>解决方案</strong>：快递员把100个快递，委托给班主任，班主任把这些快递放到办公室，同学们下课自行领取即可。 - <strong>优势</strong>：快递员省事，委托给班主任就可以走了。同学们领取也方便，因为相信班主任。</p><p>事件冒泡本身的特性，<strong>会带来的坏处，也会带来的好处</strong>，需要我们灵活掌握。程序中也有如此场景：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应该有弹框在手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应该有弹框在手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应该有弹框在手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应该有弹框在手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应该有弹框在手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>点击每个 <code>li</code> 都会弹出对话框，以前需要给每个 <code>li</code> 注册事件，是非常辛苦的，而且访问 DOM 的次数越多，这就会延长整个页面的交互就绪时间。<p></p><h3 id="事件委托的原理">6.2 事件委托的原理</h3><ul><li><p>事件委托：也称为事件代理，在jQuery 里面称为事件委派。</p></li><li><p>原理：<strong>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</strong>。<br>以上案例：给 <code>ul</code> 注册点击事件，然后利用事件对象的 <code>target</code> 来找到当前点击的 <code>li</code>，因为点击 <code>li</code>，事件会冒泡到ul 上，<code>ul</code> 有注册事件，就会触发事件监听器。</p></li><li><p>作用：我们 <strong>只操作了一次 DOM ，提高了程序的性能。</strong></p></li></ul><h2 id="常用的鼠标事件">7. 常用的鼠标事件</h2><h3 id="常用的鼠标事件-1">7.1 常用的鼠标事件</h3><ol type="1"><li><p>禁止鼠标右键菜单<br><code>contextmenu</code> 主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;contextmenu&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><p></p></li><li><p>禁止鼠标选中（<code>selectstart</code> 开始选中）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;selectstart&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><p></p></li></ol><h3 id="鼠标事件对象">7.2 鼠标事件对象</h3><p><code>event</code> 对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象 <code>MouseEvent</code> 和键盘事件对象 <code>KeyboardEvent</code>。</p><table><thead><tr class="header"><th>鼠标事件对象</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>e.clientX</code></td><td>返回鼠标相对于浏览器窗口可视区的 <code>X</code> 坐标</td></tr><tr class="even"><td><code>e.clientY</code></td><td>返回鼠标相对于浏览器窗口可视区的 <code>Y</code> 坐标</td></tr><tr class="odd"><td><code>e.pageX</code></td><td>返回鼠标相对于文档页面的 <code>X</code> 坐标IE9+支持</td></tr><tr class="even"><td><code>e.pageY</code></td><td>返回鼠标相对于文档页面的 <code>Y</code> 坐标IE9+支持</td></tr><tr class="odd"><td><code>e.screenX</code></td><td>返回鼠标相对于电脑屏幕的 <code>X</code> 坐标</td></tr><tr class="even"><td><code>e.screenY</code></td><td>返回鼠标相对于电脑屏幕的 <code>Y</code> 坐标</td></tr></tbody></table><h2 id="常用的键盘事件">8. 常用的键盘事件</h2><h3 id="常用的键盘事件-1">8.1 常用的键盘事件</h3><p>事件除了使用鼠标触发，还可以使用键盘触发。</p><table><thead><tr class="header"><th>键盘事件</th><th>触发事件</th></tr></thead><tbody><tr class="odd"><td><code>onkeyup</code></td><td>某个键盘按键被松开时触发</td></tr><tr class="even"><td><code>onkeydown</code></td><td>某个键盘按键被按下时触发</td></tr><tr class="odd"><td><code>onkeypress</code></td><td>某个键盘按键被按下时触发，但是不识别功能键（<kbd>ctrl</kbd>、<kbd>shif</kbd>、箭头等）</td></tr></tbody></table><blockquote><p>[!warning] <code>onkeypress</code> 已废弃。虽然还是有浏览器支持，但是未来可能会停止支持。请使用 <code>keydown</code> 代替。</p></blockquote><h3 id="键盘事件对象">8.2 键盘事件对象</h3><table><thead><tr class="header"><th>键盘事件对象属性</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>key</code></td><td>返回物理按键的名称值（推荐使用）</td></tr><tr class="even"><td><code>keyCode</code></td><td>返回该键的ASCII值</td></tr></tbody></table><blockquote><p>[!warning] <code>keyCode</code> 已废弃: 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。一定要用，请使用 <code>key</code> 代替。——MDN</p></blockquote><h1 id="四bom-基础browser-object-model">四、BOM 基础（Browser Object Model）</h1><h2 id="bom-概述">1. BOM 概述</h2><h3 id="bom-概述-1">1.1 BOM 概述</h3><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 <code>window</code>。</p><p>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</p><p>BOM 缺乏标准，JavaScript 语法的标准化组织是ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分</p><h3 id="dom-vs-bom">1.2 DOM vs BOM</h3><table><thead><tr class="header"><th>DOM</th><th>BOM</th></tr></thead><tbody><tr class="odd"><td>文档对象模型</td><td>浏览器对象模型</td></tr><tr class="even"><td>DOM 就是把「文档」当做一个「对象」来看待</td><td>把「浏览器」当做一个「对象」来看待</td></tr><tr class="odd"><td>DOM 的顶级对象是 <code>document</code></td><td>BOM 的顶级对象是 <code>window</code></td></tr><tr class="even"><td>DOM 主要学习的是操作页面元素</td><td>BOM 学习的是浏览器窗口交互的一些对象</td></tr><tr class="odd"><td>DOM 是W3C 标准规范</td><td>BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差</td></tr></tbody></table><h3 id="bom-的构成">1.3 BOM 的构成</h3><p>BOM 比 DOM 更加强大，包含了 DOM。</p><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/bom1.3ss67gfjn6c.png" alt="bom1"><figcaption aria-hidden="true">bom1</figcaption></figure><p><strong><code>window</code> 对象是浏览器的顶级对象</strong>，它具有双重角色。 1. 它是JS 访问浏览器窗口的一个接口。 2. 它是一个全局对象。定义在全局作用域中的变量、函数都会变成 <code>window</code> 对象的属性和方法。 在调用的时候可以省略 <code>window</code>，前面学习的对话框都属于 <code>window</code> 对象方法，如 <code>alert()</code>、<code>prompt()</code> 等。</p><blockquote><p>[!TIP] <code>window</code> 下的一个特殊属性 <code>window.name</code>。</p></blockquote><h2 id="window-对象的常见事件">2. window 对象的常见事件</h2><h3 id="窗口加载事件">2.1 窗口加载事件</h3><h4 id="onload">2.1.1 onload</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);<br></code></pre></td></tr></table></figure><p></p><p><code>window.onload</code> 是窗口（页面）加载事件,当文档内容完全加载完成会触发该事件（<strong>包括图像、脚本文件、CSS文件等</strong>）, 就调用的处理函数。</p><p>注意： 1. 有了 <code>window.onload</code> 就可以把 JS 代码写到页面元素的上方，因为onload 是等页面内容全部加载完毕， 再去执行处理函数。 2. <code>window.onload</code> 传统注册事件方式只能写一次，如果有多个，会以最后一个 <code>window.onload</code> 为准。 3. 如果使用 <code>addEventListener</code> 则没有限制。</p><h4 id="domcontentloaded">2.1.2 DOMContentLoaded</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;);<br></code></pre></td></tr></table></figure><p><code>DOMContentLoaded</code> 事件触发时，仅当DOM加载完成，<strong>不包括样式表，图片，flash等等</strong>。（Ie9以上才支持。）</p><blockquote><p>[!TIP] 如果页面的图片很多的话, 从用户访问到 <code>onload</code> 触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 <code>DOMContentLoaded</code> 事件比较合适。</p></blockquote><h2 id="调整窗口大小事件">2.2 调整窗口大小事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;resize&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);<br></code></pre></td></tr></table></figure><p><code>window.onresize</code> 是调整窗口大小加载事件, 当触发时就调用的处理函数。 注意： 1. 只要窗口大小发生像素变化，就会触发这个事件。 2. 我们经常 <strong>利用这个事件完成响应式布局</strong>。 3. <code>window.innerWidth</code> 是当前屏幕的宽度</p><h2 id="定时器">3. 定时器</h2><h3 id="两种定时器">3.1 两种定时器</h3><p><code>window</code> 对象给我们提供了2 个非常好用的方法——定时器。 - <code>setTimeout()</code> - <code>setInterval()</code></p><h3 id="settimeout-定时器">3.2 setTimeout() 定时器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(调用函数 [, 延迟的毫秒数]);<br></code></pre></td></tr></table></figure><p><code>setTimeout()</code> 方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。</p><p>注意： 1. <code>window</code> 可以省略。 2. 这个调用函数可以 <strong>直接写函数，或者写函数名或者采取字符串'函数名()'</strong> 三种形式。第三种不推荐。 3. 延迟的毫秒数省略默认是 <code>0</code>，如果写，<strong>必须是毫秒</strong>。 4. 因为定时器可能有很多，所以我们 <strong>经常给定时器赋值一个标识符</strong>。</p><p><code>setTimeout()</code> 这个调用函数我们也称为 <strong>回调函数callback</strong>。 普通函数是按照代码顺序直接调用。而这个函数，需要等待时间，时间到了才去调用这个函数，因此称为回调函数。</p><p>简单理解：回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。</p><p>以前我们讲的 <code>element.onclick = function()&#123;&#125;</code> 或者 <code>element.addEventListener(“click”, fn);</code> 里面的函数也是回调函数。</p><h3 id="停止-settimeout-定时器">3.3 停止 setTimeout() 定时器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">clearTimeout</span>(timeoutID)<br></code></pre></td></tr></table></figure><p><code>clearTimeout()</code> 方法用于取消先前通过调用 <code>setTimeout()</code> 建立的定时器。</p><blockquote><p>[!TIP] 1. <code>window</code> 可以省略。 2. 里面的 <strong>参数就是定时器的标识符</strong>。</p></blockquote><h3 id="setinterval-定时器">3.4 setInterval() 定时器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setInterval</span>(回调函数 [, 间隔的毫秒数]);<br></code></pre></td></tr></table></figure><p><code>setInterval()</code> 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。</p><p>注意： 1. <code>window</code> 可以省略。 2. 这个调用函数可以 <strong>直接写函数，或者写函数名或者采取字符串'函数名()'</strong> 三种形式。 3. 间隔的毫秒数省略默认是 <code>0</code>，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。 4.因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。 5. <strong>第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次</strong>。</p><h3 id="倒计时案例分析">3.4 倒计时案例分析</h3><blockquote><p>[!TIP] 定时器案例分析：三个盒子分别放时、分、秒。 1. 这个倒计时是不断变化的，因此需要定时器来自动变化（setInterval） 2. 三个黑色盒子里面分别存放时分秒 3. 三个黑色盒子利用innerHTML 放入计算的小时分钟秒数 4. 第一次执行也是间隔毫秒数，因此刚刷新页面会有空白 5. 最好采取封装函数的方式，这样可以先调用一次这个函数，防止刚开始刷新页面有空白问题</p></blockquote><h3 id="停止-setinterval-定时器">3.5 停止 setInterval() 定时器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">clearInterval</span>(intervalID);<br></code></pre></td></tr></table></figure><p><code>clearInterval()</code> 方法取消了先前通过调用 <code>setInterval()</code> 建立的定时器。</p><p>注意： 1. <code>window</code> 可以省略。 2. 里面的参数就是定时器的标识符。</p><h3 id="this-指向问题">3.6 this 指向问题</h3><p><code>this</code> 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 <code>this</code> 到底指向谁，一般情况下的最终指向的是那个调用它的对象 现阶段，我们先了解一下几个 <code>this</code> 指向： 1. 全局作用域或者普通函数中 <code>this</code> 指向全局对象 <code>window</code>（注意定时器里面的 <code>this</code> 指向 <code>window</code>） 2. 方法调用中谁调用 <code>this</code> 指向谁 3. 构造函数中 <code>this</code> 指向构造函数的实例</p><h2 id="js-执行机制">4. JS 执行机制</h2><h3 id="js-是单线程">4.1 JS 是单线程</h3><p>JavaScript 语言的一大特点就是 <strong>单线程</strong>，也就是说，<strong>同一个时间只能做一件事</strong>。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作DOM 而诞生的。比如我们对某个DOM 元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。</p><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h3 id="同步和异步概述">4.2 同步和异步概述</h3><p>先来看一个问题：以下代码执行的结果是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p></p><p>那么以下代码执行的结果又是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p></p><p>为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创 建多个线程。于是，JS 中出现了 <strong>同步和异步</strong>。</p><h4 id="同步">4.2.1 同步</h4><p>前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做 法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。</p><h4 id="异步">4.2.2 异步</h4><p>你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做 饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。</p><p><strong>他们的本质区别：这条流水线上各个流程的执行顺序不同</strong>。</p><h3 id="同步和异步任务">4.3 同步和异步任务</h3><h4 id="同步任务">4.3.1 同步任务</h4><p>同步任务都在主线程上执行，形成一个 <strong>执行栈</strong>。</p><h4 id="异步任务">4.3.2 异步任务</h4><p>JS 的异步是通过回调函数实现的。</p><p>一般而言，异步任务有以下三种类型：</p><ol type="1"><li>普通事件，如 <code>click</code>、<code>resize</code> 等</li><li>资源加载，如 <code>load</code>、<code>error</code> 等</li><li>定时器，包括 <code>setInterval</code>、<code>setTimeout</code> 等异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）。</li></ol><h3 id="js-执行机制-1">4.4 JS 执行机制</h3><ol type="1"><li>先执行 <strong>执行栈中的同步任务</strong>。</li><li>异步任务（回调函数）放入任务队列中。</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取 <strong>任务队列</strong> 中的异步任务，于是被读取的异步务结束等待状态，进入执行栈，开始执行。</li></ol><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/bom2.40uo3yu1dv20.png" alt="bom2"><figcaption aria-hidden="true">bom2</figcaption></figure><p>举例分析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>  (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;click&quot;</span>);<br>&#125;);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">3000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>- 若不触发点击事件，结果将依次输出 <code>1</code>、<code>2</code>、<code>3</code>； - 若点击事件在 3 秒前触发，则依次输出 <code>1</code>、<code>2</code>、<code>click</code>、<code>3</code> - 若点击事件在 3 秒后触发，则依次输出 <code>1</code>、<code>2</code>、<code>3</code>、<code>click</code><p></p><h3 id="事件循环">4.5 事件循环</h3><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为 <strong>事件循环（event loop）</strong>。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/bom3.720uz5f9vh00.png"></p><h2 id="location-对象">5. location 对象</h2><h3 id="什么是-location-对象">5.1 什么是 location 对象</h3><p><code>window</code> 对象给我们提供了一个 <code>location</code> 属性用于 <strong>获取或设置窗体的URL</strong>，并且可以用于 <strong>解析 URL</strong>。因为这个属性返回的是一个对象，所以我们将这个属性也称为 <code>location</code> 对象。</p><h3 id="url">5.2 URL</h3><p>统一资源定位符（Uniform Resource Locator, URL）是互联网上标准资源的地址。互联网上的每个文件都有 一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 URL 的一般语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">格式<br>protocol://host[:port]/path/[?query]#fragment<br>举例<br>http://www.itcast.cn/index.html?name=andy&amp;age=18#link<br></code></pre></td></tr></table></figure><p></p><table><thead><tr class="header"><th>组成</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>protocol</code></td><td>通信协议（http、ftp）</td></tr><tr class="even"><td><code>host</code></td><td>主机（域名）</td></tr><tr class="odd"><td><code>port</code></td><td>端口号（可选），省略时使用方案的默认端口，如http默认端口80</td></tr><tr class="even"><td><code>path</code></td><td>路径，由零或多个 <code>/</code> 隔开的字符串，一般表示主机上的一个目录或文件地址</td></tr><tr class="odd"><td><code>query</code></td><td>参数，以键值对的形式，通过 <code>&amp;</code> 符号分隔开</td></tr><tr class="even"><td><code>fragment</code></td><td>片段，<code>#</code> 后面内容，常见于链接、锚点</td></tr></tbody></table><h3 id="location-对象的属性">5.3 location 对象的属性</h3><table><thead><tr class="header"><th>location对象属性</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>location.href</code></td><td>获取或者设置 整个URL</td></tr><tr class="even"><td><code>location.host</code></td><td>返回主机（域名）</td></tr><tr class="odd"><td><code>location.port</code></td><td>返回端口号，未写则返回空字符串</td></tr><tr class="even"><td><code>location.pathname</code></td><td>返回路径</td></tr><tr class="odd"><td><code>location.search</code></td><td>返回参数</td></tr><tr class="even"><td><code>location.hash</code></td><td>返回片段，<code>#</code> 后面内容，常见于链接、锚点</td></tr></tbody></table><blockquote><p>[!TIP] 重点记住：<code>href</code> 和 <code>search</code></p></blockquote><h3 id="location-对象的方法">5.4 location 对象的方法</h3><table><thead><tr class="header"><th>location对象方法</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>location.assign()</code></td><td>跟 <code>href</code> 一样，可以跳转页面（也称为重定向页面）</td></tr><tr class="even"><td><code>location.replace()</code></td><td>替换当前页面，因为不记录历史，所以不能后退页面</td></tr><tr class="odd"><td><code>location.reload()</code></td><td>重新加载页面，相当于刷新按钿或者 f5 如果参数为 <code>true</code> 强制刷新 ctrl+f5</td></tr></tbody></table><h2 id="navigator-对象">6. navigator 对象</h2><p><code>navigator</code> 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 <code>userAgent</code>，该属性可以返回由客 户机发送服务器的 <code>user-agent</code> 头部的值。 下面前端代码可以判断用户那个终端打开页面，实现跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>((navigator.<span class="hljs-property">userAgent</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//手机</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//电脑</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="history-对象">7. history 对象</h2><p><code>window</code> 对象给我们提供了一个 <code>history</code> 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</p><table><thead><tr class="header"><th><code>history</code>对象方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>back()</code></td><td>网页地址后退功能</td></tr><tr class="even"><td><code>forward()</code></td><td>前进功能</td></tr><tr class="odd"><td><code>go(参数)</code></td><td>前进后退功能，参数为 <code>1</code>，前进一个页面，<code>-1</code> 后退一个页面</td></tr></tbody></table><p><code>history</code> 对象一般在实际开发中比较少用，但是会在一些OA 办公系统中见到。</p><h1 id="五pc-端网页特效">五、PC 端网页特效</h1><blockquote><p>[!TIP] 在前面学习了JS基础、DOM 和 BOM 的基本操作后，这部分主要学习这些知识的拓展应用。</p></blockquote><h2 id="元素偏移量-offset-系列">1. 元素偏移量 offset 系列</h2><h3 id="offset-概述">1.1 offset 概述</h3><p><code>offset</code> 翻译过来就是偏移量，我们使用 <code>offset</code> 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。 - 获得元素距离带有定位父元素的位置 - 获得元素自身的大小（宽度高度） - 注意：返回的数值都不带单位</p><p><code>offset</code> 系列常用属性： <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/offset1.33r96uboi540.jpg"></p><h3 id="offset-与-style-区别">1.2 offset 与 style 区别</h3><h4 id="offset">1.2.1 offset</h4><ul><li><code>offset</code> 可以得到任意样式表中的样式值</li><li><code>offset</code> 系列获得的数值是没有单位的</li><li><code>offsetWidt</code>h 包含 <code>padding+border+width</code></li><li><code>offsetWidth</code> 等属性是只读属性，只能获取不能赋值</li><li><strong>所以，我们想要获取元素大小位置，用 <code>offset</code>更合适</strong></li></ul><h4 id="style">1.2.2 style</h4><ul><li><code>style</code> 只能得到行内样式表中的样式值</li><li><code>style.width</code> 获得的是带有单位的字符串</li><li><code>style.width</code> 获得不包含 <code>padding</code> 和 <code>border</code> 的值</li><li><code>style.width</code> 是可读写属性，可以获取也可以赋值</li><li><strong>所以，我们想要给元素更改值，则需要用 <code>style</code> 改变</strong></li></ul><h3 id="案例1获取鼠标在盒子内部的坐标">1.3 案例1：获取鼠标在盒子内部的坐标</h3><h4 id="分析">1.3.1 分析</h4><ol type="1"><li>我们在盒子内点击，想要得到鼠标距离盒子左右的距离。</li><li>首先得到鼠标在页面中的坐标（e.pageX, e.pageY）</li><li>其次得到盒子在页面中的距离( box.offsetLeft, box.offsetTop)</li><li>用鼠标距离页面的坐标减去盒子在页面中的距离，得到鼠标在盒子内的坐标</li><li>如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动事件mousemove</li></ol><h4 id="代码">1.3.2 代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.box&quot;</span>);<br>box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mousemove&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">let</span> x = e.<span class="hljs-property">pageX</span> - box.<span class="hljs-property">offsetLeft</span>;<br>    <span class="hljs-keyword">let</span> y = e.<span class="hljs-property">pageY</span> - box.<span class="hljs-property">offsetTop</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span> =  <span class="hljs-string">&quot;鼠标距离盒子坐标是：(&quot;</span> +x + <span class="hljs-string">&quot;, &quot;</span> + y + <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="案例2模态框拖拽">1.4 案例2：模态框拖拽</h3><p>弹出框，我们也称为模态框。 1. 点击弹出层，会弹出模态框，并且显示灰色半透明的遮挡层。 2. 点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。 3. 鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。 4. 鼠标松开，可以停止拖动模态框移动。</p><h4 id="分析-1">1.4.1 分析</h4><ol type="1"><li>点击弹出层，模态框和遮挡层就会显示出来 display:block;</li><li>点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none;</li><li>在页面中拖拽的原理：鼠标按下并且移动，之后松开鼠标</li><li>触发事件是鼠标按下 mousedown，鼠标移动 mousemove 鼠标松开 mouseup</li><li>拖拽过程: 鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框可以跟着鼠标走了</li><li>鼠标按下触发的事件源是最上面一行，就是id 为 title</li><li>鼠标的坐标减去鼠标在盒子内的坐标，才是模态框真正的位置。</li><li>鼠标按下，我们要得到鼠标在盒子的坐标。</li><li>鼠标移动，就让模态框的坐标设置为：鼠标坐标减去盒子坐标即可，注意移动事件写到按下事件里面。</li><li>鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除</li></ol><h4 id="代码-1">1.4.2 代码</h4><blockquote><p>[!TIP] 我用阿里云盘分享了「模态框拖拽案例」，你可以不限速下载，链接：https://www.aliyundrive.com/s/uQHM8DpTh5F</p></blockquote><h3 id="案例2京东放大镜">1.5 案例2：京东放大镜</h3><blockquote><p>[!TIP] 代码：我用阿里云盘分享了「04-京东放大镜效果」，你可以不限速下载🚀 链接：https://www.aliyundrive.com/s/M9eJn6rAR28</p></blockquote><h2 id="元素可视区-client-系列">2. 元素可视区 client 系列</h2><h3 id="定义-1">2.1 定义</h3><p><code>client</code> 翻译过来就是客户端，我们使用 <code>client</code> 系列的相关属性来获取元素可视区的相关信息。通过<code>client</code> 系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p><table><thead><tr class="header"><th>client系列属性</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>element.clientTop</code></td><td>返回元素上边框的大小</td></tr><tr class="even"><td><code>element.clientLeft</code></td><td>返回元素左边框大大小</td></tr><tr class="odd"><td><code>element.clientWidth</code></td><td>返回自身包括 <code>padding</code>、内容区的宽度，不含边框，返回数值不带单位</td></tr><tr class="even"><td><code>element.clientHeight</code></td><td>返回自身包括 <code>padding</code>、内容区的高度，不含边框，返回数值不带单位</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/client1.6bor0qa82lk0.png"></p><h3 id="案例淘宝-flexible.js-源码分析">2.2 案例：淘宝 flexible.js 源码分析</h3><p>flexible 项目地址：https://github.com/amfe/lib-flexible</p><h4 id="立即执行函数">2.2.1 立即执行函数</h4><p>立即执行函数是指函数定义好后，不需要调用直接执行。即一引入 JS 文件，则该函数自动执行。</p><p>语法：<code>(function() &#123;&#125;)()</code> 或者 <code>(function()&#123;&#125;())</code></p><p>主要作用： - 创建一个独立的作用域 - 避免了命名冲突问题</p><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);&#125;)(); <span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure>可以传参数：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);&#125;)(<span class="hljs-number">10</span>); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p></p><h4 id="pageshow-事件">2.2.2 pageShow 事件</h4><p>下面三种情况都会刷新页面都会触发load 事件。 1. a标签的超链接 2. F5或者刷新按钮（强制刷新） 3. 前进后退按钮</p><p>但是火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了 DOM 和 JavaScript 的状态；实际上是将整个页面都保存在了内存里。</p><p>所以此时后退按钮不能刷新页面。</p><p>此时可以使用 <code>pageshow</code> 事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页 面中，<code>pageshow</code> 会在 <code>load</code> 事件触发后触发；根据事件对象中的 <code>persisted</code> 来判断是否是缓存中的页面触发的<code>pageshow</code> 事件，注意这个事件给 <code>window</code> 添加。</p><blockquote><p>[!warning] 多个立即执行函数间要加分号 <code>;</code> 隔开。</p></blockquote><h2 id="元素滚动-scroll-系列">3. 元素滚动 scroll 系列</h2><h3 id="元素scroll-系列属性">3.1 元素scroll 系列属性</h3><p><code>scroll</code> 翻译过来就是滚动的，我们使用 <code>scroll</code> 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p><table><thead><tr class="header"><th>scroll系列属性</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>element.scrollTop</code></td><td>返回被卷上去的上侧距离，返回数值不带单位</td></tr><tr class="even"><td><code>element.scrollLeft</code></td><td>返回被卷上去的左侧距离，返回数值不带单位</td></tr><tr class="odd"><td><code>element.scrollWidth</code></td><td>返回自身实际宽度，不含边框，返回数值不带单位</td></tr><tr class="even"><td><code>element.scrollHeight</code></td><td>返回自身实际高度，不含边框，返回数值不带单位</td></tr></tbody></table><p>如下图所示 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/scroll1.4xrvppmwt800.png"></p><h3 id="页面被卷去的头部">3.2 页面被卷去的头部</h3><p>如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏 掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 <code>onscroll</code> 事件。</p><p><strong>获取页面被卷去的头部</strong>： - <strong>页面</strong> 被卷去的头部：可以通过 <code>window.pageYOffset</code> 获得，如果是被卷去的左侧 <code>window.pageXOffset</code> - 注意，元素被卷去的头部是 <code>element.scrollTop</code>，左侧 <code>element.scrollLeft</code></p><h3 id="案例仿淘宝固定右侧侧边栏">3.3 案例：仿淘宝固定右侧侧边栏</h3><blockquote><p>[!TIP] 我用阿里云盘分享了「05-仿淘宝侧边栏.html」，你可以不限速下载🚀 链接：https://www.aliyundrive.com/s/c1sic4RxuLf</p></blockquote><p>需求（自己动手实践）： 1. 原先侧边栏是绝对定位 2. 当页面滚动到一定位置，侧边栏改为固定定位 3. 页面继续滚动，会让返回顶部显示出来</p><p>要点： 1. 需要用到页面滚动事件 <code>scroll</code> 因为是页面滚动，所以事件源是 <code>document</code> 2. 滚动到某个位置，就是判断页面被卷去的上部值。 3. 页面被卷去的头部：可以通过 <code>window.pageYOffset</code> 获得如果是被卷去的左侧 <code>window.pageXOffset</code> 4. 注意，元素被卷去的头部是 <code>element.scrollTop</code> , 如果是页面被卷去的头部则是 <code>window.pageYOffset</code> 5. 其实这个值可以通过盒子的 <code>offsetTop</code> 可以得到，如果大于等于这个值，就可以让盒子固定定位了</p><h3 id="三大系列总结">3.4 三大系列总结</h3><h4 id="对比">3.4.1 对比</h4><table><thead><tr class="header"><th>三大系列大小对比</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>element.offsetWidth</code></td><td>返回自身包括 <code>padding</code>、边框、内容区的宽度，返回数值不带单位</td></tr><tr class="even"><td><code>element.clientWidth</code></td><td>返回自身包括 <code>padding</code>、内容区的宽度，不含边框，返回数值不带单位</td></tr><tr class="odd"><td><code>element.scrollWidth</code></td><td>返回自身实际的宽度，不含边框，返回数值不带单位</td></tr></tbody></table><h4 id="主要用法">3.4.2 主要用法</h4><ol type="1"><li><code>offset</code> 系列经常用于获得元素位置 <code>offsetLeft</code>、<code>offsetTop</code></li><li><code>client</code> 经常用于获取元素大小 <code>clientWidth</code> 、<code>clientHeight</code></li><li><code>scroll</code> 经常用于获取滚动距离 <code>scrollTop</code>、<code>scrollLeft</code></li><li>注意页面滚动的距离通过 <code>window.pageXOffset</code> 获得</li></ol><h4 id="mouseenter-和-mouseover-的区别">3.5 mouseenter 和 mouseover 的区别</h4><ul><li>当鼠标移动到元素上时就会触发 <code>mouseenter</code> 事件</li><li>类似 <code>mouseover</code>，它们两者之间的差别是</li><li><code>mouseover</code> 鼠标经过自身盒子会触发，经过子盒子还会触发。<code>mouseenter</code> 只会经过自身盒子触发</li><li>之所以这样，就是因为 <code>mouseenter</code> 不会冒泡</li><li>跟 <code>mouseenter</code> 搭配鼠标离开 <code>mouseleave</code> 同样不会冒泡</li></ul><h2 id="动画函数封装">4. 动画函数封装</h2><h3 id="动画实现原理">4.1 动画实现原理</h3><p>核心原理：通过定时器 <code>setInterval()</code> 不断移动盒子位置。 实现步骤： 1. 获得盒子当前位置 2. 让盒子在当前位置加上 1 个移动距离 3. 利用定时器不断重复这个操作 4. 加一个结束定时器的条件 5. 注意此元素需要添加定位（<code>position: absolute</code>），才能使用 <code>element.style.left</code></p><h3 id="动画函数简单封装">4.2 动画函数简单封装</h3><p>注意函数需要传递 2 个参数，<strong>动画对象和移动到的距离</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">obj, target</span>) &#123;<br>    <span class="hljs-comment">// 设置定时器</span><br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">offsetLeft</span> &lt;= target) &#123;<br>            obj.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = obj.<span class="hljs-property">offsetLeft</span> + <span class="hljs-number">1</span> + <span class="hljs-string">&#x27;px&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 清除定时器</span><br>            <span class="hljs-built_in">clearInterval</span>(timer);<br>        &#125;<br>    &#125;, <span class="hljs-number">30</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动画函数给不同元素记录不同定时器">4.3 动画函数给不同元素记录不同定时器</h3><p>如果多个元素都使用这个动画函数，每次都要 <code>var</code> 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。</p><p>核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。</p><p>举例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 封装动画函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">obj, target</span>) &#123;<br>    <span class="hljs-comment">// 给不同节点对象 obj 设置定时器</span><br>    obj.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">offsetLeft</span> &lt;= target) &#123;<br>            obj.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = obj.<span class="hljs-property">offsetLeft</span> + <span class="hljs-number">1</span> + <span class="hljs-string">&#x27;px&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 清除对象自己的定时器</span><br>            <span class="hljs-built_in">clearInterval</span>(obj.<span class="hljs-property">timer</span>);<br>        &#125;<br>    &#125;, <span class="hljs-number">30</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p></p><h3 id="缓动效果原理">4.4 缓动效果原理</h3><p>之前讲的是匀速动画：<span class="math display">\[盒子当前位置 = 盒子当前位置 + 固定值\]</span></p><p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来<br>思路： 1. 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。 2. <strong>核心算法</strong>：<span class="math display">\[每次移动的距离步长 = (目标值 - 现在的位置) / 10 \]</span> 3. 停止的条件是：让当前盒子位置等于目标位置就停止定时器 4. 注意步长值需要取整</p><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">obj, target</span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(obj.<span class="hljs-property">timer</span>);<br>    obj.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 缓冲动画核心算法</span><br>        <span class="hljs-keyword">let</span> step = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>((target - obj.<span class="hljs-property">offsetLeft</span>) / <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">offsetLeft</span> === target) &#123;<br>            <span class="hljs-built_in">clearInterval</span>(obj.<span class="hljs-property">timer</span>);<br>        &#125;<br>        obj.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = obj.<span class="hljs-property">offsetLeft</span> + step + <span class="hljs-string">&#x27;px&#x27;</span>;<br>    &#125;, <span class="hljs-number">30</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p></p><h3 id="动画函数多个目标值之间移动">4.5 动画函数多个目标值之间移动</h3><p>可以让动画函数从 <code>800</code> 移动到 <code>500</code>。<br>当我们点击按钮时候，判断步长是正值还是负值： 1. 如果是正值，则步长往大了取整（<code>Math.ceil()</code>） 2. 如果是负值，则步长向小了取整（<code>Math.floor()</code>）</p><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">obj, target</span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(obj.<span class="hljs-property">timer</span>);<br>    obj.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 缓冲动画核心算法</span><br>        <span class="hljs-keyword">let</span> step = target - obj.<span class="hljs-property">offsetLeft</span>;<br>        <span class="hljs-comment">// 左右移动步值正负处理</span><br>        step = step &gt;= <span class="hljs-number">0</span> ?  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(step / <span class="hljs-number">10</span>) :  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(step / <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">offsetLeft</span> === target) &#123;<br>            <span class="hljs-built_in">clearInterval</span>(obj.<span class="hljs-property">timer</span>);<br>        &#125;<br>        obj.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = obj.<span class="hljs-property">offsetLeft</span> + step + <span class="hljs-string">&#x27;px&#x27;</span>;<br>    &#125;, <span class="hljs-number">30</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p></p><h3 id="动画函数添加回调函数">4.6 动画函数添加回调函数</h3><ul><li><p><strong>回调函数原理</strong>：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后， 再执行传进去的这个函数，这个过程就叫做 <strong>回调（<code>callback</code>）</strong>。</p></li><li><p><strong>回调函数写的位置：定时器结束的位置</strong>。</p></li></ul><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 增加回调函数形参 callback</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">obj, target, callback</span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(obj.<span class="hljs-property">timer</span>);<br>    obj.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 缓冲动画核心算法</span><br>        <span class="hljs-keyword">let</span> step = target - obj.<span class="hljs-property">offsetLeft</span>;<br>        <span class="hljs-comment">// 左右移动步值正负处理</span><br>        step = step &gt;= <span class="hljs-number">0</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(step / <span class="hljs-number">10</span>) : <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(step / <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">offsetLeft</span> === target) &#123;<br>            <span class="hljs-built_in">clearInterval</span>(obj.<span class="hljs-property">timer</span>);<br>            <span class="hljs-comment">// 判断，回调函数 callback 存在则调用</span><br>            <span class="hljs-keyword">if</span> (callback) &#123;<br>                <span class="hljs-title function_">callback</span>();<br>            &#125;<br>        &#125;<br>        obj.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = obj.<span class="hljs-property">offsetLeft</span> + step + <span class="hljs-string">&#x27;px&#x27;</span>;<br>    &#125;, <span class="hljs-number">30</span>);<br>&#125;<br><span class="hljs-comment">// 回调函数作为实参传入</span><br><span class="hljs-title function_">animate</span>(span, <span class="hljs-number">800</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    span.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;pink&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="动画函数封装到单独js文件里面">4.7 动画函数封装到单独JS文件里面</h3><p>因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可。 1. 单独新建一个 JS 文件。 2. HTML文件引入 JS 文件。</p><h2 id="常见网页特效案例">5. 常见网页特效案例</h2><h3 id="案例1轮播图">5.1 案例1：轮播图</h3><blockquote><p>[!TIP] 轮播图是JS的一个经典案例，建议自己动手实践一遍，项目源码地址：https://hacker-c.github.io/PinYouGou-Shopping/</p></blockquote><p>轮播图也称为焦点图，是网页中比较常见的网页特效。</p><p>功能需求： 1. 鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。 2. 点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。 3. 图片播放的同时，下面小圆圈模块跟随一起变化。 4. 点击小圆圈，可以播放相应图片。 5. 鼠标不经过轮播图，轮播图也会自动播放图片。 6. 鼠标经过，轮播图模块，自动播放停止。</p><details style="cursor:pointer"><summary>思路分析点击展开</summary><h4 id="总体分析">5.1.1 总体分析</h4><ol type="1"><li>因为 js 较多，我们单独新建 js 文件夹，再新建 js 文件，引入页面中。</li><li>此时需要添加 <code>load</code> 事件。</li><li>鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。</li><li>显示隐藏 <code>display</code> 按钮。</li></ol><h4 id="动态生成小圆圈">5.1.2 动态生成小圆圈</h4><ol type="1"><li>核心思路：小圆圈的个数要跟图片张数一致</li><li>所以首先先得到 <code>ul</code> 里面图片的张数（图片放入 <code>li</code> 里面，所以就是 <code>li</code> 的个数）</li><li>利用循环动态生成小圆圈（这个小圆圈要放入 <code>ol</code> 里面）</li><li>创建节点 <code>createElement('li')</code></li><li>插入节点 <code>ol.appendChild(li)</code></li><li>第一个小圆圈需要添加 <code>current</code> 类</li></ol><h4 id="小圆圈的排他思想">5.1.3 小圆圈的排他思想</h4><ol type="1"><li>点击当前小圆圈，就添加 <code>current</code> 类</li><li>其余的小圆圈就移除这个 <code>current</code> 类</li><li>注意：我们在刚才生成小圆圈的同时，就可以直接绑定这个点击事件了。</li></ol><h4 id="点击小圆圈滚动图片">5.1.4 点击小圆圈滚动图片</h4><ol type="1"><li>此时用到 <code>animate</code> 动画函数，将 js 文件引入（注意，因为 index.js 依赖 animate.js 所以，animate.js 要写到index.js 上面）</li><li>使用动画函数的前提，该元素必须有定位</li><li>注意是 <code>ul</code> 移动而不是小 <code>li</code></li><li>滚动图片的核心算法：点击某个小圆圈，就让图片滚动小圆圈的索引号乘以图片的宽度做为 <code>ul</code> 移动距离</li><li>此时需要知道小圆圈的索引号，我们可以在生成小圆圈的时候，给它设置一个自定义属性，点击的时候获取这个自定 义属性即可。</li></ol><h4 id="右侧按钮功能">5.1.5 右侧按钮功能</h4><p>点击右侧按钮一次，就让图片滚动一张。</p><ol type="1"><li>声明一个变量 <code>num</code>，点击一次，自增 1，让这个变量乘以图片宽度，就是ul 的滚动距离。</li><li>图片无缝滚动原理</li><li>把 <code>ul</code> 第一个 <code>li</code> 复制一份，放到 <code>ul</code> 的最后面</li><li>当图片滚动到克隆的最后一张图片时，让 <code>ul</code> 快速的、不做动画的跳到最左侧：<code>left</code> 为0</li><li>同时 <code>num</code> 赋值为0，可以从新开始滚动图片了</li></ol><h4 id="克隆第一张图片">5.1.6 克隆第一张图片</h4><ol type="1"><li>克隆 <code>ul</code> 第一个 <code>li.cloneNode()</code> 加 <code>true</code> 深克隆复制里面的子节点（<code>false</code>：浅克隆）</li><li>添加到 <code>ul</code> 最后面 <code>appendChild</code></li></ol><h4 id="点击右侧按钮小圆圈跟随变化">5.1.7 点击右侧按钮，小圆圈跟随变化</h4><ol type="1"><li>最简单的做法是再声明一个变量 <code>circle</code>，每次点击自增1，注意，左侧按钮也需要这个变量，因此要声明全局变量。</li><li>但是图片有5张，我们小圆圈只有4个少一个，必须加一个判断条件</li><li>如果 <code>circle == 4</code> 就从新复原为 0</li></ol><h4 id="自动播放功能">5.1.8 自动播放功能</h4><ol type="1"><li>添加一个定时器</li><li>自动播放轮播图，实际就类似于点击了右侧按钮</li><li>此时我们使用手动调用右侧按钮点击事件 <code>arrow_r.click()</code></li><li>鼠标经过 <code>focus</code> 就停止定时器</li><li>鼠标离开 <code>focus</code> 就开启定时器</li></ol><h4 id="节流阀">5.1.9 节流阀</h4><ul><li>功能：<strong>防止轮播图按钮连续点击造成播放过快。</strong></li><li>原理：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</li><li>思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。<ol type="1"><li>开始设置一个变量：<code>var flag = true;</code></li><li><code>if(flag) &#123;flag = false; do something&#125;</code>：关闭水龙头</li><li>利用回调函数动画执行完毕：<code>flag = true</code> 打开水龙头</li></ol></li></ul></details><h3 id="案例2返回顶部">5.2 案例2：返回顶部</h3><h4 id="window.scroll">5.2.1 window.scroll</h4><p>滚动窗口至文档中的特定位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scroll</span>(x, y)<br></code></pre></td></tr></table></figure>注意：里面的 <code>x</code> 和 <code>y</code> 不跟单位，直接写数字。<p></p><h4 id="带有动画的返回顶部">5.2.2 带有动画的返回顶部</h4><ol type="1"><li>此时可以继续使用我们封装的动画函数</li><li>只需要把所有的 <code>left</code> 相关的值改为跟页面垂直滚动距离相关就可以了</li><li>页面滚动了多少，可以通过 <code>window.pageYOffset</code> 得到</li><li>最后是页面滚动，使用 <code>window.scroll(x, y)</code></li></ol><h4 id="修改后的缓存动画函数">5.2.3 修改后的缓存动画函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">obj, target, callback</span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(obj.<span class="hljs-property">timer</span>);<br>    obj.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 缓冲动画核心算法</span><br>        <span class="hljs-keyword">let</span> step = target - <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageYOffset</span>;<br>        step = step &gt;= <span class="hljs-number">0</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(step / <span class="hljs-number">10</span>) : <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(step / <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">pageYOffset</span> === target) &#123;<br>            <span class="hljs-built_in">clearInterval</span>(obj.<span class="hljs-property">timer</span>);<br>            callback &amp;&amp; <span class="hljs-title function_">callback</span>();<br>        &#125;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scroll</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageYOffset</span> + step);<br>    &#125;, <span class="hljs-number">30</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">animate</span>(<span class="hljs-variable language_">window</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p></p><h3 id="案例3筋斗云">5.3 案例3：筋斗云</h3><h4 id="效果">5.3.1 效果</h4><ul><li>鼠标经过某个小 <code>li</code>，筋斗云跟这到当前小 <code>li</code> 位置</li><li>鼠标离开这个小 <code>li</code>，筋斗云复原为原来的位置</li><li>鼠标点击了某个小 <code>li</code>，筋斗云就会留在点击这个小 <code>li</code> 的位置</li></ul><h4 id="实现">5.3.2 实现</h4><ol type="1"><li>利用动画函数做动画效果</li><li>原先筋斗云的起始位置是 <code>0</code></li><li>鼠标经过某个小 <code>li</code>，把当前小 <code>li</code> 的 <code>offsetLeft</code> 位置做为目标值即可</li><li>鼠标离开某个小 <code>li</code>，就把目标值设为 <code>0</code></li><li>如果点击了某个小 <code>li</code>，就把 <code>li</code> 当前的位置存储起来，做为筋斗云的起始位置</li></ol><p>核心代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> current = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">// (1) 鼠标经过把当前小li 的位置做为目标值</span><br>    lis[i].<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseenter&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">animate</span>(cloud, <span class="hljs-variable language_">this</span>.<span class="hljs-property">offsetLeft</span>);<br>    &#125;);<br>    <span class="hljs-comment">// (2) 鼠标离开就回到起始的位置 </span><br>    lis[i].<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseleave&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">animate</span>(cloud, current);<br>    &#125;);<br>    <span class="hljs-comment">// (3) 当我们鼠标点击，就把当前位置做为目标值</span><br>    lis[i].<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">offsetLeft</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p></p><h1 id="六-移动端网页特效">六、 移动端网页特效</h1><h2 id="触摸事件">1. 触摸事件</h2><h3 id="触屏事件概述">1.1 触屏事件概述</h3><p>移动端浏览器兼容性较好，我们不需要考虑以前JS 的兼容性问题，可以放心的使用原生JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 <code>touch</code>（也称触摸事件），Android 和IOS 都有。</p><p><code>touch</code> 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控 笔）对屏幕或者触控板操作。</p><p>常见的触屏事件如下：</p><table><thead><tr class="header"><th>触屏</th><th>touch 事件说明</th></tr></thead><tbody><tr class="odd"><td><code>touchstart</code></td><td>手指触摸到一个 DOM 元素时触发</td></tr><tr class="even"><td><code>touchmove</code></td><td>手指在一个 DOM 元素上滑动时触发</td></tr><tr class="odd"><td><code>touchend</code></td><td>手指从一个 DOM 元素上移开时触发</td></tr></tbody></table><h3 id="触摸事件对象touchevent">1.2 触摸事件对象（<code>TouchEvent</code>）</h3><p>TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等</p><p><code>touchstart</code>、<code>touchmove</code>、<code>touchend</code> 三个事件都会各自有事件对象。</p><p>触摸事件对象重点我们看三个常见对象列表：</p><table><thead><tr class="header"><th>触摸列表</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>touches</code></td><td>正在触摸屏幕的所有手指的一个列表</td></tr><tr class="even"><td><code>targetTouches</code></td><td>正在触摸当前 DOM 元素上的手指的一个列表</td></tr><tr class="odd"><td><code>changedTouches</code></td><td>手指状态发生了改变的列表，从无到有，从有到无变化</td></tr></tbody></table><p><font color="red">因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</font></p><h3 id="移动端拖动元素">1.3 移动端拖动元素</h3><ol type="1"><li><code>touchstart、touchmove、touchend</code> 可以实现拖动元素</li><li>但是拖动元素需要当前手指的坐标值我们可以使用 <code>targetTouches[0]</code> 里面的 <code>pageX</code> 和 <code>pageY</code></li><li>移动端拖动的原理：手指移动中，计算出手指移动的距离。然后用盒子原来的位置+ 手指移动的距离</li><li>手指移动的距离：手指滑动中的位置减去手指刚开始触摸的位置</li></ol><p>拖动元素三步曲： - （1）触摸元素 <code>touchstart</code> ：获取手指初始坐标，同时获得盒子原来的位置 - （2）移动手指 <code>touchmove</code> ：计算手指的滑动距离，并且移动盒子 - （3）离开手指 <code>touchend</code> :</p><p>注意：手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 <code>e.preventDefault();</code></p><h2 id="移动端常见特效">2. 移动端常见特效</h2><p>案例省略，只记录笔记。</p><h3 id="classlist">2.1 classList</h3><p><code>classList</code> 属性是 HTML5 新增的一个属性，返回元素的类名。但是 ie10 以上版本支持。 该属性用于在元素中添加，移除及切换 CSS 类。有以下方法</p><p>添加类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">focus.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;current&#x27;</span>);<br></code></pre></td></tr></table></figure><p></p><p>移除类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">focus.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;current&#x27;</span>);<br></code></pre></td></tr></table></figure><p></p><p>切换类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">focus.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;current&#x27;</span>);<br></code></pre></td></tr></table></figure><p></p><p><font color="red">注意以上方法里面，所有类名都不带点</font></p><h3 id="click-延时解决方案">2.2 click 延时解决方案</h3><p>移动端 <code>click</code> 事件会有 <code>300ms</code> 的延时，原因是移动端屏幕双击会缩放（double tap to zoom）页面。 解决方案：</p><h4 id="禁用缩放">（1）禁用缩放</h4><p>浏览器禁用默认的双击缩放行为并且去掉300ms 的点击延迟。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;user-scalable=no&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="利用touch事件自己封装这个事件解决-300ms-延迟">（2）利用touch事件自己封装这个事件解决 <code>300ms</code> 延迟。</h4><p>原理就是： 1. 当我们手指触摸屏幕，记录当前触摸时间 2. 当我们手指离开屏幕，用离开的时间减去触摸的时间 3. 如果时间小于 <code>150ms</code>，并且没有滑动过屏幕，那么我们就定义为点击</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//封装tap，解决click 300ms 延时</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tap</span>(<span class="hljs-params">obj, callback</span>) &#123;<br>  <span class="hljs-keyword">var</span> isMove = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">var</span> startTime = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录触摸时候的时间变量</span><br>  obj.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 记录触摸时间</span><br>  &#125;);<br>  obj.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    isMove = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 看看是否有滑动，有滑动算拖拽，不算点击</span><br>  &#125;);<br>  obj.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchend&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 如果手指触摸和离开时间小于150ms 算点击</span><br>    <span class="hljs-keyword">if</span> (!isMove &amp;&amp; (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime) &lt; <span class="hljs-number">150</span>) &#123; <br>      callback &amp;&amp; <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 执行回调函数</span><br>    &#125;<br>    isMove = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 取反重置</span><br>    startTime = <span class="hljs-number">0</span>;<br>  &#125;);<br>&#125;<br><span class="hljs-comment">//调用</span><br><span class="hljs-title function_">tap</span>(div, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 执行代码&#125;);</span><br></code></pre></td></tr></table></figure><p></p><h4 id="使用插件-fastclick">（3）使用插件 fastclick</h4><p>使用 fastclick 插件解决300ms 延迟。官网：https://github.com/ftlabs/fastclick</p><ol type="1"><li>引入</li><li>按照文档说明使用</li></ol><p>例如，在原生 JS 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;addEventListener&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">document</span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">FastClick</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>);<br>  &#125;, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p></p><h1 id="七本地存储">七、本地存储</h1><h2 id="本地存储概述">1. 本地存储概述</h2><h3 id="背景">1.1 背景</h3><p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经 常性在本地存储大量的数据，HTML5 规范提出了相关解决方案。</p><h3 id="本地存储特性">1.2 本地存储特性</h3><ul><li>数据存储在用户浏览器中</li><li>设置、读取方便、甚至页面刷新不丢失数据</li><li>容量较大，<code>sessionStorage</code> 约5M、<code>localStorage</code> 约20M</li><li>只能存储字符串，可以将对象 <code>JSON.stringify()</code> 编码后存储</li></ul><h2 id="window.sessionstorage">2. window.sessionStorage</h2><h3 id="特点">2.1 特点</h3><ul><li>生命周期为 <strong>关闭浏览器窗口</strong></li><li>在同一个窗口（页面）下数据可以共享</li><li>以键值对的形式存储使用</li></ul><h3 id="相关操作">2.2 相关操作</h3><ol type="1"><li>存储数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">sessionStorage.<span class="hljs-title function_">setItem</span>(key, value)<br></code></pre></td></tr></table></figure></li><li>获取数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">sessionStorage.<span class="hljs-title function_">getItem</span>(key)<br></code></pre></td></tr></table></figure></li><li>删除数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">sessionStorage.<span class="hljs-title function_">removeItem</span>(key)<br></code></pre></td></tr></table></figure></li><li>删除所有数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">sessionStorage.<span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure></li></ol><h2 id="window.localstorage">3. window.localStorage</h2><h3 id="特点-1">3.1 特点</h3><ul><li>生命周期 <strong>永久生效</strong>，除非手动删除否则关闭页面也会存在</li><li>可以多窗口（页面）共享（同一浏览器可以共享）</li><li>以键值对的形式存储使用</li></ul><h3 id="相关操作-1">3.2 相关操作</h3><ol type="1"><li>存储数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, value)<br></code></pre></td></tr></table></figure></li><li>获取数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)<br></code></pre></td></tr></table></figure></li><li>删除数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">loaclStorage.<span class="hljs-title function_">removeItem</span>(key)<br></code></pre></td></tr></table></figure></li><li>删除所有数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure></li></ol><h2 id="案例记住用户名">4. 案例：记住用户名</h2><h3 id="分析-2">4.1 分析</h3><p>如果勾选记住用户名，下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名。</p><ul><li>把数据存起来，用到本地存储</li><li>关闭页面，也可以显示用户名，所以用到 <code>localStorage</code></li><li>打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名，并且勾选复选框</li><li>当复选框发生改变的时候 <code>change</code> 事件</li><li>如果勾选，就存储，否则就移除</li></ul><h3 id="代码-2">4.2 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> nameInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#username&#x27;</span>);<br><span class="hljs-keyword">let</span> remember = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#remember&#x27;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>)) &#123;<br>    nameInput.<span class="hljs-property">value</span> = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>);<br>    remember.<span class="hljs-property">checked</span> = <span class="hljs-literal">true</span>;<br>&#125;<br>remember.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (remember.<span class="hljs-property">checked</span>) &#123;<br>        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>, nameInput.<span class="hljs-property">value</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Unicorn-acc.github.io">Miraclo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://unicorn-acc.github.io/posts/24734.html">http://unicorn-acc.github.io/posts/24734.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Unicorn-acc.github.io" target="_blank">Miraclo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS/">JS</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/25185.html"><img class="prev-cover" src="https://w.wallhaven.cc/full/vq/wallhaven-vqmyq3.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JQuery笔记（入门、常用API、事件、其他方法）</div></div></a></div><div class="next-post pull-right"><a href="/posts/41353.html"><img class="next-cover" src="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JS基础语法（变量、数据类型、运算符、流程控制、函数、数组、作用域、对象、内置对象）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/41353.html" title="JS基础语法（变量、数据类型、运算符、流程控制、函数、数组、作用域、对象、内置对象）"><img class="cover" src="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-28</div><div class="title">JS基础语法（变量、数据类型、运算符、流程控制、函数、数组、作用域、对象、内置对象）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80web-api-%E7%AE%80%E4%BB%8B"><span class="toc-text">一、Web Api 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#web-apis-%E5%92%8C-js-%E5%9F%BA%E7%A1%80%E5%85%B3%E8%81%94%E6%80%A7"><span class="toc-text">1. Web APIs 和 JS 基础关联性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E7%BB%84%E6%88%90"><span class="toc-text">1.1 JS 组成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api-%E5%92%8C-web-api"><span class="toc-text">2. API 和 Web API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api"><span class="toc-text">2.1 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-api"><span class="toc-text">2.2 Web API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8Cdom-%E5%9F%BA%E7%A1%80document-object-model"><span class="toc-text">二、DOM 基础（Document Object Model）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dom-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. DOM 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-dom"><span class="toc-text">1.1 什么是 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dom-%E6%A0%91"><span class="toc-text">1.2 DOM 树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E9%87%8D%E8%A6%81"><span class="toc-text">2. 获取元素【重要】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0"><span class="toc-text">2.1 如何获取页面元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE-id-%E8%8E%B7%E5%8F%96"><span class="toc-text">2.2 根据 ID 获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%A0%87%E7%AD%BE%E5%90%8D%E8%8E%B7%E5%8F%96"><span class="toc-text">2.3 根据标签名获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-html5-%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96"><span class="toc-text">2.4 通过 HTML5 新增方法获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%89%B9%E6%AE%8A%E5%85%83%E7%B4%A0"><span class="toc-text">2.5 获取特殊元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80"><span class="toc-text">3. 事件基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 事件概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-text">3.2 事件三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E9%87%8D%E8%A6%81"><span class="toc-text">3.4 常见鼠标事件【重要】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0"><span class="toc-text">4. 操作元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9"><span class="toc-text">4.1 改变元素内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innertext-%E5%92%8C-innerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.2 innerText 和 innerHTML 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">4.3 常用元素的属性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">4.4 表单元素的属性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">4.5 样式属性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3"><span class="toc-text">4.6 排他思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#h5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-text">4.7 H5自定义属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEh5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-text">4.7.1 设置H5自定义属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96h5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-text">4.7.2 获取H5自定义属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">4.8 元素属性操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-text">4.8.1 获取属性值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-text">4.8.2 设置属性值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%B1%9E%E6%80%A7"><span class="toc-text">4.8.3 移除属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">5. 结点操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">5.1为什么学节点操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%A6%82%E8%BF%B0"><span class="toc-text">5.2 节点概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7"><span class="toc-text">5.3 节点层级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E7%BA%A7%E8%8A%82%E7%82%B9"><span class="toc-text">5.3.1 父级节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-text">5.3.2 子节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9"><span class="toc-text">5.3.3 兄弟节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="toc-text">5.3.4 创建并添加节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-text">5.3.5 删除节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E8%8A%82%E7%82%B9"><span class="toc-text">5.3.6 复制节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5.3.7 三种动态创建元素的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dom-%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93%E9%87%8D%E8%A6%81"><span class="toc-text">6. DOM 学习阶段核心总结【重要】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B"><span class="toc-text">6.1 创</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E"><span class="toc-text">6.2 增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0"><span class="toc-text">6.3 删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9"><span class="toc-text">6.4 改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5"><span class="toc-text">6.5 查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">6.6 属性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">6.7 事件操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7"><span class="toc-text">三、事件高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6"><span class="toc-text">1. 注册事件（绑定事件）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 注册事件概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-text">1.1.1 传统注册方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-text">1.1.2 事件监听注册方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addeventlistener-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2 addEventListener 事件监听方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#attachevent-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8Fie8%E4%BB%A5%E5%8F%8A%E6%97%A9%E6%9C%9F%E7%89%88%E6%9C%AC%E7%8B%AC%E6%9C%89"><span class="toc-text">1.3 attachEvent 事件监听方式（IE8以及早期版本独有）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8B%E4%BB%B6%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6"><span class="toc-text">2. 删除事件（解绑事件）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F-1"><span class="toc-text">2.1 传统注册方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9B%91%E5%90%AC%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-text">2.2 方法监听注册方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#removeeventlistenerie9"><span class="toc-text">2.2.1 removeEventListener（≥IE9）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#detachevent%E4%BB%85%E9%80%82%E7%94%A8%E4%BA%8Eie8%E5%8F%8A%E4%BB%A5%E4%B8%8B"><span class="toc-text">2.2.2 detachEvent（仅适用于IE8及以下）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dom-%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-text">3. DOM 事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">3.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">3.2 注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">4. 事件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.1 什么是事件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-text">4.2 事件对象的使用语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E6%96%B9%E6%A1%88"><span class="toc-text">4.3 事件对象的兼容性方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">4.4 事件对象的常见属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7-e.target-%E5%92%8C-this-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">4.4.1 事件对象属性 e.target 和 this 的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-text">4.4.2 阻止事件默认行为</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">5. 阻止事件冒泡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">5.1 阻止事件冒泡的两种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">5.2 阻止事件冒泡的兼容性解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%BB%A3%E7%90%86%E5%A7%94%E6%B4%BE"><span class="toc-text">6. 事件委托（代理、委派）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">6.1 前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">6.2 事件委托的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-text">7. 常用的鼠标事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6-1"><span class="toc-text">7.1 常用的鼠标事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">7.2 鼠标事件对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-text">8. 常用的键盘事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6-1"><span class="toc-text">8.1 常用的键盘事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.2 键盘事件对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9Bbom-%E5%9F%BA%E7%A1%80browser-object-model"><span class="toc-text">四、BOM 基础（Browser Object Model）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bom-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. BOM 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bom-%E6%A6%82%E8%BF%B0-1"><span class="toc-text">1.1 BOM 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dom-vs-bom"><span class="toc-text">1.2 DOM vs BOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bom-%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-text">1.3 BOM 的构成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#window-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6"><span class="toc-text">2. window 对象的常见事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.1 窗口加载事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#onload"><span class="toc-text">2.1.1 onload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#domcontentloaded"><span class="toc-text">2.1.2 DOMContentLoaded</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.2 调整窗口大小事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">3. 定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">3.1 两种定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#settimeout-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">3.2 setTimeout() 定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2-settimeout-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">3.3 停止 setTimeout() 定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setinterval-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">3.4 setInterval() 定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E8%AE%A1%E6%97%B6%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">3.4 倒计时案例分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2-setinterval-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">3.5 停止 setInterval() 定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98"><span class="toc-text">3.6 this 指向问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">4. JS 执行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.1 JS 是单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%A6%82%E8%BF%B0"><span class="toc-text">4.2 同步和异步概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-text">4.2.1 同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">4.2.2 异步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.3 同步和异步任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.3.1 同步任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.3.2 异步任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-1"><span class="toc-text">4.4 JS 执行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">4.5 事件循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#location-%E5%AF%B9%E8%B1%A1"><span class="toc-text">5. location 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-location-%E5%AF%B9%E8%B1%A1"><span class="toc-text">5.1 什么是 location 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#url"><span class="toc-text">5.2 URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">5.3 location 对象的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">5.4 location 对象的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#navigator-%E5%AF%B9%E8%B1%A1"><span class="toc-text">6. navigator 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#history-%E5%AF%B9%E8%B1%A1"><span class="toc-text">7. history 对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94pc-%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88"><span class="toc-text">五、PC 端网页特效</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%81%8F%E7%A7%BB%E9%87%8F-offset-%E7%B3%BB%E5%88%97"><span class="toc-text">1. 元素偏移量 offset 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#offset-%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 offset 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#offset-%E4%B8%8E-style-%E5%8C%BA%E5%88%AB"><span class="toc-text">1.2 offset 与 style 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#offset"><span class="toc-text">1.2.1 offset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#style"><span class="toc-text">1.2.2 style</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E5%9C%A8%E7%9B%92%E5%AD%90%E5%86%85%E9%83%A8%E7%9A%84%E5%9D%90%E6%A0%87"><span class="toc-text">1.3 案例1：获取鼠标在盒子内部的坐标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-text">1.3.1 分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">1.3.2 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2%E6%A8%A1%E6%80%81%E6%A1%86%E6%8B%96%E6%8B%BD"><span class="toc-text">1.4 案例2：模态框拖拽</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-text">1.4.1 分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">1.4.2 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2%E4%BA%AC%E4%B8%9C%E6%94%BE%E5%A4%A7%E9%95%9C"><span class="toc-text">1.5 案例2：京东放大镜</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%8F%AF%E8%A7%86%E5%8C%BA-client-%E7%B3%BB%E5%88%97"><span class="toc-text">2. 元素可视区 client 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">2.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%B7%98%E5%AE%9D-flexible.js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2.2 案例：淘宝 flexible.js 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-text">2.2.1 立即执行函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pageshow-%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.2.2 pageShow 事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%BB%9A%E5%8A%A8-scroll-%E7%B3%BB%E5%88%97"><span class="toc-text">3. 元素滚动 scroll 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0scroll-%E7%B3%BB%E5%88%97%E5%B1%9E%E6%80%A7"><span class="toc-text">3.1 元素scroll 系列属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%A2%AB%E5%8D%B7%E5%8E%BB%E7%9A%84%E5%A4%B4%E9%83%A8"><span class="toc-text">3.2 页面被卷去的头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%BF%E6%B7%98%E5%AE%9D%E5%9B%BA%E5%AE%9A%E5%8F%B3%E4%BE%A7%E4%BE%A7%E8%BE%B9%E6%A0%8F"><span class="toc-text">3.3 案例：仿淘宝固定右侧侧边栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93"><span class="toc-text">3.4 三大系列总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">3.4.1 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%94%A8%E6%B3%95"><span class="toc-text">3.4.2 主要用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mouseenter-%E5%92%8C-mouseover-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.5 mouseenter 和 mouseover 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85"><span class="toc-text">4. 动画函数封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 动画实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85"><span class="toc-text">4.2 动画函数简单封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0%E7%BB%99%E4%B8%8D%E5%90%8C%E5%85%83%E7%B4%A0%E8%AE%B0%E5%BD%95%E4%B8%8D%E5%90%8C%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">4.3 动画函数给不同元素记录不同定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%8A%A8%E6%95%88%E6%9E%9C%E5%8E%9F%E7%90%86"><span class="toc-text">4.4 缓动效果原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0%E5%A4%9A%E4%B8%AA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B9%8B%E9%97%B4%E7%A7%BB%E5%8A%A8"><span class="toc-text">4.5 动画函数多个目标值之间移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">4.6 动画函数添加回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E5%88%B0%E5%8D%95%E7%8B%ACjs%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2"><span class="toc-text">4.7 动画函数封装到单独JS文件里面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B"><span class="toc-text">5. 常见网页特效案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1%E8%BD%AE%E6%92%AD%E5%9B%BE"><span class="toc-text">5.1 案例1：轮播图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E5%88%86%E6%9E%90"><span class="toc-text">5.1.1 总体分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E5%B0%8F%E5%9C%86%E5%9C%88"><span class="toc-text">5.1.2 动态生成小圆圈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%9C%86%E5%9C%88%E7%9A%84%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3"><span class="toc-text">5.1.3 小圆圈的排他思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E5%B0%8F%E5%9C%86%E5%9C%88%E6%BB%9A%E5%8A%A8%E5%9B%BE%E7%89%87"><span class="toc-text">5.1.4 点击小圆圈滚动图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E4%BE%A7%E6%8C%89%E9%92%AE%E5%8A%9F%E8%83%BD"><span class="toc-text">5.1.5 右侧按钮功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E9%9A%86%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87"><span class="toc-text">5.1.6 克隆第一张图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E5%8F%B3%E4%BE%A7%E6%8C%89%E9%92%AE%E5%B0%8F%E5%9C%86%E5%9C%88%E8%B7%9F%E9%9A%8F%E5%8F%98%E5%8C%96"><span class="toc-text">5.1.7 点击右侧按钮，小圆圈跟随变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E5%8A%9F%E8%83%BD"><span class="toc-text">5.1.8 自动播放功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%E9%98%80"><span class="toc-text">5.1.9 节流阀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8"><span class="toc-text">5.2 案例2：返回顶部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#window.scroll"><span class="toc-text">5.2.1 window.scroll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E5%8A%A8%E7%94%BB%E7%9A%84%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8"><span class="toc-text">5.2.2 带有动画的返回顶部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0"><span class="toc-text">5.2.3 修改后的缓存动画函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3%E7%AD%8B%E6%96%97%E4%BA%91"><span class="toc-text">5.3 案例3：筋斗云</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-text">5.3.1 效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.3.2 实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88"><span class="toc-text">六、 移动端网页特效</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6"><span class="toc-text">1. 触摸事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 触屏事件概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1touchevent"><span class="toc-text">1.2 触摸事件对象（TouchEvent）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8B%96%E5%8A%A8%E5%85%83%E7%B4%A0"><span class="toc-text">1.3 移动端拖动元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%89%B9%E6%95%88"><span class="toc-text">2. 移动端常见特效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#classlist"><span class="toc-text">2.1 classList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#click-%E5%BB%B6%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">2.2 click 延时解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E7%BC%A9%E6%94%BE"><span class="toc-text">（1）禁用缩放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8touch%E4%BA%8B%E4%BB%B6%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85%E8%BF%99%E4%B8%AA%E4%BA%8B%E4%BB%B6%E8%A7%A3%E5%86%B3-300ms-%E5%BB%B6%E8%BF%9F"><span class="toc-text">（2）利用touch事件自己封装这个事件解决 300ms 延迟。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6-fastclick"><span class="toc-text">（3）使用插件 fastclick</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-text">七、本地存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 本地存储概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text">1.1 背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%89%B9%E6%80%A7"><span class="toc-text">1.2 本地存储特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#window.sessionstorage"><span class="toc-text">2. window.sessionStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">2.1 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-text">2.2 相关操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#window.localstorage"><span class="toc-text">3. window.localStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-text">3.1 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C-1"><span class="toc-text">3.2 相关操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E8%AE%B0%E4%BD%8F%E7%94%A8%E6%88%B7%E5%90%8D"><span class="toc-text">4. 案例：记住用户名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-text">4.1 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text">4.2 代码</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Miraclo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人只有在走上坡路的时候才会累和迷茫。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.1},options:{renderActions:{findScript:[10,t=>{for(const n of document.querySelectorAll('script[type^="math/tex"]')){var e=!!n.type.match(/; *mode=display/),e=new t.options.MathItem(n.textContent,t.inputJax[0],e),a=document.createTextNode("");n.parentNode.replaceChild(a,n),e.start={node:a,delim:"",n:0},e.end={node:a,delim:"",n:0},t.math.push(e)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t.hasAttribute("display")?btf.wrap(t,"div",{class:"mathjax-overflow"}):btf.wrap(t,"span",{class:"mathjax-overflow"})})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script></div><link rel="stylesheet" href="/css/Lete.css"><script src="/js/custom.js"></script><script src="/js/mouth.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1s"),arr[i].setAttribute("data-wow-delay","1ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>