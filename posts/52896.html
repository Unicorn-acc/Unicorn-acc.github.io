<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>消息队列RabbitMQ_03_交换机、死信队列、延迟队列+整合Springboot | Miraclo</title><meta name="author" content="Miraclo"><meta name="copyright" content="Miraclo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布&#x2F;订阅”。  为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外"><meta property="og:type" content="article"><meta property="og:title" content="消息队列RabbitMQ_03_交换机、死信队列、延迟队列+整合Springboot"><meta property="og:url" content="http://unicorn-acc.github.io/posts/52896.html"><meta property="og:site_name" content="Miraclo"><meta property="og:description" content="在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布&#x2F;订阅”。  为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w.wallhaven.cc/full/x6/wallhaven-x619o3.jpg"><meta property="article:published_time" content="2023-03-13T10:46:01.000Z"><meta property="article:modified_time" content="2023-07-27T14:53:07.796Z"><meta property="article:author" content="Miraclo"><meta property="article:tag" content="消息队列"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/x6/wallhaven-x619o3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://unicorn-acc.github.io/posts/52896"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:2e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:800,languages:{author:"作者: Miraclo",link:"链接: ",source:"来源: Miraclo",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"消息队列RabbitMQ_03_交换机、死信队列、延迟队列+整合Springboot",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-07-27 14:53:07"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mouth.css"><link rel="stylesheet" href="/css/codecolor.css"><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://w.wallhaven.cc/full/x6/wallhaven-x619o3.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Miraclo</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">消息队列RabbitMQ_03_交换机、死信队列、延迟队列+整合Springboot</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-13T10:46:01.000Z" title="发表于 2023-03-13 10:46:01">2023-03-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%B7%A5%E5%85%B7/">中间件与工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/">RabbitMQ</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="消息队列RabbitMQ_03_交换机、死信队列、延迟队列+整合Springboot"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，<strong>每个任务都恰好交付给一个消费者(工作进程)</strong>。在这一部分中，我们<strong>将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布/订阅”</strong>。</p><blockquote><p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者</p></blockquote><h1 id="三exchanges交换机">三、Exchanges交换机</h1><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，<strong>生产者只能将消息发送到交换机(exchange)</strong>，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000035.png" alt="RabbitMQ-00000035"><figcaption aria-hidden="true">RabbitMQ-00000035</figcaption></figure><h3 id="exchanges-的类型"><strong>Exchanges 的类型</strong></h3><ul><li><p><strong>直接(direct)</strong>：处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 abc ，则只有被标记为 abc 的消息才被转发，不会转发 abc.def，也不会转发 dog.ghi，只会转发 abc。</p></li><li><p><strong>主题(topic)</strong>：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号 * 匹配不多不少一个词。因此 abc.# 能够匹配到 abc.def.ghi，但是 abc.* 只会匹配到 abc.def。</p></li><li><p><strong>标题(headers)</strong>：不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到RabbitMQ 时会取到该消息的 headers 与 Exchange 绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是 Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要要字符串形式的。</p><p>匹配规则 x-match 有下列两种类型：</p><p>x-match = all ：表示所有的键值对都匹配才能接受到消息</p><p>x-match = any ：表示只要有键值对匹配就能接受到消息</p></li><li><p><strong>扇出(fanout)</strong>：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。</p></li></ul><p><strong>无名exchange：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。<br></code></pre></td></tr></table></figure><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000036.png" alt="RabbitMQ-00000036"><figcaption aria-hidden="true">RabbitMQ-00000036</figcaption></figure><p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话</p><h2 id="临时队列">临时队列</h2><p>之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。</p><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p><p>创建临时队列的方式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br></code></pre></td></tr></table></figure><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000037.png" alt="、"><figcaption aria-hidden="true">、</figcaption></figure><h2 id="绑定-bindings">绑定 bindings</h2><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000038.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627203918539.png"></p><h2 id="fanout-exchange扇出交换机发布订阅模式">Fanout exchange（扇出交换机(发布订阅模式)）</h2><p>一个发送，多个接受，发布/订阅模式</p><h3 id="fanout-介绍">Fanout 介绍</h3><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息<strong>广播</strong>到它知道的 所有队列中。系统中默认有些 exchange 类型</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000039.png"></p><h3 id="fanout-实战">Fanout 实战</h3><blockquote><p>在这种模式下，发送者不需要声明队列，只需要声明交换机然后在每次发送中发送到交换机中。接收者方声明队列，绑定到交换机上，然后接收队列中的消息。</p></blockquote><p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000040.png"></p><p>Logs 和临时队列的绑定关系如下图</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000041.png"></p><hr><p>注意</p><blockquote><p>先启动两个消费者再启动生产者。</p><p>生产者生产消息后，如果没有对应的消费者接收，则该消息是遗弃的消息</p></blockquote><p>ReceiveLogs01 将接收到的消息打印在控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveLogs01</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        <span class="hljs-comment">// 声明一个交换机（名称， 类别）</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 生成一个临时的队列 队列的名称是随机的</span><br><span class="hljs-comment">         * 当消费者断开和该队列的连接时 队列自动删除</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">// 绑定交换机与队列</span><br>        <span class="hljs-comment">// 把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息,把接收到的消息打印在屏幕........... &quot;</span>);<br><br>        <span class="hljs-comment">// 接收消息</span><br>        <span class="hljs-comment">// 消费者取消消息时回调接口</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;控制台打印接收到的消息&quot;</span> + message);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ReceiveLogs02 把消息写出到文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveLogs02</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 生成一个临时的队列 队列的名称是随机的</span><br><span class="hljs-comment">         * 当消费者断开和该队列的连接时 队列自动删除</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息,把接收到的消息写到文件........... &quot;</span>);<br><br>        <span class="hljs-comment">//发送回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\test\\rabbitmq_info.txt&quot;</span>);<br>            FileUtils.writeStringToFile(file,message,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;数据写入文件成功&quot;</span>);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>EmitLog 发送消息给两个消费者接收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmitLog</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明一个 exchange</span><br><span class="hljs-comment">         * 1.exchange 的名称</span><br><span class="hljs-comment">         * 2.exchange 的类型</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入信息&quot;</span>);<br>        <span class="hljs-keyword">while</span> (sc.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sc.nextLine();<br>            channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;生产者发出消息&quot;</span> + message);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="direct-exchange直接交换机路由模式">Direct exchange（直接交换机(路由模式)）</h2><p>在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p><p>我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： <strong>队列只对它绑定的交换机的消息感兴趣</strong>。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, "routingKey");</p><p>绑定之后的意义由其交换类型决定。</p><h3 id="direct-介绍">Direct 介绍</h3><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，<strong>消息只去到它绑定的 routingKey 队列中去。</strong></p><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000042.png" alt="RabbitMQ-00000042"><figcaption aria-hidden="true">RabbitMQ-00000042</figcaption></figure><p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.</p><p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p><h3 id="多重绑定">多重绑定</h3><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000043.png" alt="RabbitMQ-00000043"><figcaption aria-hidden="true">RabbitMQ-00000043</figcaption></figure><p>当然如果 exchange 的绑定类型是direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多，如上图所示。</p><h3 id="direct-实战">Direct 实战</h3><p>关系：</p><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000044.png" alt="RabbitMQ-00000044"><figcaption aria-hidden="true">RabbitMQ-00000044</figcaption></figure><p>交换机：</p><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000045.png" alt="RabbitMQ-00000045"><figcaption aria-hidden="true">RabbitMQ-00000045</figcaption></figure><p>c1消费者：绑定 disk 队列，routingKey 为 error</p><p>c2消费者：绑定 console 队列，routingKey 为 info、warning</p><p>当生产者生产消息到 <code>direct_logs</code> 交换机里，该交换机会检测消息的 routingKey 条件，然后分配到满足条件的队列里，最后由消费者从队列消费消息。</p><p>C1消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveLogsDirect01</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        <span class="hljs-comment">// 交换机声明</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;disk&quot;</span>;<br>        <span class="hljs-comment">//队列声明</span><br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//队列绑定</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;error&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息...&quot;</span>);<br><br>        <span class="hljs-comment">//发送回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            message = <span class="hljs-string">&quot;接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="hljs-string">&quot;,消息:&quot;</span> + message;<br>            System.out.println(<span class="hljs-string">&quot;error 消息已经接收：\n&quot;</span> + message);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C2消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveLogsDirect02</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;console&quot;</span>;<br>        <span class="hljs-comment">//队列声明</span><br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//队列绑定</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;info&quot;</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;warning&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;等待接收消息...&quot;</span>);<br><br>        <span class="hljs-comment">//发送回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            message = <span class="hljs-string">&quot;接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="hljs-string">&quot;,消息:&quot;</span> + message;<br>            System.out.println(<span class="hljs-string">&quot;info和warning 消息已经接收：\n&quot;</span> + message);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmitLogDirect</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        <br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">//创建多个 bindingKey</span><br>        Map&lt;String, String&gt; bindingKeyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        bindingKeyMap.put(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;普通 info 信息&quot;</span>);<br>        bindingKeyMap.put(<span class="hljs-string">&quot;warning&quot;</span>, <span class="hljs-string">&quot;警告 warning 信息&quot;</span>);<br>        bindingKeyMap.put(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;错误 error 信息&quot;</span>);<br>        <span class="hljs-comment">//debug 没有消费这接收这个消息 所有就丢失了</span><br>        bindingKeyMap.put(<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-string">&quot;调试 debug 信息&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;<br>            <span class="hljs-comment">//获取 key value</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">bindingKey</span> <span class="hljs-operator">=</span> bindingKeyEntry.getKey();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> bindingKeyEntry.getValue();<br><br>            channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="hljs-literal">null</span>, message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;生产者发出消息:&quot;</span> + message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="topics-exchange主题交换机主题模式">Topics exchange（主题交换机(主题模式)）</h2><h3 id="topic-的介绍">Topic 的介绍</h3><p>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。</p><p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 <strong>topic</strong> 类型</p><p><strong>Topic 的要求</strong></p><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是<strong>一个单词列表</strong>，<strong>以点号分隔开</strong>。这些单词可以是任意单词</p><p>比如说："stock.usd.nyse", "nyse.vmw", "qui ck.orange.rabbit" 这种类型的。</p><p>当然这个单词列表最多不能超过 255 个字节。</p><p>在这个规则列表中， 其中有两个替换符是大家需要注意的：</p><ul><li>*<strong>(星号)可以代替一个位置</strong></li><li><strong>#(井号)可以替代零个或多个位置</strong></li></ul><h3 id="topic-匹配案例">Topic 匹配案例</h3><p>下图绑定关系如下</p><figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000046.png" alt="RabbitMQ-00000046"><figcaption aria-hidden="true">RabbitMQ-00000046</figcaption></figure><ul><li>Q1--&gt;绑定的是<ul><li>中间带 orange 带 3 个单词的字符串 <code>(*.orange.*)</code></li></ul></li><li>Q2--&gt;绑定的是<ul><li>最后一个单词是 rabbit 的 3 个单词 <code>(*.*.rabbit)</code></li><li>第一个单词是 lazy 的多个单词 <code>(lazy.#)</code></li></ul></li></ul><p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的</p><table><thead><tr class="header"><th>例子</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>quick.orange.rabbit</td><td>被队列 Q1Q2 接收到</td></tr><tr class="even"><td>azy.orange.elephant</td><td>被队列 Q1Q2 接收到</td></tr><tr class="odd"><td>quick.orange.fox</td><td>被队列 Q1 接收到</td></tr><tr class="even"><td>lazy.brown.fox</td><td>被队列 Q2 接收到</td></tr><tr class="odd"><td>lazy.pink.rabbit</td><td>虽然满足两个绑定但只被队列 Q2 接收一次</td></tr><tr class="even"><td>quick.brown.fox</td><td>不匹配任何绑定不会被任何队列接收到会被丢弃</td></tr><tr class="odd"><td>quick.orange.male.rabbit</td><td>是四个单词不匹配任何绑定会被丢弃</td></tr><tr class="even"><td>lazy.orange.male.rabbit</td><td>是四个单词但匹配 Q2</td></tr></tbody></table><blockquote><p>注意：</p><ul><li>当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像 fanout 了</li><li>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</li></ul></blockquote><h3 id="topic-实战">Topic 实战</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000047.png"></p><p>代码如下：</p><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmitLogTopic</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        <span class="hljs-comment">// BuiltinExchangeType.TOPIC 等同于 &quot;topic&quot;</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Q1--&gt;绑定的是</span><br><span class="hljs-comment">         *      中间带 orange 带 3 个单词的字符串(*.orange.*)</span><br><span class="hljs-comment">         * Q2--&gt;绑定的是</span><br><span class="hljs-comment">         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span><br><span class="hljs-comment">         *      第一个单词是 lazy 的多个单词(lazy.#)</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         */</span><br>        Map&lt;String, String&gt; bindingKeyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        bindingKeyMap.put(<span class="hljs-string">&quot;quick.orange.rabbit&quot;</span>, <span class="hljs-string">&quot;被队列 Q1Q2 接收到&quot;</span>);<br>        bindingKeyMap.put(<span class="hljs-string">&quot;lazy.orange.elephant&quot;</span>, <span class="hljs-string">&quot;被队列 Q1Q2 接收到&quot;</span>);<br>        bindingKeyMap.put(<span class="hljs-string">&quot;quick.orange.fox&quot;</span>, <span class="hljs-string">&quot;被队列 Q1 接收到&quot;</span>);<br>        bindingKeyMap.put(<span class="hljs-string">&quot;lazy.brown.fox&quot;</span>, <span class="hljs-string">&quot;被队列 Q2 接收到&quot;</span>);<br>        bindingKeyMap.put(<span class="hljs-string">&quot;lazy.pink.rabbit&quot;</span>, <span class="hljs-string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);<br>        bindingKeyMap.put(<span class="hljs-string">&quot;quick.brown.fox&quot;</span>, <span class="hljs-string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);<br>        bindingKeyMap.put(<span class="hljs-string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="hljs-string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);<br>        bindingKeyMap.put(<span class="hljs-string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="hljs-string">&quot;是四个单词但匹配 Q2&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">bindingKey</span> <span class="hljs-operator">=</span> bindingKeyEntry.getKey();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> bindingKeyEntry.getValue();<br><br>            channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="hljs-literal">null</span>, message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;生产者发出消息：&quot;</span> + message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者Q1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveLogsTopic01</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        <span class="hljs-comment">// BuiltinExchangeType.TOPIC 等同于 &quot;topic&quot;</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);<br>        <span class="hljs-comment">//声明 Q1 队列与绑定关系</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Q1&quot;</span>;<br>        <span class="hljs-comment">//声明</span><br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//绑定</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;*.orange.*&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息........... &quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot; 接收队列:&quot;</span> + queueName + <span class="hljs-string">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="hljs-string">&quot;,消息:&quot;</span> + message);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者Q2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveLogsTopic02</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        <span class="hljs-comment">// BuiltinExchangeType.TOPIC 等同于 &quot;topic&quot;</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);<br>        <span class="hljs-comment">//声明 Q2 队列与绑定关系</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Q2&quot;</span>;<br>        <span class="hljs-comment">//声明</span><br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//绑定</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;*.*.rabbit&quot;</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;lazy.#&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;等待接收消息........... &quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot; 接收队列:&quot;</span> + queueName + <span class="hljs-string">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="hljs-string">&quot;,消息:&quot;</span> + message);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="四死信的概念">四、死信的概念</h1><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因<strong>导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：<strong>用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</strong></p><h2 id="死信的来源">死信的来源</h2><ul><li><p><strong>消息 TTL 过期</strong></p><p>TTL是Time To Live的缩写, 也就是生存时间</p></li><li><p><strong>队列达到最大长度</strong></p><p>队列满了，无法再添加数据到 mq 中</p></li><li><p><strong>消息被拒绝</strong></p><p>(basic.reject 或 basic.nack) 并且 requeue=false.</p></li></ul><h2 id="死信实战">死信实战</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091031069.png"></p><h3 id="死信之ttl过期延迟队列前置">死信之TTL过期（延迟队列前置）</h3><p>消费者 C1 代码：（启动之后关闭该消费者 模拟其接收不到消息）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer01</span> &#123;<br><br>    <span class="hljs-comment">//普通交换机的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br>    <span class="hljs-comment">//死信交换机的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_exchange&quot;</span>;<br><br>    <span class="hljs-comment">//普通队列的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_queue&quot;</span>;<br>    <span class="hljs-comment">//死信队列的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-comment">//声明死信和普通交换机，类型为direct</span><br>        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);<br>        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">//声明普通队列</span><br>        Map&lt;String,Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//过期时间 10s 由生产者指定 更加灵活</span><br>        <span class="hljs-comment">//arguments.put(&quot;x-message-ttl&quot;,10000);</span><br>        <span class="hljs-comment">//正常的队列设置死信交换机</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);<span class="hljs-comment">//图中红箭头</span><br>        <span class="hljs-comment">//设置死信routingKey</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br><br>        channel.queueDeclare(NORMAL_QUEUE,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,arguments);<br>        <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////</span><br>        <span class="hljs-comment">//声明死信队列</span><br>        channel.queueDeclare(DEAD_QUEUE,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">//绑定普通的交换机与队列</span><br>        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br><br>        <span class="hljs-comment">//绑定死信的交换机与死信的队列</span><br>        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="hljs-string">&quot;lisi&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息...&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag,message) -&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;Consumer01接受的消息是：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody(),<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        &#125;;<br><br>        channel.basicConsume(NORMAL_QUEUE,<span class="hljs-literal">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>生产者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br>    <span class="hljs-comment">//普通交换机的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-comment">//死信消息 设置ttl时间 live to time 单位是ms</span><br>        AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="hljs-string">&quot;10000&quot;</span>).build();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;<span class="hljs-number">11</span> ; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;info&quot;</span>+i;<br>            channel.basicPublish(NORMAL_EXCHANGE,<span class="hljs-string">&quot;zhangsan&quot;</span>,properties,message.getBytes());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>先启动消费者 C1，创建出队列，然后停止该 C1 的运行，则 C1 将无法收到队列的消息，无法收到的消息 10 秒后进入死信队列。启动生产者 producer 生产消息</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091031071.png"></p><p>消费者 C2 代码：</p><p>以上步骤完成后，启动 C2 消费者，它消费死信队列里面的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer02</span> &#123;<br><br>    <span class="hljs-comment">//死信队列的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        System.out.println(<span class="hljs-string">&quot;等待接收死信消息...&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, message) -&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;Consumer02接受的消息是：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody(),<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        &#125;;<br><br>        channel.basicConsume(DEAD_QUEUE,<span class="hljs-literal">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091031072.png"></p><h3 id="死信之最大长度">死信之最大长度</h3><p>1、消息生产者代码去掉 TTL 属性</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091031073.png"></p><p>2、C1 消费者修改以下代码<strong>(启动之后关闭该消费者 模拟其接收不到消息)</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091031074.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置正常队列长度的限制，例如发送10个消息，6个为正常，4个为死信</span><br>params.put(<span class="hljs-string">&quot;x-max-length&quot;</span>,<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p><mark>注意此时需要把原先队列删除 因为参数改变了</mark></p><p>3、C2 消费者代码不变(启动 C2 消费者)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091031075.png"></p><h3 id="死信之消息被拒">死信之消息被拒</h3><p>1、消息生产者代码同上生产者一致</p><p>2、C1 消费者拒收消息 "info5"，开启手动应答(启动之后关闭该消费者 模拟其接收不到消息)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer01</span> &#123;<br><br>    <span class="hljs-comment">//普通交换机的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br>    <span class="hljs-comment">//死信交换机的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_exchange&quot;</span>;<br><br>    <span class="hljs-comment">//普通队列的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_queue&quot;</span>;<br>    <span class="hljs-comment">//死信队列的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-comment">//声明死信和普通交换机，类型为direct</span><br>        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);<br>        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">//声明普通队列</span><br>        Map&lt;String,Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//过期时间 10s 由生产者指定 更加灵活</span><br>        <span class="hljs-comment">//arguments.put(&quot;x-message-ttl&quot;,10000);</span><br>        <span class="hljs-comment">//正常的队列设置死信交换机</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);<span class="hljs-comment">//图中红箭头</span><br>        <span class="hljs-comment">//设置死信routingKey</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>        <span class="hljs-comment">//设置正常队列长度的限制，例如发送10个消息，6个为正常，4个为死信</span><br>        <span class="hljs-comment">//arguments.put(&quot;x-max-length&quot;,6);</span><br><br>        channel.queueDeclare(NORMAL_QUEUE,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,arguments);<br>        <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////</span><br>        <span class="hljs-comment">//声明死信队列</span><br>        channel.queueDeclare(DEAD_QUEUE,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">//绑定普通的交换机与队列</span><br>        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br><br>        <span class="hljs-comment">//绑定死信的交换机与死信的队列</span><br>        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="hljs-string">&quot;lisi&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息...&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag,message) -&gt;&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            <span class="hljs-keyword">if</span>(msg.equals(<span class="hljs-string">&quot;info5&quot;</span>))&#123;<br>                System.out.println(<span class="hljs-string">&quot;Consumer01接受的消息是：&quot;</span>+msg+<span class="hljs-string">&quot;： 此消息是被C1拒绝的&quot;</span>);<br>                <span class="hljs-comment">//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span><br>                channel.basicReject(message.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Consumer01接受的消息是：&quot;</span>+msg);<br>                channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>            &#125;<br><br>        &#125;;<br>        <span class="hljs-comment">//开启手动应答，也就是关闭手动应答</span><br>        channel.basicConsume(NORMAL_QUEUE,<span class="hljs-literal">false</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091031076.png"></p><p>3、C2 消费者代码不变</p><p>启动消费者 1 然后再启动消费者 2</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091031077.png"></p><hr><h1 id="五延迟队列介绍">五、延迟队列介绍</h1><p><strong>延迟队列概念：</strong>（延迟队列用于延迟消息处理的时间）</p><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，<strong>延时队列就是用来存放需要在指定时间被处理的元素的队列</strong>。</p><p><strong>延迟队列使用场景：</strong></p><ol type="1"><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？</p><p>如果数据量比较少，确实可以这样做，比如：对于「如果账单一周内未支付则进行自动结算」这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。<strong>但对于数据量比较大，并且时效性较强的场景</strong>，如：「订单十分钟内未支付则关闭」，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，<strong>对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下</strong>。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032473.png"></p><h2 id="rabbitmq-中的-ttl">RabbitMQ 中的 TTL</h2><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p><p>换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为"死信"。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><p><strong>队列设置TTL</strong></p><p>在创建队列的时候设置队列的“x-message-ttl”属性</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032474.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>params.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;QA&quot;</span>).withArguments(args).build(); <span class="hljs-comment">// QA 队列的最大存活时间位 5000 毫秒</span><br></code></pre></td></tr></table></figure><p><strong>消息设置TTL</strong></p><p>是针对每条消息设置TTL</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032475.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">rabbitTemplate.converAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XC&quot;</span>,message,correlationData -&gt; &#123;<br>    correlationData.getMessageProperties().setExpiration(<span class="hljs-string">&quot;5000&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>两者区别</strong></p><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间，具体看下方案例。</p><p>另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃</p><h2 id="重要整合-springboot">【重要※】整合 springboot</h2><p>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。</p><p>1、创建一个空项目：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032476.png"></p><p>2、添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--RabbitMQ 依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--swagger--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--RabbitMQ 测试依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、修改配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">42.192.149.71</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">admin</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><p>4、添加Swagger 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oddfar.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;<br><span class="hljs-keyword">import</span> springfox.documentation.service.ApiInfo;<br><span class="hljs-keyword">import</span> springfox.documentation.service.Contact;<br><span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<br><span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<br><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">webApiConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;webApi&quot;</span>)<br>                .apiInfo(webApiInfo())<br>                .select()<br>                .build();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">webApiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;rabbitmq 接口文档&quot;</span>)<br>                .description(<span class="hljs-string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;zhiyuan&quot;</span>, <span class="hljs-string">&quot;http://oddfar.com&quot;</span>, <span class="hljs-string">&quot;test@qq.com&quot;</span>))<br>                .build();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列-ttl">队列 TTL</h2><ul><li><strong>代码架构图</strong></li></ul><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032477.png"></p><p>原先配置队列信息，写在了生产者和消费者代码中，现在可写在配置类中，生产者只发消息，消费者只接受消息</p><h3 id="配置文件类代码"><strong>1、配置文件类代码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TtlQueueConfig</span> &#123;<br><br>    <span class="hljs-comment">//普通交换机的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String X_EXCHANGE=<span class="hljs-string">&quot;X&quot;</span>;<br>    <span class="hljs-comment">//死信交换机的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String Y_DEAD_LETTER_EXCHANGE=<span class="hljs-string">&quot;Y&quot;</span>;<br>    <span class="hljs-comment">//普通队列的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_A=<span class="hljs-string">&quot;QA&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_B=<span class="hljs-string">&quot;QB&quot;</span>;<br>    <span class="hljs-comment">//死信队列的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_LETTER_QUEUE=<span class="hljs-string">&quot;QD&quot;</span>;<br><br>    <span class="hljs-comment">//声明xExchange  别名</span><br>    <span class="hljs-meta">@Bean(&quot;xExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">xExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(X_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-comment">//声明yExchange 别名</span><br>    <span class="hljs-meta">@Bean(&quot;yExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">yExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-comment">//声明普通队列  要有ttl 为10s</span><br>    <span class="hljs-meta">@Bean(&quot;queueA&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueA</span><span class="hljs-params">()</span>&#123;<br>        Map&lt;String,Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//设置死信交换机</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);<br>        <span class="hljs-comment">//设置死信RoutingKey</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;YD&quot;</span>);<br>        <span class="hljs-comment">//设置TTL 10s 单位是ms</span><br>        arguments.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>,<span class="hljs-number">10000</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();<br>    &#125;<br><br>    <span class="hljs-comment">//声明普通队列  要有ttl 为40s</span><br>    <span class="hljs-meta">@Bean(&quot;queueB&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueB</span><span class="hljs-params">()</span>&#123;<br>        Map&lt;String,Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//设置死信交换机</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);<br>        <span class="hljs-comment">//设置死信RoutingKey</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;YD&quot;</span>);<br>        <span class="hljs-comment">//设置TTL 10s 单位是ms</span><br>        arguments.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>,<span class="hljs-number">40000</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();<br>    &#125;<br><br>    <span class="hljs-comment">//声明死信队列  要有ttl 为40s</span><br>    <span class="hljs-meta">@Bean(&quot;queueD&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueD</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(DEAD_LETTER_QUEUE).build();<br>    &#125;<br>	<span class="hljs-comment">//@Qualifier(&quot;queueA&quot;) 根据Bean名字进行捆绑</span><br>    <span class="hljs-comment">// 可以不用写,springboot会自动注入被bean标注的方法形参</span><br>    <span class="hljs-comment">//声明队列 QA 绑定 X 交换机</span><br>    <span class="hljs-meta">@Bean</span> <br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueABindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="hljs-string">&quot;XA&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//声明队列 QB 绑定 X 交换机 </span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="hljs-string">&quot;XB&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//声明队列 QD 绑定 Y 交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueDBindingY</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="hljs-string">&quot;YD&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="消息生产者代码"><strong>2、消息生产者代码</strong></h3><p><strong>Controller 层代码，获取消息，放到 RabbitMQ</strong> 里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">	发送延迟消息</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/ttl&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMsgController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>    <br>    <span class="hljs-comment">//开始发消息</span><br>    <span class="hljs-meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;message&quot;)</span> String message)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;当前时间:&#123;&#125;,发送一条信息给两个TTL队列：&#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString(), message);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XA&quot;</span>,<span class="hljs-string">&quot;消息来自ttl为10s的队列:&quot;</span>+message);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XB&quot;</span>,<span class="hljs-string">&quot;消息来自ttl为40s的队列:&quot;</span>+message);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消息消费者代码"><strong>3、消息消费者代码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消费者 - 死信队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLetterQueueConsumer</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;QD&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveD</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>        log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString(), msg);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>发起一个请求：<code>http://localhost:8888/ttl/sendMsg/嘻嘻嘻</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032478.png"></p><blockquote><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p><p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？ -- <strong>延时队列TTL优化</strong></p></blockquote><h2 id="延时队列ttl优化">延时队列TTL优化</h2><p>在这里新增了一个队列 QC，该队列不设置 TTL 时间，根据前端的请求确定 TTL 时间，绑定关系如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032479.png"></p><p><strong>配置文件类代码：</strong></p><p>新增一个配置文件类，用于新增队列 QC，也可以放在上方的配置文件类里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgTtlQueueConfig</span> &#123;<br><br>    <span class="hljs-comment">//普通队列的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_C</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QC&quot;</span>;<br><br>    <span class="hljs-comment">//死信交换机的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String Y_DEAD_LETTER_EXCHANGE=<span class="hljs-string">&quot;Y&quot;</span>;<br><br>    <span class="hljs-comment">//声明QC</span><br>    <span class="hljs-meta">@Bean(&quot;queueC&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">QueueC</span><span class="hljs-params">()</span>&#123;<br>        Map&lt;String,Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//设置死信交换机</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);<br>        <span class="hljs-comment">//设置死信RoutingKey</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;YD&quot;</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();<br>    &#125;<br>    <span class="hljs-comment">//声明队列 QC 绑定 X 交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueCBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span>DirectExchange xExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="hljs-string">&quot;XC&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>生产者代码：</strong></p><p><strong>Controller 新增方法</strong></p><p>该方法接收的请求要带有 TTL 时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/ttl&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMsgController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>    <span class="hljs-comment">//开始发消息</span><br>    <span class="hljs-meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;message&quot;)</span> String message)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;当前时间:&#123;&#125;,发送一条信息给两个TTL队列：&#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString(),message);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XA&quot;</span>,<span class="hljs-string">&quot;消息来自ttl为10s的队列:&quot;</span>+message);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XB&quot;</span>,<span class="hljs-string">&quot;消息来自ttl为40s的队列:&quot;</span>+message);<br><br>    &#125;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment"> 	* 延时队列优化</span><br><span class="hljs-comment"> 	* <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment"> 	* <span class="hljs-doctag">@param</span> ttlTime 延时的毫秒</span><br><span class="hljs-comment"> 	*/</span><br>    <span class="hljs-comment">//开始发消息 发TTL</span><br>    <span class="hljs-meta">@GetMapping(&quot;/sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;message&quot;)</span> String message,</span><br><span class="hljs-params">                        <span class="hljs-meta">@PathVariable(&quot;ttlTime&quot;)</span> String ttlTime)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;当前时间:&#123;&#125;,发送一条时长是&#123;&#125;毫秒TTL信息给队列QC：&#123;&#125;&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString(),ttlTime,message);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XC&quot;</span>,message,msg -&gt; &#123;<br>            <span class="hljs-comment">//发送消息的时候的延迟时长</span><br>            msg.getMessageProperties().setExpiration(ttlTime);<br>            <span class="hljs-keyword">return</span> msg;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>发起请求</p><p><code>http://localhost:8080/ttl/sendExpirationMsg/你好1/20000</code></p><p><code>http://localhost:8080/ttl/sendExpirationMsg/你好2/2000</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032480.png"></p><p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时「死亡」</p><blockquote><p><strong>因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</strong></p></blockquote><p>这也就是为什么如图的时间：你好 2 延时 2 秒，却后执行，还要等待你好 1 消费后再执行你好2</p><h2 id="rabbitmq-插件实现延迟队列">Rabbitmq 插件实现延迟队列</h2><p>上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。</p><p><strong>安装延时队列插件</strong></p><p>可去<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">官网下载 (opens new window)</a>找到 <strong>rabbitmq_delayed_message_exchange</strong> 插件，放置到 RabbitMQ 的插件目录。</p><p>因为官网也是跳转去该插件的 GitHub 地址进行下载：<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases">点击跳转(opens new window)</a></p><p>打开 Linux，用 <code>Xftp</code> 将插件放到 RabbitMQ 的安装目录下的 plgins 目录，</p><p>RabbitMQ 与其 plgins 目录默认分别位于</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># RabbitMQ 安装目录</span><br><span class="hljs-built_in">cd</span> /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8   <br><span class="hljs-comment"># RabbitMQ 的 plgins 所在目录</span><br><span class="hljs-built_in">cd</span> /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins<br></code></pre></td></tr></table></figure><p>其中我的版本是 <code>/rabbitmq_server-3.8.8</code></p><p>进入目录后执行下面命令让该插件生效，然后重启 RabbitMQ</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装</span><br>rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_delayed_message_exchange<br><span class="hljs-comment"># 重启服务</span><br>systemctl restart rabbitmq-server<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@master plugins]<span class="hljs-comment"># rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br>Enabling plugins on node rabbit@master:<br>rabbitmq_delayed_message_exchange<br>The following plugins have been configured:<br>  rabbitmq_delayed_message_exchange<br>  rabbitmq_management<br>  rabbitmq_management_agent<br>  rabbitmq_web_dispatch<br>Applying plugin configuration to rabbit@master...<br>The following plugins have been enabled:<br>  rabbitmq_delayed_message_exchange<br><br>started 1 plugins.<br>[root@master plugins]<span class="hljs-comment"># systemctl restart rabbitmq-server</span><br></code></pre></td></tr></table></figure><blockquote><p>解释</p><p>安装命令不能出现插件版本和后缀，如 <code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange-3.8.0.ez</code> 会报错</p><p>必须是 <code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code>，后面不允许填入版本和文件后缀</p></blockquote><p>打开 Web 界面，查看交换机的新增功能列表，如果多出了如图所示，代表成功添加插件</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032481.png"></p><h3 id="插件实战">插件实战</h3><p>在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032482.png"></p><h4 id="配置文件类代码-1"><strong>1、配置文件类代码</strong></h4><p>新增一个配置类 <code>DelayedQueueConfig</code>，也可以放在原来的配置文件里，代码里使用了 <code>CustomExchange</code> 类，通过参数来自定义一个类型(direct、topic等)</p><p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedQueueConfig</span> &#123;<br><br>    <span class="hljs-comment">//交换机</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.exchange&quot;</span>;<br>    <span class="hljs-comment">//队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.queue&quot;</span>;<br>    <span class="hljs-comment">//routingKey</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.routingkey&quot;</span>;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">delayedQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(DELAYED_QUEUE_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">//声明交换机,基于插件的交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CustomExchange <span class="hljs-title function_">delayedExchange</span><span class="hljs-params">()</span>&#123;<br><br>        Map&lt;String,Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        arguments.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 1.交换机的名称</span><br><span class="hljs-comment">         * 2.交换机的类型 x-delayed-message</span><br><span class="hljs-comment">         * 3.是否需要持久化</span><br><span class="hljs-comment">         * 4.是否需要自动删除</span><br><span class="hljs-comment">         * 5.其他的参数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME,<span class="hljs-string">&quot;x-delayed-message&quot;</span>,<br>                <span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,arguments);<br>    &#125;<br><br>    <span class="hljs-comment">//绑定</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">delayedQueueBindingDelayedExchange</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue,</span><br><span class="hljs-params">            <span class="hljs-meta">@Qualifier(&quot;delayedExchange&quot;)</span>CustomExchange delayedExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange)<br>                .with(DELAYED_ROUTING_KEY).noargs();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="生产者代码"><strong>2、生产者代码</strong></h4><p>在 controller 里新增一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开始发消息，基于插件的 消息及 延迟的时间</span><br><span class="hljs-meta">@GetMapping(&quot;/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;message&quot;)</span> String message,</span><br><span class="hljs-params">                    <span class="hljs-meta">@PathVariable(&quot;delayTime&quot;)</span> Integer delayTime)</span>&#123;<br>    log.info(<span class="hljs-string">&quot;当前时间:&#123;&#125;,发送一条时长是&#123;&#125;毫秒TTL信息给延迟队列delayed.queue：&#123;&#125;&quot;</span>,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString(),delayTime,message);<br><br>    rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME,<br>            DelayedQueueConfig.DELAYED_ROUTING_KEY,message, msg -&gt; &#123;<br>        <span class="hljs-comment">//发送消息的时候的延迟时长 单位ms</span><br>        msg.getMessageProperties().setDelay(delayTime);<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者代码"><strong>3、消费者代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消费者 - 基于插件的延时队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayQueueConsumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.queue&quot;</span>;<br><br>    <span class="hljs-meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveDelayedQueue</span><span class="hljs-params">(Message message)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>        log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString(), msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发送请求：</p><ul><li><a target="_blank" rel="noopener" href="http://localhost:8080/ttl/sendDelayMsg/hello1/20000" class="uri">http://localhost:8080/ttl/sendDelayMsg/hello1/20000</a></li><li><a target="_blank" rel="noopener" href="http://localhost:8080/ttl/sendDelayMsg/hello2/2000" class="uri">http://localhost:8080/ttl/sendDelayMsg/hello2/2000</a></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs03/202303091032483.png"></p><p>第二个消息被先消费掉了，符合预期(可以看到哪怕 hello1 需要20秒再进入延时队列，hello2 2 秒后直接进入延时队列，无需等待 hello1</p><h2 id="总结">总结</h2><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Unicorn-acc.github.io">Miraclo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://unicorn-acc.github.io/posts/52896.html">http://unicorn-acc.github.io/posts/52896.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Unicorn-acc.github.io" target="_blank">Miraclo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/x6/wallhaven-x619o3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/21208.html"><img class="prev-cover" src="https://w.wallhaven.cc/full/1p/wallhaven-1p1qjg.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">消息队列RabbitMQ_04_发布确认高级、其他高级特性（幂等性、优先级队列、惰性队列）</div></div></a></div><div class="next-post pull-right"><a href="/posts/46865.html"><img class="next-cover" src="https://w.wallhaven.cc/full/kx/wallhaven-kx3p1q.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">消息队列RabbitMQ_02_简单案例、工作队列、消息确认、发布确认模式(三种确认发布方式)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/54760.html" title="消息队列RabbitMQ_01_介绍、软件安装"><img class="cover" src="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">消息队列RabbitMQ_01_介绍、软件安装</div></div></a></div><div><a href="/posts/21208.html" title="消息队列RabbitMQ_04_发布确认高级、其他高级特性（幂等性、优先级队列、惰性队列）"><img class="cover" src="https://w.wallhaven.cc/full/1p/wallhaven-1p1qjg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-13</div><div class="title">消息队列RabbitMQ_04_发布确认高级、其他高级特性（幂等性、优先级队列、惰性队列）</div></div></a></div><div><a href="/posts/46865.html" title="消息队列RabbitMQ_02_简单案例、工作队列、消息确认、发布确认模式(三种确认发布方式)"><img class="cover" src="https://w.wallhaven.cc/full/kx/wallhaven-kx3p1q.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">消息队列RabbitMQ_02_简单案例、工作队列、消息确认、发布确认模式(三种确认发布方式)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89exchanges%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">三、Exchanges交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exchanges-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">Exchanges 的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-text">临时队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-bindings"><span class="toc-text">绑定 bindings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fanout-exchange%E6%89%87%E5%87%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">Fanout exchange（扇出交换机(发布订阅模式)）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fanout-%E4%BB%8B%E7%BB%8D"><span class="toc-text">Fanout 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fanout-%E5%AE%9E%E6%88%98"><span class="toc-text">Fanout 实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#direct-exchange%E7%9B%B4%E6%8E%A5%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F"><span class="toc-text">Direct exchange（直接交换机(路由模式)）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#direct-%E4%BB%8B%E7%BB%8D"><span class="toc-text">Direct 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%91%E5%AE%9A"><span class="toc-text">多重绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#direct-%E5%AE%9E%E6%88%98"><span class="toc-text">Direct 实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#topics-exchange%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F"><span class="toc-text">Topics exchange（主题交换机(主题模式)）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#topic-%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">Topic 的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#topic-%E5%8C%B9%E9%85%8D%E6%A1%88%E4%BE%8B"><span class="toc-text">Topic 匹配案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#topic-%E5%AE%9E%E6%88%98"><span class="toc-text">Topic 实战</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">四、死信的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="toc-text">死信的来源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E5%AE%9E%E6%88%98"><span class="toc-text">死信实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E4%B9%8Bttl%E8%BF%87%E6%9C%9F%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%89%8D%E7%BD%AE"><span class="toc-text">死信之TTL过期（延迟队列前置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E4%B9%8B%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6"><span class="toc-text">死信之最大长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E4%B9%8B%E6%B6%88%E6%81%AF%E8%A2%AB%E6%8B%92"><span class="toc-text">死信之消息被拒</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D"><span class="toc-text">五、延迟队列介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rabbitmq-%E4%B8%AD%E7%9A%84-ttl"><span class="toc-text">RabbitMQ 中的 TTL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%95%B4%E5%90%88-springboot"><span class="toc-text">【重要※】整合 springboot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97-ttl"><span class="toc-text">队列 TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E4%BB%A3%E7%A0%81"><span class="toc-text">1、配置文件类代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-text">2、消息生产者代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-text">3、消息消费者代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97ttl%E4%BC%98%E5%8C%96"><span class="toc-text">延时队列TTL优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rabbitmq-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">Rabbitmq 插件实现延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E5%AE%9E%E6%88%98"><span class="toc-text">插件实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E4%BB%A3%E7%A0%81-1"><span class="toc-text">1、配置文件类代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-text">2、生产者代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-text">3、消费者代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Miraclo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人只有在走上坡路的时候才会累和迷茫。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.1},options:{renderActions:{findScript:[10,t=>{for(const n of document.querySelectorAll('script[type^="math/tex"]')){var e=!!n.type.match(/; *mode=display/),e=new t.options.MathItem(n.textContent,t.inputJax[0],e),a=document.createTextNode("");n.parentNode.replaceChild(a,n),e.start={node:a,delim:"",n:0},e.end={node:a,delim:"",n:0},t.math.push(e)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t.hasAttribute("display")?btf.wrap(t,"div",{class:"mathjax-overflow"}):btf.wrap(t,"span",{class:"mathjax-overflow"})})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script></div><link rel="stylesheet" href="/css/Lete.css"><script src="/js/custom.js"></script><script src="/js/mouth.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1s"),arr[i].setAttribute("data-wow-delay","1ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>