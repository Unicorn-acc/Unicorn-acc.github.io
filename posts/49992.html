<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Netty-01-NIO基础（三大组件、Selecter、NIOvsBIO） | Miraclo</title><meta name="author" content="Miraclo"><meta name="copyright" content="Miraclo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Netty-01-NIO基础 non-blocking io 非阻塞 IO 前置知识： nio三大组件，channel，buffer，selector。 channel是通道，可以是网络socket通道，也可以是文件传输的通道。 buffer是应用程序到通道直接的桥梁，数据缓存区，有bytebuffer，也可以有charbuffer。buffer的数据结构支持读写，所以在读写转换的时候需要调用ap"><meta property="og:type" content="article"><meta property="og:title" content="Netty-01-NIO基础（三大组件、Selecter、NIOvsBIO）"><meta property="og:url" content="http://unicorn-acc.github.io/posts/49992.html"><meta property="og:site_name" content="Miraclo"><meta property="og:description" content="Netty-01-NIO基础 non-blocking io 非阻塞 IO 前置知识： nio三大组件，channel，buffer，selector。 channel是通道，可以是网络socket通道，也可以是文件传输的通道。 buffer是应用程序到通道直接的桥梁，数据缓存区，有bytebuffer，也可以有charbuffer。buffer的数据结构支持读写，所以在读写转换的时候需要调用ap"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w.wallhaven.cc/full/kx/wallhaven-kx3p1q.jpg"><meta property="article:published_time" content="2023-09-06T15:25:20.000Z"><meta property="article:modified_time" content="2023-09-20T08:55:49.528Z"><meta property="article:author" content="Miraclo"><meta property="article:tag" content="Netty"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/kx/wallhaven-kx3p1q.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://unicorn-acc.github.io/posts/49992"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:2e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:800,languages:{author:"作者: Miraclo",link:"链接: ",source:"来源: Miraclo",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Netty-01-NIO基础（三大组件、Selecter、NIOvsBIO）",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-09-20 08:55:49"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mouth.css"><link rel="stylesheet" href="/css/codecolor.css"><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">162</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://w.wallhaven.cc/full/kx/wallhaven-kx3p1q.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Miraclo</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span></span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Netty-01-NIO基础（三大组件、Selecter、NIOvsBIO）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-09-06T15:25:20.000Z" title="发表于 2023-09-06 15:25:20">2023-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%B7%A5%E5%85%B7/">中间件与工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%B7%A5%E5%85%B7/2%E3%80%81Netty/">2、Netty</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Netty-01-NIO基础（三大组件、Selecter、NIOvsBIO）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="netty-01-nio基础">Netty-01-NIO基础</h1><p>non-blocking io 非阻塞 IO</p><p>前置知识：</p><p>nio三大组件，channel，buffer，selector。</p><p><strong>channel</strong>是通道，可以是网络socket通道，也可以是文件传输的通道。</p><p><strong>buffer</strong>是应用程序到通道直接的桥梁，数据缓存区，有bytebuffer，也可以有charbuffer。buffer的数据结构支持读写，所以在读写转换的时候需要调用api flip。还有很多其他api</p><p><strong>selector</strong>，每次读取通道数据的时候要么阻塞，要么就是不断的无意义轮询。我们可以把channel注册到seletor里，监听seletor的事件，读事件，写事件，连接事件，根据事件再来操作。</p><p>断开连接也会产生读事件，值为-1.</p><h2 id="三大组件">1. 三大组件</h2><h3 id="channel-buffer">1.1 Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/image-20230905132527051.png"></p><p>常见的 Channel 有</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>buffer 则用来缓冲读写数据，常见的 buffer 有</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h3 id="selector">1.2 Selector</h3><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p><h4 id="多线程版设计">多线程版设计</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/image-20230905132809763.png"></p><h4 id="多线程版缺点">⚠️ 多线程版缺点</h4><ul><li>内存占用高</li><li>线程上下文切换成本高</li><li>只适合连接数少的场景</li></ul><h4 id="线程池版设计">线程池版设计</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/image-20230905132854144.png"></p><h4 id="线程池版缺点">⚠️ 线程池版缺点</h4><ul><li>阻塞模式下，线程仅能处理一个 socket 连接</li><li>仅适合短连接场景</li></ul><h4 id="selector-版设计">selector 版设计</h4><p><strong>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。</strong>适合连接数特别多，但流量低的场景（low traffic）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/image-20230905132946663.png"></p><p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理</p><h2 id="bytebuffer">2. ByteBuffer</h2><p>有一普通文本文件 data.txt，内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1234567890abcd<br></code></pre></td></tr></table></figure><p>使用 FileChannel 来读取文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>            <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 向 buffer 写入</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>                log.debug(<span class="hljs-string">&quot;读到字节数：&#123;&#125;&quot;</span>, len);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 切换 buffer 读模式</span><br>                buffer.flip();<br>                <span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, (<span class="hljs-type">char</span>)buffer.get());<br>                &#125;<br>                <span class="hljs-comment">// 切换 buffer 写模式</span><br>                buffer.clear();<br>            &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d<br>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1<br></code></pre></td></tr></table></figure><h3 id="bytebuffer-正确使用姿势">2.1 ByteBuffer 正确使用姿势</h3><ol type="1"><li>向 buffer 写入数据，例如调用 channel.read(buffer)</li><li>调用 flip() 切换至<strong>读模式</strong></li><li>从 buffer 读取数据，例如调用 buffer.get()</li><li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li><li>重复 1~4 步骤</li></ol><h3 id="bytebuffer-结构">2.2 ByteBuffer 结构</h3><p>ByteBuffer 有以下重要属性</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>一开始</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0021.png"></p><p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0018.png"></p><p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0019.png"></p><p>读取 4 个字节后，状态</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0020.png"></p><p>clear 动作发生后，状态</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0021.png"></p><p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0022.png"></p><h4 id="调试工具类">💡 调试工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufferUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] BYTE2CHAR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] HEXDUMP_TABLE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">256</span> * <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXPADDING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">16</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">65536</span> &gt;&gt;&gt; <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTE2HEX = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTEPADDING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">16</span>];<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] DIGITS = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>            HEXDUMP_TABLE[i &lt;&lt; <span class="hljs-number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0x0F</span>];<br>            HEXDUMP_TABLE[(i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>] = DIGITS[i &amp; <span class="hljs-number">0x0F</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-comment">// Generate the lookup table for hex dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXPADDING.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">padding</span> <span class="hljs-operator">=</span> HEXPADDING.length - i;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(padding * <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&quot;   &quot;</span>);<br>            &#125;<br>            HEXPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">12</span>);<br>            buf.append(NEWLINE);<br>            buf.append(Long.toHexString(i &lt;&lt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));<br>            buf.setCharAt(buf.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            buf.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>            HEXDUMP_ROWPREFIXES[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-hex-dump conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;<br>            BYTE2HEX[i] = <span class="hljs-string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">padding</span> <span class="hljs-operator">=</span> BYTEPADDING.length - i;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(padding);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>            BYTEPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-char conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0x1f</span> || i &gt;= <span class="hljs-number">0x7f</span>) &#123;<br>                BYTE2CHAR[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                BYTE2CHAR[i] = (<span class="hljs-type">char</span>) i;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印所有内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugAll</span><span class="hljs-params">(ByteBuffer buffer)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldlimit</span> <span class="hljs-operator">=</span> buffer.limit();<br>        buffer.limit(buffer.capacity());<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(origin, buffer, <span class="hljs-number">0</span>, buffer.capacity());<br>        System.out.println(<span class="hljs-string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);<br>        System.out.println(origin);<br>        buffer.limit(oldlimit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印可读取内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugRead</span><span class="hljs-params">(ByteBuffer buffer)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());<br>        System.out.println(<span class="hljs-string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());<br>        System.out.println(builder);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendPrettyHexDump</span><span class="hljs-params">(StringBuilder dump, ByteBuffer buf, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<br>                    <span class="hljs-string">&quot;expected: &quot;</span> + <span class="hljs-string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="hljs-string">&quot;) &lt;= offset + length(&quot;</span> + length<br>                            + <span class="hljs-string">&quot;) &lt;= &quot;</span> + <span class="hljs-string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dump.append(<br>                <span class="hljs-string">&quot;         +-------------------------------------------------+&quot;</span> +<br>                        NEWLINE + <span class="hljs-string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +<br>                        NEWLINE + <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> offset;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">fullRows</span> <span class="hljs-operator">=</span> length &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> length &amp; <span class="hljs-number">0xF</span>;<br><br>        <span class="hljs-comment">// Dump the rows which have 16 bytes.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; fullRows; row++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowStartIndex</span> <span class="hljs-operator">=</span> (row &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br><br>            <span class="hljs-comment">// Per-row prefix.</span><br>            appendHexDumpRowPrefix(dump, row, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowEndIndex</span> <span class="hljs-operator">=</span> rowStartIndex + <span class="hljs-number">16</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// ASCII dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Dump the last row which has less than 16 bytes.</span><br>        <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowStartIndex</span> <span class="hljs-operator">=</span> (fullRows &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br>            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowEndIndex</span> <span class="hljs-operator">=</span> rowStartIndex + remainder;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(HEXPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// Ascii dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(BYTEPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        dump.append(NEWLINE +<br>                <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendHexDumpRowPrefix</span><span class="hljs-params">(StringBuilder dump, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> rowStartIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;<br>            dump.append(HEXDUMP_ROWPREFIXES[row]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dump.append(NEWLINE);<br>            dump.append(Long.toHexString(rowStartIndex &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));<br>            dump.setCharAt(dump.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getUnsignedByte</span><span class="hljs-params">(ByteBuffer buffer, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">short</span>) (buffer.get(index) &amp; <span class="hljs-number">0xFF</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bytebuffer-常见方法">2.3 ByteBuffer 常见方法</h3><h4 id="分配空间">分配空间</h4><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Bytebuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><h4 id="向-buffer-写入数据">向 buffer 写入数据</h4><p>有两种办法</p><ul><li>调用 channel 的 read 方法</li><li>调用 buffer 自己的 put 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buf);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">buf.put((<span class="hljs-type">byte</span>)<span class="hljs-number">127</span>);<br></code></pre></td></tr></table></figure><h4 id="从-buffer-读取数据">从 buffer 读取数据</h4><p>同样有两种办法</p><ul><li>调用 channel 的 write 方法</li><li>调用 buffer 自己的 get 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">writeBytes</span> <span class="hljs-operator">=</span> channel.write(buf);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buf.get();<br></code></pre></td></tr></table></figure><p>get 方法会让 position 读指针向后走，如果想重复读取数据</p><ul><li>可以调用 rewind 方法将 position 重新置为 0</li><li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li></ul><h4 id="mark-和-reset">mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p><blockquote><p><strong>注意</strong></p><p>rewind 和 flip 都会清除 mark 位置</p></blockquote><h4 id="字符串与-bytebuffer-互转">字符串与 ByteBuffer 互转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer2</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>).encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><br>debug(buffer1);<br>debug(buffer2);<br><br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer3</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buffer1);<br>System.out.println(buffer3.getClass());<br>System.out.println(buffer3.toString());<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| e4 bd a0 e5 a5 bd                               |......          |<br>+--------+-------------------------------------------------+----------------+<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| e4 bd a0 e5 a5 bd                               |......          |<br>+--------+-------------------------------------------------+----------------+<br>class java.nio.HeapCharBuffer<br>你好<br></code></pre></td></tr></table></figure><h4 id="buffer-的线程安全">⚠️ Buffer 的线程安全</h4><p>Buffer 是<strong>非线程安全的</strong></p><h3 id="scattering-reads">2.4 Scattering Reads</h3><p>分散读取，有一个文本文件 3parts.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">onetwothree<br></code></pre></td></tr></table></figure><p>使用如下方式读取，可以将数据填充至多个 buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;helloword/3parts.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>    channel.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[]&#123;a, b, c&#125;);<br>    a.flip();<br>    b.flip();<br>    c.flip();<br>    debug(a);<br>    debug(b);<br>    debug(c);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 6f 6e 65                                        |one             |<br>+--------+-------------------------------------------------+----------------+<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 74 77 6f                                        |two             |<br>+--------+-------------------------------------------------+----------------+<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 74 68 72 65 65                                  |three           |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h3 id="gathering-writes">2.5 Gathering Writes</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;helloword/3parts.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    channel.position(<span class="hljs-number">11</span>);<br><br>    d.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>&#125;);<br>    e.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;);<br>    d.flip();<br>    e.flip();<br>    debug(d);<br>    debug(e);<br>    channel.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[]&#123;d, e&#125;);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 66 6f 75 72                                     |four            |<br>+--------+-------------------------------------------------+----------------+<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 66 69 76 65                                     |five            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">onetwothreefourfive<br></code></pre></td></tr></table></figure><h3 id="练习">2.6 练习</h3><p>网络上有多条数据发送给服务端，数据之间使用 进行分隔 但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p><ul><li>Hello,world</li><li>I'm zhangsan</li><li>How are you?</li></ul><p>变成了下面的两个 byteBuffer (<strong>黏包，半包</strong>)</p><ul><li>Hello,world'm zhangsan</li><li>w are you?</li></ul><p>现在要求你编写程序，将错乱的数据恢复成原始的按 分隔的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">32</span>);<br>    <span class="hljs-comment">//                     11            24</span><br>    source.put(<span class="hljs-string">&quot;Hello,world\nI&#x27;m zhangsan\nHo&quot;</span>.getBytes());<br>    split(source);<br><br>    source.put(<span class="hljs-string">&quot;w are you?\nhaha!\n&quot;</span>.getBytes());<br>    split(source);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(ByteBuffer source)</span> &#123;<br>    source.flip();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLimit</span> <span class="hljs-operator">=</span> source.limit();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; oldLimit; i++) &#123;<br>        <span class="hljs-keyword">if</span> (source.get(i) == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            System.out.println(i);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(i + <span class="hljs-number">1</span> - source.position());<br>            <span class="hljs-comment">// 0 ~ limit</span><br>            source.limit(i + <span class="hljs-number">1</span>);<br>            target.put(source); <span class="hljs-comment">// 从source 读，向 target 写</span><br>            debugAll(target);<br>            source.limit(oldLimit);<br>        &#125;<br>    &#125;<br>    source.compact();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件编程">3. 文件编程</h2><h3 id="filechannel">3.1 FileChannel</h3><h4 id="filechannel-工作模式">⚠️ FileChannel 工作模式</h4><blockquote><p>FileChannel 只能工作在阻塞模式下</p></blockquote><h4 id="获取">获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel 只能读</li><li>通过 FileOutputStream 获取的 channel 只能写</li><li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li></ul><h4 id="读取">读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buffer);<br></code></pre></td></tr></table></figure><h4 id="写入">写入</h4><p>写入的正确姿势如下， SocketChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ...;<br>buffer.put(...); <span class="hljs-comment">// 存入数据</span><br>buffer.flip();   <span class="hljs-comment">// 切换读模式</span><br><br><span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>    channel.write(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p><h4 id="关闭">关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p><h4 id="位置">位置</h4><p>获取当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> channel.position();<br></code></pre></td></tr></table></figure><p>设置当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">newPos</span> <span class="hljs-operator">=</span> ...;<br>channel.position(newPos);<br></code></pre></td></tr></table></figure><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1</li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h4 id="大小">大小</h4><p>使用 size 方法获取文件的大小</p><h4 id="强制写入">强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h3 id="两个-channel-传输数据">3.2 两个 Channel 传输数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">FROM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloword/data.txt&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">TO</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloword/to.txt&quot;</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-keyword">try</span> (<span class="hljs-type">FileChannel</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FROM).getChannel();<br>     <span class="hljs-type">FileChannel</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(TO).getChannel();<br>    ) &#123;<br>    from.transferTo(<span class="hljs-number">0</span>, from.size(), to);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>System.out.println(<span class="hljs-string">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">transferTo 用时：8.2011<br></code></pre></td></tr></table></figure><p>超过 2g 大小的文件传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFileChannelTransferTo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data.txt&quot;</span>).getChannel();<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;to.txt&quot;</span>).getChannel();<br>        ) &#123;<br>            <span class="hljs-comment">// 效率高，底层会利用操作系统的零拷贝进行优化</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> from.size();<br>            <span class="hljs-comment">// left 变量代表还剩余多少字节</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> size; left &gt; <span class="hljs-number">0</span>; ) &#123;<br>                System.out.println(<span class="hljs-string">&quot;position:&quot;</span> + (size - left) + <span class="hljs-string">&quot; left:&quot;</span> + left);<br>                left -= from.transferTo((size - left), left, to);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际传输一个超大文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">position:0 left:7769948160<br>position:2147483647 left:5622464513<br>position:4294967294 left:3474980866<br>position:6442450941 left:1327497219<br></code></pre></td></tr></table></figure><h3 id="path">3.3 Path</h3><p>jdk7 引入了 Path 和 Paths 类</p><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;1.txt&quot;</span>); <span class="hljs-comment">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span><br><br><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>); <span class="hljs-comment">// 绝对路径 代表了  d:\1.txt</span><br><br><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:/1.txt&quot;</span>); <span class="hljs-comment">// 绝对路径 同样代表了  d:\1.txt</span><br><br><span class="hljs-type">Path</span> <span class="hljs-variable">projects</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\data&quot;</span>, <span class="hljs-string">&quot;projects&quot;</span>); <span class="hljs-comment">// 代表了  d:\data\projects</span><br></code></pre></td></tr></table></figure><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">d:<br>	|- data<br>		|- projects<br>			|- a<br>			|- b<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\data\\projects\\a\\..\\b&quot;</span>);<br>System.out.println(path);<br>System.out.println(path.normalize()); <span class="hljs-comment">// 正常化路径</span><br></code></pre></td></tr></table></figure><p>会输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">d:\data\projects\a\..\b<br>d:\data\projects\b<br></code></pre></td></tr></table></figure><h3 id="files">3.4 Files</h3><p>检查文件是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br>System.out.println(Files.exists(path));<br></code></pre></td></tr></table></figure><p>创建一级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/d1&quot;</span>);<br>Files.createDirectory(path);<br></code></pre></td></tr></table></figure><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建多级目录用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/d1/d2&quot;</span>);<br>Files.createDirectories(path);<br></code></pre></td></tr></table></figure><p>拷贝文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/target.txt&quot;</span>);<br><br>Files.copy(source, target);<br></code></pre></td></tr></table></figure><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);<br></code></pre></td></tr></table></figure><p>移动文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><br>Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);<br></code></pre></td></tr></table></figure><ul><li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li></ul><p>删除文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/target.txt&quot;</span>);<br><br>Files.delete(target);<br></code></pre></td></tr></table></figure><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/d1&quot;</span>);<br><br>Files.delete(target);<br></code></pre></td></tr></table></figure><ul><li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li></ul><p>遍历目录文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">dirCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">fileCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    Files.walkFileTree(path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(dir);<br>            dirCount.incrementAndGet();<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.preVisitDirectory(dir, attrs);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>            System.out.println(file);<br>            fileCount.incrementAndGet();<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitFile(file, attrs);<br>        &#125;<br>    &#125;);<br>    System.out.println(dirCount); <span class="hljs-comment">// 133</span><br>    System.out.println(fileCount); <span class="hljs-comment">// 1479</span><br>&#125;<br></code></pre></td></tr></table></figure><p>统计 jar 的数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);<br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">fileCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>Files.walkFileTree(path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <br>        <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (file.toFile().getName().endsWith(<span class="hljs-string">&quot;.jar&quot;</span>)) &#123;<br>            fileCount.incrementAndGet();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitFile(file, attrs);<br>    &#125;<br>&#125;);<br>System.out.println(fileCount); <span class="hljs-comment">// 724</span><br></code></pre></td></tr></table></figure><p>删除多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;d:\\a&quot;</span>);<br>Files.walkFileTree(path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <br>        <span class="hljs-keyword">throws</span> IOException &#123;<br>        Files.delete(file);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitFile(file, attrs);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">postVisitDirectory</span><span class="hljs-params">(Path dir, IOException exc)</span> <br>        <span class="hljs-keyword">throws</span> IOException &#123;<br>        Files.delete(dir);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.postVisitDirectory(dir, exc);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="删除很危险">⚠️ 删除很危险</h4><blockquote><p>删除是危险操作，确保要递归删除的文件夹没有重要内容</p></blockquote><p>拷贝多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\Snipaste-1.16.2-x64&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\Snipaste-1.16.2-x64aaa&quot;</span>;<br><br>Files.walk(Paths.get(source)).forEach(path -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetName</span> <span class="hljs-operator">=</span> path.toString().replace(source, target);<br>        <span class="hljs-comment">// 是目录</span><br>        <span class="hljs-keyword">if</span> (Files.isDirectory(path)) &#123;<br>            Files.createDirectory(Paths.get(targetName));<br>        &#125;<br>        <span class="hljs-comment">// 是普通文件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Files.isRegularFile(path)) &#123;<br>            Files.copy(path, Paths.get(targetName));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(end - start);<br></code></pre></td></tr></table></figure><h2 id="网络编程">4. 网络编程</h2><h3 id="非阻塞-vs-阻塞">4.1 非阻塞 vs 阻塞</h3><h4 id="阻塞">阻塞</h4><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li><li>SocketChannel.read 会在没有数据可读时让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li></ul></li></ul><p>服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 nio 来理解阻塞模式, 单线程</span><br><span class="hljs-comment">// 0. ByteBuffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 1. 创建了服务器</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><br><span class="hljs-comment">// 2. 绑定监听端口</span><br>ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br><span class="hljs-comment">// 3. 连接集合</span><br>List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span><br>    log.debug(<span class="hljs-string">&quot;connecting...&quot;</span>);<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept(); <span class="hljs-comment">// 阻塞方法，线程停止运行</span><br>    log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>    channels.add(sc);<br>    <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>        <span class="hljs-comment">// 5. 接收客户端发送的数据</span><br>        log.debug(<span class="hljs-string">&quot;before read... &#123;&#125;&quot;</span>, channel);<br>        channel.read(buffer); <span class="hljs-comment">// 阻塞方法，线程停止运行</span><br>        buffer.flip();<br>        debugRead(buffer);<br>        buffer.clear();<br>        log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="非阻塞">非阻塞</h4><ul><li>非阻塞模式下，相关方法都会不会让线程暂停<ul><li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li><li><strong>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept</strong></li><li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li></ul></li><li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li><li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li></ul><p>服务器端，客户端代码不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 nio 来理解非阻塞模式, 单线程</span><br><span class="hljs-comment">// 0. ByteBuffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 1. 创建了服务器</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>ssc.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br><span class="hljs-comment">// 2. 绑定监听端口</span><br>ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><span class="hljs-comment">// 3. 连接集合</span><br>List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept(); <span class="hljs-comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span><br>    <span class="hljs-keyword">if</span> (sc != <span class="hljs-literal">null</span>) &#123;<br>        log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>        sc.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br>        channels.add(sc);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>        <span class="hljs-comment">// 5. 接收客户端发送的数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<span class="hljs-comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span><br>        <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.flip();<br>            debugRead(buffer);<br>            buffer.clear();<br>            log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多路复用">✔多路复用</h4><p><strong>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</strong></p><ul><li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul></li></ul><h3 id="selector-1">4.2 Selector</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/image-20230905145249272.png"></p><p>好处</p><ul><li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li><li>让这个线程能够被充分利用</li><li>节约了线程的数量</li><li>减少了线程上下文切换</li></ul><h4 id="创建">创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure><h4 id="绑定-channel-事件">绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 selector 才会关心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> channel.register(selector, 绑定事件);<br></code></pre></td></tr></table></figure><ul><li>channel 必须工作在非阻塞模式</li><li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的事件类型可以有<ul><li><strong>connect - 客户端连接成功时触发</strong></li><li><strong>accept - 服务器端成功接受连接时触发</strong></li><li><strong>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</strong></li><li><strong>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</strong></li></ul></li></ul><h4 id="监听-channel-事件">监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p><p>方法1，阻塞直到绑定事件发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br></code></pre></td></tr></table></figure><p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select(<span class="hljs-type">long</span> timeout);<br></code></pre></td></tr></table></figure><p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.selectNow();<br></code></pre></td></tr></table></figure><h4 id="select-何时不阻塞">💡 select 何时不阻塞</h4><ul><li>事件发生时<ul><li><strong>客户端发起连接请求</strong>，会触发 accept 事件</li><li><strong>客户端发送数据过来，客户端正常、异常关闭时</strong>，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li><li>channel 可写，会触发 write 事件</li><li>在 linux 下 nio bug 发生时</li></ul></li><li>调用 selector.wakeup()</li><li>调用 selector.close()</li><li>selector 所在线程 interrupt</li></ul><h3 id="处理-accept-事件">4.3 处理 accept 事件</h3><p>客户端代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)) &#123;<br>            System.out.println(socket);<br>            socket.getOutputStream().write(<span class="hljs-string">&quot;world&quot;</span>.getBytes());<br>            System.in.read();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器端代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelDemo6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>            channel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            System.out.println(channel);<br>            <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>            channel.configureBlocking(<span class="hljs-literal">false</span>);<br>            channel.register(selector, SelectionKey.OP_ACCEPT);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br><span class="hljs-comment">//                int count = selector.selectNow();</span><br>                log.debug(<span class="hljs-string">&quot;select count: &#123;&#125;&quot;</span>, count);<br><span class="hljs-comment">//                if(count &lt;= 0) &#123;</span><br><span class="hljs-comment">//                    continue;</span><br><span class="hljs-comment">//                &#125;</span><br><br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br><br>                <span class="hljs-comment">// 遍历所有事件，逐一处理</span><br>                Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                    <span class="hljs-comment">// 判断事件类型</span><br>                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                        <span class="hljs-comment">// 必须处理</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                    &#125;<br>                    <span class="hljs-comment">// 处理完毕，必须将事件移除</span><br>                    iter.remove();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件发生后能否不处理">💡 事件发生后能否不处理</h4><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p><ul><li><p><strong>水平触发（level-triggered，也被称为条件触发）LT</strong>：只要满足条件，就触发一个事件。</p></li><li><p><strong>边缘触发（edge-triggered）ET</strong>：当状态变化时触发事件。</p></li></ul><h3 id="处理-read-事件">4.4 处理 read 事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelDemo6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>            channel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            System.out.println(channel);<br>            <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>            channel.configureBlocking(<span class="hljs-literal">false</span>);<br>            channel.register(selector, SelectionKey.OP_ACCEPT);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br><span class="hljs-comment">//                int count = selector.selectNow();</span><br>                log.debug(<span class="hljs-string">&quot;select count: &#123;&#125;&quot;</span>, count);<br><span class="hljs-comment">//                if(count &lt;= 0) &#123;</span><br><span class="hljs-comment">//                    continue;</span><br><span class="hljs-comment">//                &#125;</span><br><br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br><br>                <span class="hljs-comment">// 遍历所有事件，逐一处理</span><br>                Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                    <span class="hljs-comment">// 判断事件类型</span><br>                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                        <span class="hljs-comment">// 必须处理</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                        sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                        sc.register(selector, SelectionKey.OP_READ);<br>                        log.debug(<span class="hljs-string">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> sc.read(buffer);<br>                        <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>) &#123;<br>                            key.cancel();<br>                            sc.close();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            buffer.flip();<br>                            debug(buffer);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 处理完毕，必须将事件移除</span><br>                    iter.remove();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>开启两个客户端，修改一下发送文字，输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]<br>21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1<br>21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]<br>21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 68 65 6c 6c 6f                                  |hello           |<br>+--------+-------------------------------------------------+----------------+<br>21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1<br>21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]<br>21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 77 6f 72 6c 64                                  |world           |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h4 id="为何要-iter.remove">💡 为何要 iter.remove()</h4><p><strong>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除</strong>。例如</p><ul><li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey</li><li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，<strong>在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</strong></li></ul><h4 id="cancel-的作用">💡 cancel 的作用</h4><p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p><h4 id="不处理边界的问题">⚠️ 不处理边界的问题</h4><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ServerSocket ss=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9000</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> ss.accept();<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> s.getInputStream();<br>            <span class="hljs-comment">// 这里这么写，有没有问题</span><br>            <span class="hljs-type">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> in.read(arr);<br>                <span class="hljs-comment">// 这里这么写，有没有问题</span><br>                <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr, <span class="hljs-number">0</span>, read));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9000</span>);<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> max.getOutputStream();<br>        out.write(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<br>        out.write(<span class="hljs-string">&quot;world&quot;</span>.getBytes());<br>        out.write(<span class="hljs-string">&quot;你好&quot;</span>.getBytes());<br>        max.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hell<br>owor<br>ld�<br>�好<br><br></code></pre></td></tr></table></figure><p>为什么？</p><h4 id="处理消息的边界">处理消息的边界</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0023.png"></p><ul><li><strong>一种思路是固定消息长度</strong>，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li><li><strong>另一种思路是按分隔符拆分</strong>，缺点是效率低</li><li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式</li></ul></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/image-20230905150543762.png"></p><p>服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(ByteBuffer source)</span> &#123;<br>    source.flip();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; source.limit(); i++) &#123;<br>        <span class="hljs-comment">// 找到一条完整消息</span><br>        <span class="hljs-keyword">if</span> (source.get(i) == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span> - source.position();<br>            <span class="hljs-comment">// 把这条完整消息存入新的 ByteBuffer</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(length);<br>            <span class="hljs-comment">// 从 source 读，向 target 写</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                target.put(source.get());<br>            &#125;<br>            debugAll(target);<br>        &#125;<br>    &#125;<br>    source.compact(); <span class="hljs-comment">// 0123456789abcdef  position 16 limit 16</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1. 创建 selector, 管理多个 channel</span><br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 2. 建立 selector 和 channel 的联系（注册）</span><br>    <span class="hljs-comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span><br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sscKey</span> <span class="hljs-operator">=</span> ssc.register(selector, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// key 只关注 accept 事件</span><br>    sscKey.interestOps(SelectionKey.OP_ACCEPT);<br>    log.debug(<span class="hljs-string">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);<br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span><br>        <span class="hljs-comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span><br>        selector.select();<br>        <span class="hljs-comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span><br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="hljs-comment">// accept, read</span><br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>            <span class="hljs-comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span><br>            iter.remove();<br>            log.debug(<span class="hljs-string">&quot;key: &#123;&#125;&quot;</span>, key);<br>            <span class="hljs-comment">// 5. 区分事件类型</span><br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123; <span class="hljs-comment">// 如果是 accept</span><br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> channel.accept();<br>                sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>); <span class="hljs-comment">// attachment</span><br>                <span class="hljs-comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span><br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">scKey</span> <span class="hljs-operator">=</span> sc.register(selector, <span class="hljs-number">0</span>, buffer);<br>                scKey.interestOps(SelectionKey.OP_READ);<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                log.debug(<span class="hljs-string">&quot;scKey:&#123;&#125;&quot;</span>, scKey);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123; <span class="hljs-comment">// 如果是 read</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel(); <span class="hljs-comment">// 拿到触发事件的channel</span><br>                    <span class="hljs-comment">// 获取 selectionKey 上关联的附件</span><br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer); <span class="hljs-comment">// 如果是正常断开，read 的方法的返回值是 -1</span><br>                    <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>) &#123;<br>                        key.cancel();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        split(buffer);<br>                        <span class="hljs-comment">// 需要扩容</span><br>                        <span class="hljs-keyword">if</span> (buffer.position() == buffer.limit()) &#123;<br>                            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="hljs-number">2</span>);<br>                            buffer.flip();<br>                            newBuffer.put(buffer); <span class="hljs-comment">// 0123456789abcdef3333\n</span><br>                            key.attach(newBuffer);<br>                        &#125;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                    key.cancel();  <span class="hljs-comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br><span class="hljs-type">SocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> sc.getLocalAddress();<br><span class="hljs-comment">// sc.write(Charset.defaultCharset().encode(&quot;hello\nworld\n&quot;));</span><br>sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;0123\n456789abcdef&quot;</span>));<br>sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;0123456789abcdef3333\n&quot;</span>));<br>System.in.read();<br></code></pre></td></tr></table></figure><h4 id="bytebuffer-大小分配">ByteBuffer 大小分配</h4><ul><li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要<strong>设计大小可变的 ByteBuffer</strong><ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h3 id="处理-write-事件">4.5 处理 write 事件</h3><h4 id="一次无法写完例子">一次无法写完例子</h4><ul><li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li><li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul><li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li><li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li><li>如果不取消，会每次可写均会触发 write 事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            selector.select();<br><br>            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                iter.remove();<br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>                    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sckey</span> <span class="hljs-operator">=</span> sc.register(selector, SelectionKey.OP_READ);<br>                    <span class="hljs-comment">// 1. 向客户端发送内容</span><br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3000000</span>; i++) &#123;<br>                        sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> Charset.defaultCharset().encode(sb.toString());<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buffer);<br>                    <span class="hljs-comment">// 3. write 表示实际写了多少字节</span><br>                    System.out.println(<span class="hljs-string">&quot;实际写入字节:&quot;</span> + write);<br>                    <span class="hljs-comment">// 4. 如果有剩余未读字节，才需要关注写事件</span><br>                    <span class="hljs-keyword">if</span> (buffer.hasRemaining()) &#123;<br>                        <span class="hljs-comment">// read 1  write 4</span><br>                        <span class="hljs-comment">// 在原有关注事件的基础上，多关注 写事件</span><br>                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);<br>                        <span class="hljs-comment">// 把 buffer 作为附件加入 sckey</span><br>                        sckey.attach(buffer);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buffer);<br>                    System.out.println(<span class="hljs-string">&quot;实际写入字节:&quot;</span> + write);<br>                    <span class="hljs-keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="hljs-comment">// 写完了</span><br>                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);<br>                        key.attach(<span class="hljs-literal">null</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>        sc.configureBlocking(<span class="hljs-literal">false</span>);<br>        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);<br>        sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            selector.select();<br>            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                iter.remove();<br>                <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>                    System.out.println(sc.finishConnect());<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>                    count += sc.read(buffer);<br>                    buffer.clear();<br>                    System.out.println(count);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="write-为何要取消">💡 write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p><h3 id="更进一步">4.6 更进一步</h3><h4 id="利用多线程优化">💡 利用多线程优化</h4><blockquote><p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费</p></blockquote><p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p><p>分两组选择器</p><ul><li>单线程配一个选择器，专门处理 accept 事件</li><li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelDemo7</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BossEventLoop</span>().register();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BossEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> Selector boss;<br>        <span class="hljs-keyword">private</span> WorkerEventLoop[] workers;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>                ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>                ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>                boss = Selector.open();<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">ssckey</span> <span class="hljs-operator">=</span> ssc.register(boss, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br>                ssckey.interestOps(SelectionKey.OP_ACCEPT);<br>                workers = initEventLoops();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;boss&quot;</span>).start();<br>                log.debug(<span class="hljs-string">&quot;boss start...&quot;</span>);<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;<br><span class="hljs-comment">//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];</span><br>            WorkerEventLoop[] workerEventLoops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerEventLoop</span>[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; workerEventLoops.length; i++) &#123;<br>                workerEventLoops[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerEventLoop</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> workerEventLoops;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    boss.select();<br>                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        iter.remove();<br>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                            <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                            sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                            log.debug(<span class="hljs-string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());<br>                            workers[index.getAndIncrement() % workers.length].register(sc);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> Selector worker;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">WorkerEventLoop</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>            <span class="hljs-built_in">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(SocketChannel sc)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                worker = Selector.open();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;worker-&quot;</span> + index).start();<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>            tasks.add(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sckey</span> <span class="hljs-operator">=</span> sc.register(worker, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br>                    sckey.interestOps(SelectionKey.OP_READ);<br>                    worker.selectNow();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            worker.wakeup();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    worker.select();<br>                    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> tasks.poll();<br>                    <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>                        task.run();<br>                    &#125;<br>                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();<br>                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> sc.read(buffer);<br>                                <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                                    key.cancel();<br>                                    sc.close();<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    buffer.flip();<br>                                    log.debug(<span class="hljs-string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());<br>                                    debugAll(buffer);<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                                e.printStackTrace();<br>                                key.cancel();<br>                                sc.close();<br>                            &#125;<br>                        &#125;<br>                        iter.remove();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="如何拿到-cpu-个数">💡 如何拿到 cpu 个数</h4><blockquote><ul><li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li><li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li></ul></blockquote><h3 id="udp">4.7 UDP</h3><ul><li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li><li>server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃</li></ul><p>首先启动服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UdpServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> DatagramChannel.open()) &#123;<br>            channel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>            System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">32</span>);<br>            channel.receive(buffer);<br>            buffer.flip();<br>            debug(buffer);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">waiting...<br></code></pre></td></tr></table></figure><p>运行客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UdpClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> DatagramChannel.open()) &#123;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;hello&quot;</span>);<br>            <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>);<br>            channel.send(buffer, address);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来服务器端输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 68 65 6c 6c 6f                                  |hello           |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h2 id="nio-vs-bio">5. NIO vs BIO</h2><h3 id="stream-vs-channel">5.1 stream vs channel</h3><ul><li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li><li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li><li>二者均为全双工，即读写可以同时进行</li></ul><h3 id="io-模型">5.2 IO 模型</h3><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</p><ul><li>同步：线程自己去获取结果（一个线程）</li><li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li></ul><p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p><ul><li>等待数据阶段</li><li>复制数据阶段</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0033.png"></p><ul><li><p>阻塞 IO</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0039.png"></p></li><li><p>非阻塞 IO</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0035.png"></p></li><li><p>多路复用</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0038.png"></p></li><li><p>信号驱动</p></li><li><p>异步 IO</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0037.png"></p></li></ul><hr><ul><li><p>阻塞 IO vs 多路复用</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0034.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0036.png"></p></li></ul><h4 id="参考">🔖 参考</h4><p>UNIX 网络编程 - 卷 I</p><h3 id="零拷贝">5.3 零拷贝</h3><h4 id="传统-io-问题">传统 IO 问题</h4><p><strong>传统的 IO 将一个文件通过 socket 写出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)f.length()];<br>file.read(buf);<br><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ...;<br>socket.getOutputStream().write(buf);<br></code></pre></td></tr></table></figure><p>内部工作流程是这样的：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0024.png"></p><ol type="1"><li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p><blockquote><p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p></blockquote></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p></li><li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p></li><li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p></li></ol><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h4 id="nio-优化">NIO 优化</h4><p>通过 DirectByteBuf</p><ul><li>ByteBuffer.allocate(10) HeapByteBuffer 使用的还是 java 内存</li><li>ByteBuffer.allocateDirect(10) DirectByteBuffer 使用的是操作系统内存</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0025.png"></p><p>大部分步骤与优化前相同，不再赘述。唯有一点：<strong>java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</strong></p><ul><li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></li></ul><p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0026.png"></p><ol type="1"><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li></ol><p>可以看到</p><ul><li>只发生了一次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><p>进一步优化（linux 2.4）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Unicorn-acc/blogimgs/imgs05/0027.png"></p><ol type="1"><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li></ol><p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id="aio">5.3 AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP 实现了真正的异步 IO</li><li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li></ul></blockquote><h4 id="文件-aio">文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AioDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">AsynchronousFileChannel</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <br>                AsynchronousFileChannel.open(<br>                	Paths.get(<span class="hljs-string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            s.read(buffer, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;read completed...&#123;&#125;&quot;</span>, result);<br>                    buffer.flip();<br>                    debug(buffer);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;read failed...&quot;</span>);<br>                &#125;<br>            &#125;);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;do other things...&quot;</span>);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...<br>13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...<br>13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 61 0d                                           |a.              |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>可以看到</p><ul><li>响应文件读取成功的是另一个线程 Thread-5</li><li>主线程并没有 IO 操作阻塞</li></ul><h4 id="守护线程">💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p><h4 id="网络-aio">网络 AIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AioServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">AsynchronousServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> AsynchronousServerSocketChannel.open();<br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        ssc.accept(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AcceptHandler</span>(ssc));<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeChannel</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.printf(<span class="hljs-string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>            sc.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel sc;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReadHandler</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sc = sc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (result == -<span class="hljs-number">1</span>) &#123;<br>                    closeChannel(sc);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                System.out.printf(<span class="hljs-string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>                attachment.flip();<br>                System.out.println(Charset.defaultCharset().decode(attachment));<br>                attachment.clear();<br>                <span class="hljs-comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span><br>                sc.read(attachment, attachment, <span class="hljs-built_in">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>            closeChannel(sc);<br>            exc.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel sc;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">WriteHandler</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sc = sc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>            <span class="hljs-comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span><br>            <span class="hljs-keyword">if</span> (attachment.hasRemaining()) &#123;<br>                sc.write(attachment);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>            exc.printStackTrace();<br>            closeChannel(sc);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcceptHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousServerSocketChannel ssc;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AcceptHandler</span><span class="hljs-params">(AsynchronousServerSocketChannel ssc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.ssc = ssc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>            <span class="hljs-comment">// 读事件由 ReadHandler 处理</span><br>            sc.read(buffer, buffer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadHandler</span>(sc));<br>            <span class="hljs-comment">// 写事件由 WriteHandler 处理</span><br>            sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="hljs-number">16</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteHandler</span>(sc));<br>            <span class="hljs-comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span><br>            ssc.accept(<span class="hljs-literal">null</span>, <span class="hljs-built_in">this</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, Object attachment)</span> &#123;<br>            exc.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Unicorn-acc.github.io">Miraclo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://unicorn-acc.github.io/posts/49992.html">http://unicorn-acc.github.io/posts/49992.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Unicorn-acc.github.io" target="_blank">Miraclo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Netty/">Netty</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/kx/wallhaven-kx3p1q.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/23953.html"><img class="prev-cover" src="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Netty-02-Netty入门（HelloWorld、流程梳理、EventLoop、Channel、Handler、Future、ByteBuf）</div></div></a></div><div class="next-post pull-right"><a href="/posts/2958.html"><img class="next-cover" src="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">3天精通网页布局（学完这课网页布局可以随意玩）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/240.html" title="Netty-04-Netty优化和源码（还没看）"><img class="cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p9273e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="title">Netty-04-Netty优化和源码（还没看）</div></div></a></div><div><a href="/posts/23953.html" title="Netty-02-Netty入门（HelloWorld、流程梳理、EventLoop、Channel、Handler、Future、ByteBuf）"><img class="cover" src="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="title">Netty-02-Netty入门（HelloWorld、流程梳理、EventLoop、Channel、Handler、Future、ByteBuf）</div></div></a></div><div><a href="/posts/54466.html" title="Netty-03-Netty进阶（粘包与半包、解决方案、协议设计解析）"><img class="cover" src="https://w.wallhaven.cc/full/1p/wallhaven-1p1qjg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="title">Netty-03-Netty进阶（粘包与半包、解决方案、协议设计解析）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#netty-01-nio%E5%9F%BA%E7%A1%80"><span class="toc-text">Netty-01-NIO基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">1. 三大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#channel-buffer"><span class="toc-text">1.1 Channel &amp; Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selector"><span class="toc-text">1.2 Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E8%AE%BE%E8%AE%A1"><span class="toc-text">多线程版设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E7%BC%BA%E7%82%B9"><span class="toc-text">⚠️ 多线程版缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E8%AE%BE%E8%AE%A1"><span class="toc-text">线程池版设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E7%BC%BA%E7%82%B9"><span class="toc-text">⚠️ 线程池版缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#selector-%E7%89%88%E8%AE%BE%E8%AE%A1"><span class="toc-text">selector 版设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bytebuffer"><span class="toc-text">2. ByteBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bytebuffer-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="toc-text">2.1 ByteBuffer 正确使用姿势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bytebuffer-%E7%BB%93%E6%9E%84"><span class="toc-text">2.2 ByteBuffer 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">💡 调试工具类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bytebuffer-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">2.3 ByteBuffer 常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">分配空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91-buffer-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">向 buffer 写入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-buffer-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">从 buffer 读取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mark-%E5%92%8C-reset"><span class="toc-text">mark 和 reset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E-bytebuffer-%E4%BA%92%E8%BD%AC"><span class="toc-text">字符串与 ByteBuffer 互转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#buffer-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">⚠️ Buffer 的线程安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scattering-reads"><span class="toc-text">2.4 Scattering Reads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gathering-writes"><span class="toc-text">2.5 Gathering Writes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-text">2.6 练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-text">3. 文件编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#filechannel"><span class="toc-text">3.1 FileChannel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#filechannel-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">⚠️ FileChannel 工作模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96"><span class="toc-text">获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96"><span class="toc-text">读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5"><span class="toc-text">写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD"><span class="toc-text">关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE"><span class="toc-text">位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F"><span class="toc-text">大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%86%99%E5%85%A5"><span class="toc-text">强制写入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA-channel-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="toc-text">3.2 两个 Channel 传输数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#path"><span class="toc-text">3.3 Path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#files"><span class="toc-text">3.4 Files</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%BE%88%E5%8D%B1%E9%99%A9"><span class="toc-text">⚠️ 删除很危险</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">4. 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E-vs-%E9%98%BB%E5%A1%9E"><span class="toc-text">4.1 非阻塞 vs 阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">✔多路复用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selector-1"><span class="toc-text">4.2 Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-channel-%E4%BA%8B%E4%BB%B6"><span class="toc-text">绑定 Channel 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC-channel-%E4%BA%8B%E4%BB%B6"><span class="toc-text">监听 Channel 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select-%E4%BD%95%E6%97%B6%E4%B8%8D%E9%98%BB%E5%A1%9E"><span class="toc-text">💡 select 何时不阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-accept-%E4%BA%8B%E4%BB%B6"><span class="toc-text">4.3 处理 accept 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E5%90%8E%E8%83%BD%E5%90%A6%E4%B8%8D%E5%A4%84%E7%90%86"><span class="toc-text">💡 事件发生后能否不处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-read-%E4%BA%8B%E4%BB%B6"><span class="toc-text">4.4 处理 read 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E8%A6%81-iter.remove"><span class="toc-text">💡 为何要 iter.remove()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cancel-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">💡 cancel 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">⚠️ 不处理边界的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="toc-text">处理消息的边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bytebuffer-%E5%A4%A7%E5%B0%8F%E5%88%86%E9%85%8D"><span class="toc-text">ByteBuffer 大小分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-write-%E4%BA%8B%E4%BB%B6"><span class="toc-text">4.5 处理 write 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%97%A0%E6%B3%95%E5%86%99%E5%AE%8C%E4%BE%8B%E5%AD%90"><span class="toc-text">一次无法写完例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write-%E4%B8%BA%E4%BD%95%E8%A6%81%E5%8F%96%E6%B6%88"><span class="toc-text">💡 write 为何要取消</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5"><span class="toc-text">4.6 更进一步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96"><span class="toc-text">💡 利用多线程优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0-cpu-%E4%B8%AA%E6%95%B0"><span class="toc-text">💡 如何拿到 cpu 个数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#udp"><span class="toc-text">4.7 UDP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nio-vs-bio"><span class="toc-text">5. NIO vs BIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stream-vs-channel"><span class="toc-text">5.1 stream vs channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-%E6%A8%A1%E5%9E%8B"><span class="toc-text">5.2 IO 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">🔖 参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-text">5.3 零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-io-%E9%97%AE%E9%A2%98"><span class="toc-text">传统 IO 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nio-%E4%BC%98%E5%8C%96"><span class="toc-text">NIO 优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aio"><span class="toc-text">5.3 AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-aio"><span class="toc-text">文件 AIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">💡 守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-aio"><span class="toc-text">网络 AIO</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Miraclo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人只有在走上坡路的时候才会累和迷茫。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.1},options:{renderActions:{findScript:[10,t=>{for(const n of document.querySelectorAll('script[type^="math/tex"]')){var e=!!n.type.match(/; *mode=display/),e=new t.options.MathItem(n.textContent,t.inputJax[0],e),a=document.createTextNode("");n.parentNode.replaceChild(a,n),e.start={node:a,delim:"",n:0},e.end={node:a,delim:"",n:0},t.math.push(e)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t.hasAttribute("display")?btf.wrap(t,"div",{class:"mathjax-overflow"}):btf.wrap(t,"span",{class:"mathjax-overflow"})})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script></div><link rel="stylesheet" href="/css/Lete.css"><script src="/js/custom.js"></script><script src="/js/mouth.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1s"),arr[i].setAttribute("data-wow-delay","1ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>